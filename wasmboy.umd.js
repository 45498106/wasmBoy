(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.WasmBoy = {})));
}(this, (function (exports) { 'use strict';

var index = typeof fetch=='function' ? fetch.bind() : function(url, options) {
	options = options || {};
	return new Promise( function (resolve, reject) {
		var request = new XMLHttpRequest();

		request.open(options.method || 'get', url);

		for (var i in options.headers) {
			request.setRequestHeader(i, options.headers[i]);
		}

		request.withCredentials = options.credentials=='include';

		request.onload = function () {
			resolve(response());
		};

		request.onerror = reject;

		request.send(options.body);

		function response() {
			var keys = [],
				all = [],
				headers = {},
				header;

			request.getAllResponseHeaders().replace(/^(.*?):\s*([\s\S]*?)$/gm, function (m, key, value) {
				keys.push(key = key.toLowerCase());
				all.push([key, value]);
				header = headers[key];
				headers[key] = header ? (header + "," + value) : value;
			});

			return {
				ok: (request.status/200|0) == 1,		// 200-299
				status: request.status,
				statusText: request.statusText,
				url: request.responseURL,
				clone: response,
				text: function () { return Promise.resolve(request.responseText); },
				json: function () { return Promise.resolve(request.responseText).then(JSON.parse); },
				blob: function () { return Promise.resolve(new Blob([request.response])); },
				headers: {
					keys: function () { return keys; },
					entries: function () { return all; },
					get: function (n) { return headers[n.toLowerCase()]; },
					has: function (n) { return n.toLowerCase() in headers; }
				}
			};
		}
	});
};
//# sourceMappingURL=unfetch.es.js.map

// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;

function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  Promise$1._immediateFn(function() {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self)
      throw new TypeError('A promise cannot be resolved with itself.');
    if (
      newValue &&
      (typeof newValue === 'object' || typeof newValue === 'function')
    ) {
      var then = newValue.then;
      if (newValue instanceof Promise$1) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise$1._immediateFn(function() {
      if (!self._handled) {
        Promise$1._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(
      function(value) {
        if (done) return;
        done = true;
        resolve(self, value);
      },
      function(reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      }
    );
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

function Promise$1(fn) {
  if (!(this instanceof Promise$1))
    throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  this._state = 0;
  this._handled = false;
  this._value = undefined;
  this._deferreds = [];

  doResolve(fn, this);
}

var _proto = Promise$1.prototype;
_proto.catch = function(onRejected) {
  return this.then(null, onRejected);
};

_proto.then = function(onFulfilled, onRejected) {
  var prom = new this.constructor(noop);

  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

Promise$1.all = function(arr) {
  return new Promise$1(function(resolve, reject) {
    if (!arr || typeof arr.length === 'undefined')
      throw new TypeError('Promise.all accepts an array');
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(
              val,
              function(val) {
                res(i, val);
              },
              reject
            );
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise$1.resolve = function(value) {
  if (value && typeof value === 'object' && value.constructor === Promise$1) {
    return value;
  }

  return new Promise$1(function(resolve) {
    resolve(value);
  });
};

Promise$1.reject = function(value) {
  return new Promise$1(function(resolve, reject) {
    reject(value);
  });
};

Promise$1.race = function(values) {
  return new Promise$1(function(resolve, reject) {
    for (var i = 0, len = values.length; i < len; i++) {
      values[i].then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
Promise$1._immediateFn =
  (typeof setImmediate === 'function' &&
    function(fn) {
      setImmediate(fn);
    }) ||
  function(fn) {
    setTimeoutFunc(fn, 0);
  };

Promise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

var encoded = "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ABA1BEAjBSQBQQQhAwUgAEH7ABA1BEAjBiQBQQQhAwUgAEH8ABA1BEAjByQBQQQhAwUgAEH9ABA1BEAjCCQBQQQhAwUgAEH+ABA1BEAjByMIEDQQEiQBQQQhAwUgAEH/ABA1BEBBBCEDBSAAQYABEDUEQCMDEEhBBCEDBSAAQYEBEDUEQCMEEEhBBCEDBSAAQYIBEDUEQCMFEEhBBCEDBSAAQYMBEDUEQCMGEEhBBCEDBSAAQYQBEDUEQCMHEEhBBCEDBSAAQYUBEDUEQCMIEEhBBCEDBSAAQYYBEDUEQCMHIwgQNBASEEhBCCEDBSAAQYcBEDUEQCMBEEhBBCEDBSAAQYgBEDUEQCMDEElBBCEDBSAAQYkBEDUEQCMEEElBBCEDBSAAQYoBEDUEQCMFEElBBCEDBSAAQYsBEDUEQCMGEElBBCEDBSAAQYwBEDUEQCMHEElBBCEDBSAAQY0BEDUEQCMIEElBBCEDBSAAQY4BEDUEQCMHIwgQNBASEElBCCEDBSAAQY8BEDUEQCMBEElBBCEDBSAAQZABEDUEQCMDEEpBBCEDBSAAQZEBEDUEQCMEEEpBBCEDBSAAQZIBEDUEQCMFEEpBBCEDBSAAQZMBEDUEQCMGEEpBBCEDBSAAQZQBEDUEQCMHEEpBBCEDBSAAQZUBEDUEQCMIEEpBBCEDBSAAQZYBEDUEQCMHIwgQNBASEEpBCCEDBSAAQZcBEDUEQCMBEEpBBCEDBSAAQZgBEDUEQCMDEEtBBCEDBSAAQZkBEDUEQCMEEEtBBCEDBSAAQZoBEDUEQCMFEEtBBCEDBSAAQZsBEDUEQCMGEEtBBCEDBSAAQZwBEDUEQCMHEEtBBCEDBSAAQZ0BEDUEQCMIEEtBBCEDBSAAQZ4BEDUEQCMHIwgQNBASEEtBCCEDBSAAQZ8BEDUEQCMBEEtBBCEDBSAAQaABEDUEQCMDEExBBCEDBSAAQaEBEDUEQCMEEExBBCEDBSAAQaIBEDUEQCMFEExBBCEDBSAAQaMBEDUEQCMGEExBBCEDBSAAQaQBEDUEQCMHEExBBCEDBSAAQaUBEDUEQCMIEExBBCEDBSAAQaYBEDUEQCMHIwgQNBASEExBCCEDBSAAQacBEDUEQCMBEExBBCEDBSAAQagBEDUEQCMDEE1BBCEDBSAAQakBEDUEQCMEEE1BBCEDBSAAQaoBEDUE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cmVzcwY3d2FzbS9tZW1vcnkvbWVtb3J5TWFwL2dldFdhc21Cb3lPZmZzZXRGcm9tR2FtZUJveU9mZnNldAcxd2FzbS9tZW1vcnkvc3RvcmUvX2VpZ2h0Qml0U3RvcmVJbnRvV2FzbUJveU1lbW9yeQg0d2FzbS9tZW1vcnkvc3RvcmUvZWlnaHRCaXRTdG9yZUludG9HQk1lbW9yeVNraXBUcmFwcwkgd2FzbS9oZWxwZXJzL2luZGV4L3NwbGl0SGlnaEJ5dGUKH3dhc20vaGVscGVycy9pbmRleC9zcGxpdExvd0J5dGULNndhc20vbWVtb3J5L3N0b3JlL3NpeHRlZW5CaXRTdG9yZUludG9HQk1lbW9yeVNraXBUcmFwcwwvd2FzbS9tZW1vcnkvbG9hZC9fZWlnaHRCaXRMb2FkRnJvbVdhc21Cb3lNZW1vcnkNMndhc20vbWVtb3J5L2xvYWQvZWlnaHRCaXRMb2FkRnJvbUdCTWVtb3J5U2tpcFRyYXBzDiF3YXNtL2hlbHBlcnMvaW5kZXgvcmVzZXRCaXRPbkJ5dGUPH3dhc20vaGVscGVycy9pbmRleC9zZXRCaXRPbkJ5dGUQIHdhc20vam95cGFkL2luZGV4L2dldEpveXBhZFN0YXRlESR3YXNtL21lbW9yeS9yZWFkVHJhcHMvY2hlY2tSZWFkVHJhcHMSKXdhc20vbWVtb3J5L2xvYWQvZWlnaHRCaXRMb2FkRnJvbUdCTWVtb3J5Eyp3YXNtL3NvdW5kL3JlZ2lzdGVycy9nZXRSZWdpc3RlcjFPZkNoYW5uZWwUKXdhc20vc291bmQvbGVuZ3RoL3NldENoYW5uZWxMZW5ndGhDb3VudGVyFSp3YXNtL3NvdW5kL3JlZ2lzdGVycy9nZXRSZWdpc3RlcjRPZkNoYW5uZWwWKndhc20vc291bmQvcmVnaXN0ZXJzL2dldFJlZ2lzdGVyM09mQ2hhbm5lbBcod2FzbS9zb3VuZC9mcmVxdWVuY3kvZ2V0Q2hhbm5lbEZyZXF1ZW5jeRgqd2FzbS9zb3VuZC9yZWdpc3RlcnMvZ2V0UmVnaXN0ZXIyT2ZDaGFubmVsGSx3YXNtL3NvdW5kL2VudmVsb3BlL2dldENoYW5uZWxFbnZlbG9wZVBlcmlvZBotd2FzbS9zb3VuZC9yZWdpc3RlcnMvZ2V0Q2hhbm5lbFN0YXJ0aW5nVm9sdW1lGyJ3YXNtL3NvdW5kL2NoYW5uZWwxL2lzU3dlZXBFbmFibGVkHCx3YXNtL3NvdW5kL2NoYW5uZWwxL2dldE5ld0ZyZXF1ZW5jeUZyb21Td2VlcB0qd2FzbS9zb3VuZC9yZWdpc3RlcnMvc2V0UmVnaXN0ZXIzT2ZDaGFubmVsHip3YXNtL3NvdW5kL3JlZ2lzdGVycy9zZXRSZWdpc3RlcjRPZkNoYW5uZWwfKHdhc20vc291bmQvZnJlcXVlbmN5L3NldENoYW5uZWxGcmVxdWVuY3kgMndhc20vc291bmQvY2hhbm5lbDEvY2FsY3VsYXRlU3dlZXBBbmRDaGVja092ZXJmbG93ISh3YXNtL3NvdW5kL3JlZ2lzdGVycy9pc0NoYW5uZWxEYWNFbmFibGVkIiR3YXNtL3NvdW5kL2NoYW5uZWwxL0NoYW5uZWwxLnRyaWdnZXIjJHdhc20vc291bmQvY2hhbm5lbDIvQ2hhbm5lbDIudHJpZ2dlciQkd2FzbS9zb3VuZC9jaGFubmVsMy9DaGFubmVsMy50cmlnZ2VyJUJ3YXNtL3NvdW5kL2NoYW5uZWw0L0NoYW5uZWw0LmdldE5vaXNlQ2hhbm5lbERpdmlzb3JGcm9tRGl2aXNvckNvZGUmNndhc20vc291bmQvY2hhbm5lbDQvQ2hhbm5lbDQuZ2V0Tm9pc2VDaGFubmVsQ2xvY2tTaGlmdCc7d2FzbS9zb3VuZC9jaGFubmVsNC9DaGFubmVsNC5nZXROb2lzZUNoYW5uZWxGcmVxdWVuY3lQZXJpb2QoJHdhc20vc291bmQvY2hhbm5lbDQvQ2hhbm5lbDQudHJpZ2dlcikwd2FzbS9zb3VuZC9yZWdpc3RlcnMvaGFuZGxlZFdyaXRlVG9Tb3VuZFJlZ2lzdGVyKiN3YXNtL21lbW9yeS93cml0ZVRyYXBzL19kbWFUcmFuc2Zlcismd2FzbS9tZW1vcnkvd3JpdGVUcmFwcy9jaGVja1dyaXRlVHJhcHMsK3dhc20vbWVtb3J5L3N0b3JlL2VpZ2h0Qml0U3RvcmVJbnRvR0JNZW1vcnktJndhc20vbWVtb3J5L21lbW9yeS9pbml0aWFsaXplQ2FydHJpZGdlLid3YXNtL3NvdW5kL2NoYW5uZWwxL0NoYW5uZWwxLmluaXRpYWxpemUvJ3dhc20vc291bmQvY2hhbm5lbDIvQ2hhbm5lbDIuaW5pdGlhbGl6ZTAnd2FzbS9zb3VuZC9jaGFubmVsMy9DaGFubmVsMy5pbml0aWFsaXplMSd3YXNtL3NvdW5kL2NoYW5uZWw0L0NoYW5uZWw0LmluaXRpYWxpemUyIHdhc20vc291bmQvc291bmQvaW5pdGlhbGl6ZVNvdW5kMxl3YXNtL2NwdS9pbmRleC9pbml0aWFsaXplNCN3YXNtL2hlbHBlcnMvaW5kZXgvY29uY2F0ZW5hdGVCeXRlczUZd2FzbS9jcHUvb3Bjb2Rlcy9pc09wY29kZTYZd2FzbS9jcHUvZmxhZ3Mvc2V0RmxhZ0JpdDcfd2FzbS9jcHUvZmxhZ3Mvc2V0SGFsZkNhcnJ5RmxhZzgvd2FzbS9jcHUvZmxhZ3MvY2hlY2tBbmRTZXRFaWdodEJpdEhhbGZDYXJyeUZsYWc5Gndhc20vY3B1L2ZsYWdzL3NldFplcm9GbGFnOh53YXNtL2NwdS9mbGFncy9zZXRTdWJ0cmFjdEZsYWc7G3dhc20vY3B1L2ZsYWdzL3NldENhcnJ5RmxhZzwhd2FzbS9oZWxwZXJzL2luZGV4L3JvdGF0ZUJ5dGVMZWZ0PS13YXNtL21lbW9yeS9zdG9yZS9zaXh0ZWVuQml0U3RvcmVJbnRvR0JNZW1vcnk+NHdhc20vY3B1L2ZsYWdzL2NoZWNrQW5kU2V0U2l4dGVlbkJpdEZsYWdzQWRkT3ZlcmZsb3c/Indhc20vaGVscGVycy9pbmRleC9yb3RhdGVCeXRlUmlnaHRAG3dhc20vY3B1L2ZsYWdzL2dldENhcnJ5RmxhZ0Etd2FzbS9oZWxwZXJzL2luZGV4L3JvdGF0ZUJ5dGVMZWZ0VGhyb3VnaENhcnJ5Qht3YXNtL2NwdS9pbmRleC9yZWxhdGl2ZUp1bXBDLndhc20vaGVscGVycy9pbmRleC9yb3RhdGVCeXRlUmlnaHRUaHJvdWdoQ2FycnlEGndhc20vY3B1L2ZsYWdzL2dldFplcm9GbGFnRR93YXNtL2NwdS9mbGFncy9nZXRIYWxmQ2FycnlGbGFnRh53YXNtL2NwdS9mbGFncy9nZXRTdWJ0cmFjdEZsYWdHK3dhc20vY3B1L2ZsYWdzL2NoZWNrQW5kU2V0RWlnaHRCaXRDYXJyeUZsYWdIIndhc20vY3B1L2luc3RydWN0aW9ucy9hZGRBUmVnaXN0ZXJJLndhc20vY3B1L2luc3RydWN0aW9ucy9hZGRBVGhyb3VnaENhcnJ5UmVnaXN0ZXJKIndhc20vY3B1L2luc3RydWN0aW9ucy9zdWJBUmVnaXN0ZXJLLndhc20vY3B1L2luc3RydWN0aW9ucy9zdWJBVGhyb3VnaENhcnJ5UmVnaXN0ZXJMIndhc20vY3B1L2luc3RydWN0aW9ucy9hbmRBUmVnaXN0ZXJNIndhc20vY3B1L2luc3RydWN0aW9ucy94b3JBUmVnaXN0ZXJOIXdhc20vY3B1L2luc3RydWN0aW9ucy9vckFSZWdpc3Rlck8hd2FzbS9jcHUvaW5zdHJ1Y3Rpb25zL2NwQVJlZ2lzdGVyUCt3YXNtL21lbW9yeS9sb2FkL3NpeHRlZW5CaXRMb2FkRnJvbUdCTWVtb3J5USh3YXNtL2NwdS9pbnN0cnVjdGlvbnMvcm90YXRlUmVnaXN0ZXJMZWZ0Uil3YXNtL2NwdS9pbnN0cnVjdGlvbnMvcm90YXRlUmVnaXN0ZXJSaWdodFM0d2FzbS9jcHUvaW5zdHJ1Y3Rpb25zL3JvdGF0ZVJlZ2lzdGVyTGVmdFRocm91Z2hDYXJyeVQ1d2FzbS9jcHUvaW5zdHJ1Y3Rpb25zL3JvdGF0ZVJlZ2lzdGVyUmlnaHRUaHJvdWdoQ2FycnlVJ3dhc20vY3B1L2luc3RydWN0aW9ucy9zaGlmdExlZnRSZWdpc3RlclYyd2FzbS9jcHUvaW5zdHJ1Y3Rpb25zL3NoaWZ0UmlnaHRBcml0aG1ldGljUmVnaXN0ZXJXK3dhc20vY3B1L2luc3RydWN0aW9ucy9zd2FwTmliYmxlc09uUmVnaXN0ZXJYL3dhc20vY3B1L2luc3RydWN0aW9ucy9zaGlmdFJpZ2h0TG9naWNhbFJlZ2lzdGVyWSd3YXNtL2NwdS9pbnN0cnVjdGlvbnMvdGVzdEJpdE9uUmVnaXN0ZXJaJndhc20vY3B1L2luc3RydWN0aW9ucy9zZXRCaXRPblJlZ2lzdGVyWyF3YXNtL2NwdS9jYk9wY29kZXMvaGFuZGxlQ2JPcGNvZGVcI3dhc20vaW50ZXJydXB0cy9pbmRleC9zZXRJbnRlcnJ1cHRzXR53YXNtL2NwdS9vcGNvZGVzL2V4ZWN1dGVPcGNvZGVeKndhc20vaW50ZXJydXB0cy9pbmRleC9hcmVJbnRlcnJ1cHRzRW5hYmxlZF8qd2FzbS9pbnRlcnJ1cHRzL2luZGV4L2FyZUludGVycnVwdHNQZW5kaW5nYCd3YXNtL3RpbWVycy9pbmRleC9fY2hlY2tEaXZpZGVyUmVnaXN0ZXJhIXdhc20vdGltZXJzL2luZGV4L19pc1RpbWVyRW5hYmxlZGIyd2FzbS90aW1lcnMvaW5kZXgvX2dldEN1cnJlbnRDeWNsZUNvdW50ZXJGcmVxdWVuY3ljJ3dhc20vaW50ZXJydXB0cy9pbmRleC9fcmVxdWVzdEludGVycnVwdGQrd2FzbS9pbnRlcnJ1cHRzL2luZGV4L3JlcXVlc3RUaW1lckludGVycnVwdGUed2FzbS90aW1lcnMvaW5kZXgvdXBkYXRlVGltZXJzZh53YXNtL2dyYXBoaWNzL2xjZC9pc0xjZEVuYWJsZWRnKXdhc20vaW50ZXJydXB0cy9pbmRleC9yZXF1ZXN0TGNkSW50ZXJydXB0aB53YXNtL2dyYXBoaWNzL2xjZC9zZXRMY2RTdGF0dXNpLHdhc20vZ3JhcGhpY3MvcmVuZGVyVXRpbHMvZ2V0VGlsZURhdGFBZGRyZXNzai13YXNtL2dyYXBoaWNzL3JlbmRlclV0aWxzL2dldENvbG9yRnJvbVBhbGV0dGVrIndhc20vbWVtb3J5L21lbW9yeS9zZXRQaXhlbE9uRnJhbWVsKXdhc20vZ3JhcGhpY3MvYmFja2dyb3VuZC9yZW5kZXJCYWNrZ3JvdW5kbSF3YXNtL2dyYXBoaWNzL3dpbmRvdy9yZW5kZXJXaW5kb3duIndhc20vbWVtb3J5L21lbW9yeS9nZXRQaXhlbE9uRnJhbWVvI3dhc20vZ3JhcGhpY3Mvc3ByaXRlcy9yZW5kZXJTcHJpdGVzcCR3YXNtL2dyYXBoaWNzL2dyYXBoaWNzL19kcmF3U2NhbmxpbmVxKXdhc20vbWVtb3J5L21lbW9yeS9zdG9yZUZyYW1lVG9CZVJlbmRlcmVkcix3YXNtL2ludGVycnVwdHMvaW5kZXgvcmVxdWVzdFZCbGFua0ludGVycnVwdHMld2FzbS9ncmFwaGljcy9ncmFwaGljcy91cGRhdGVHcmFwaGljc3Qmd2FzbS9pbnRlcnJ1cHRzL2luZGV4L19oYW5kbGVJbnRlcnJ1cHR1JXdhc20vaW50ZXJydXB0cy9pbmRleC9jaGVja0ludGVycnVwdHN2KHdhc20vc291bmQvbGVuZ3RoL2lzQ2hhbm5lbExlbmd0aEVuYWJsZWR3KXdhc20vc291bmQvY2hhbm5lbDEvQ2hhbm5lbDEudXBkYXRlTGVuZ3RoeCl3YXNtL3NvdW5kL2NoYW5uZWwyL0NoYW5uZWwyLnVwZGF0ZUxlbmd0aHkpd2FzbS9zb3VuZC9jaGFubmVsMy9DaGFubmVsMy51cGRhdGVMZW5ndGh6KXdhc20vc291bmQvY2hhbm5lbDQvQ2hhbm5lbDQudXBkYXRlTGVuZ3Roeyh3YXNtL3NvdW5kL2NoYW5uZWwxL0NoYW5uZWwxLnVwZGF0ZVN3ZWVwfC13YXNtL3NvdW5kL2VudmVsb3BlL2dldENoYW5uZWxFbnZlbG9wZUFkZE1vZGV9K3dhc20vc291bmQvY2hhbm5lbDEvQ2hhbm5lbDEudXBkYXRlRW52ZWxvcGV+K3dhc20vc291bmQvY2hhbm5lbDIvQ2hhbm5lbDIudXBkYXRlRW52ZWxvcGV/K3dhc20vc291bmQvY2hhbm5lbDQvQ2hhbm5lbDQudXBkYXRlRW52ZWxvcGWAAR53YXNtL3NvdW5kL2R1dHkvZ2V0Q2hhbm5lbER1dHmBAT13YXNtL3NvdW5kL2R1dHkvaXNEdXR5Q3ljbGVDbG9ja1Bvc2l0aXZlT3JOZWdhdGl2ZUZvcldhdmVmb3JtggEmd2FzbS9zb3VuZC9jaGFubmVsMS9DaGFubmVsMS5nZXRTYW1wbGWDASZ3YXNtL3NvdW5kL2NoYW5uZWwyL0NoYW5uZWwyLmdldFNhbXBsZYQBJndhc20vc291bmQvY2hhbm5lbDMvQ2hhbm5lbDMuZ2V0U2FtcGxlhQE3d2FzbS9zb3VuZC9jaGFubmVsNC9DaGFubmVsNC5pc05vaXNlQ2hhbm5lbFdpZHRoTW9kZVNldIYBJndhc20vc291bmQvY2hhbm5lbDQvQ2hhbm5lbDQuZ2V0U2FtcGxlhwExd2FzbS9zb3VuZC9yZWdpc3RlcnMvaXNDaGFubmVsRW5hYmxlZE9uTGVmdE91dHB1dIgBMndhc20vc291bmQvcmVnaXN0ZXJzL2lzQ2hhbm5lbEVuYWJsZWRPblJpZ2h0T3V0cHV0iQEod2FzbS9zb3VuZC9zb3VuZC9nZXRTYW1wbGVBc1Vuc2lnbmVkQnl0ZYoBNXdhc20vbWVtb3J5L21lbW9yeS9zZXRMZWZ0QW5kUmlnaHRPdXRwdXRGb3JBdWRpb1F1ZXVliwEgd2FzbS9zb3VuZC9zb3VuZC9yZXNldEF1ZGlvUXVldWWMARx3YXNtL3NvdW5kL3NvdW5kL3VwZGF0ZVNvdW5kjQEed2FzbS9jcHUvb3Bjb2Rlcy9lbXVsYXRpb25TdGVwjgEXd2FzbS9jcHUvb3Bjb2Rlcy91cGRhdGWPATN3YXNtL2pveXBhZC9pbmRleC9fZ2V0Sm95cGFkQnV0dG9uU3RhdGVGcm9tQnV0dG9uSWSQATN3YXNtL2pveXBhZC9pbmRleC9fc2V0Sm95cGFkQnV0dG9uU3RhdGVGcm9tQnV0dG9uSWSRASx3YXNtL2ludGVycnVwdHMvaW5kZXgvcmVxdWVzdEpveXBhZEludGVycnVwdJIBJHdhc20vam95cGFkL2luZGV4L19wcmVzc0pveXBhZEJ1dHRvbpMBJndhc20vam95cGFkL2luZGV4L19yZWxlYXNlSm95cGFkQnV0dG9ulAEgd2FzbS9qb3lwYWQvaW5kZXgvc2V0Sm95cGFkU3RhdGWVASN3YXNtL3NvdW5kL3NvdW5kL2dldEF1ZGlvUXVldWVJbmRleJYBK3dhc20vbWVtb3J5L21lbW9yeS9nZXRTYXZlU3RhdGVNZW1vcnlPZmZzZXSXATJ3YXNtL21lbW9yeS9zdG9yZS9zdG9yZUJvb2xlYW5EaXJlY3RseVRvV2FzbU1lbW9yeZgBHHdhc20vY3B1L2luZGV4L0NwdS5zYXZlU3RhdGWZASl3YXNtL2dyYXBoaWNzL2dyYXBoaWNzL0dyYXBoaWNzLnNhdmVTdGF0ZZoBKndhc20vaW50ZXJydXB0cy9pbmRleC9JbnRlcnJ1cHRzLnNhdmVTdGF0ZZsBIndhc20vam95cGFkL2luZGV4L0pveXBhZC5zYXZlU3RhdGWcASN3YXNtL21lbW9yeS9tZW1vcnkvTWVtb3J5LnNhdmVTdGF0ZZ0BIndhc20vdGltZXJzL2luZGV4L1RpbWVycy5zYXZlU3RhdGWeASB3YXNtL3NvdW5kL3NvdW5kL1NvdW5kLnNhdmVTdGF0ZZ8BJndhc20vc291bmQvY2hhbm5lbDEvQ2hhbm5lbDEuc2F2ZVN0YXRloAEmd2FzbS9zb3VuZC9jaGFubmVsMi9DaGFubmVsMi5zYXZlU3RhdGWhASZ3YXNtL3NvdW5kL2NoYW5uZWwzL0NoYW5uZWwzLnNhdmVTdGF0ZaIBJndhc20vc291bmQvY2hhbm5lbDQvQ2hhbm5lbDQuc2F2ZVN0YXRlowEUd2FzbS9pbmRleC9zYXZlU3RhdGWkATJ3YXNtL21lbW9yeS9sb2FkL2xvYWRCb29sZWFuRGlyZWN0bHlGcm9tV2FzbU1lbW9yeaUBHHdhc20vY3B1L2luZGV4L0NwdS5sb2FkU3RhdGWmASl3YXNtL2dyYXBoaWNzL2dyYXBoaWNzL0dyYXBoaWNzLmxvYWRTdGF0ZacBKndhc20vaW50ZXJydXB0cy9pbmRleC9JbnRlcnJ1cHRzLmxvYWRTdGF0ZagBI3dhc20vbWVtb3J5L21lbW9yeS9NZW1vcnkubG9hZFN0YXRlqQEid2FzbS90aW1lcnMvaW5kZXgvVGltZXJzLmxvYWRTdGF0ZaoBIHdhc20vc291bmQvc291bmQvU291bmQubG9hZFN0YXRlqwEmd2FzbS9zb3VuZC9jaGFubmVsMS9DaGFubmVsMS5sb2FkU3RhdGWsASZ3YXNtL3NvdW5kL2NoYW5uZWwyL0NoYW5uZWwyLmxvYWRTdGF0Za0BJndhc20vc291bmQvY2hhbm5lbDMvQ2hhbm5lbDMubG9hZFN0YXRlrgEmd2FzbS9zb3VuZC9jaGFubmVsNC9DaGFubmVsNC5sb2FkU3RhdGWvARR3YXNtL2luZGV4L2xvYWRTdGF0ZbABF3dhc20vaW5kZXgvZ2V0UmVnaXN0ZXJBsQEXd2FzbS9pbmRleC9nZXRSZWdpc3RlckKyARd3YXNtL2luZGV4L2dldFJlZ2lzdGVyQ7MBF3dhc20vaW5kZXgvZ2V0UmVnaXN0ZXJEtAEXd2FzbS9pbmRleC9nZXRSZWdpc3RlckW1ARd3YXNtL2luZGV4L2dldFJlZ2lzdGVySLYBF3dhc20vaW5kZXgvZ2V0UmVnaXN0ZXJMtwEXd2FzbS9pbmRleC9nZXRSZWdpc3Rlcka4ARx3YXNtL2luZGV4L2dldFByb2dyYW1Db3VudGVyuQEad2FzbS9pbmRleC9nZXRTdGFja1BvaW50ZXK6ARx3YXNtL2luZGV4L2dldFByZXZpb3VzT3Bjb2RluwEkd2FzbS9pbmRleC9nZXRPcGNvZGVBdFByb2dyYW1Db3VudGVyvAEFc3RhcnQAKhBzb3VyY2VNYXBwaW5nVVJMGGluZGV4LnVudG91Y2hlZC53YXNtLm1hcA==";

function asciiToBinary(str) {
  if (typeof atob === 'function') {
    return atob(str);
  } else {
    return new Buffer(str, 'base64').toString('binary');
  }
}

function decode(encoded) {
  var binaryString = asciiToBinary(encoded);
  var bytes = new Uint8Array(binaryString.length);
  for (var i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
}

var wasmModule = (function (importObject) {
  return WebAssembly.instantiate(decode(encoded), importObject).then(function (r) {
    return r.instance;
  });
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

// Declare Our Constants
var GAMEBOY_CAMERA_WIDTH = 160;
var GAMEBOY_CAMERA_HEIGHT = 144;
var WASMBOY_MEMORY_CURRENT_RENDERED_FRAME = 0x028400;

var WasmBoyGraphicsService = function () {
  function WasmBoyGraphicsService() {
    classCallCheck(this, WasmBoyGraphicsService);

    this.wasmInstance = undefined;
    this.wasmByteMemory = undefined;

    this.canvasElement = undefined;
    this.canvasContext = undefined;
    this.canvasImageData = undefined;

    this.resizeThrottleTimeout = undefined;
  }

  createClass(WasmBoyGraphicsService, [{
    key: 'initialize',
    value: function initialize(canvasElement, wasmInstance, wasmByteMemory) {
      var _this = this;

      this.wasmInstance = wasmInstance;
      this.wasmByteMemory = wasmByteMemory;

      return new Promise$1(function (resolve, reject) {
        try {
          // Prepare our canvas
          _this.canvasElement = canvasElement;
          _this.canvasContext = _this.canvasElement.getContext('2d');
          _this.canvasImageData = _this.canvasContext.createImageData(GAMEBOY_CAMERA_WIDTH, GAMEBOY_CAMERA_HEIGHT);

          // Fill the canvas with a blank screen
          // using client width since we are not requiring a width and height oin the canvas
          // https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth
          // TODO: Mention respopnsive canvas scaling in the docs
          _this.canvasContext.clearRect(0, 0, _this.canvasElement.clientWidth, _this.canvasElement.clientHeight);
          _this.canvasContext.fillStyle = '#000000';
          _this.canvasContext.fillRect(0, 0, _this.canvasElement.clientWidth, _this.canvasElement.clientHeight);

          // Scale the canvas
          _this.scaleCanvas();

          // Listen for window resize events for scaling
          window.addEventListener("resize", function () {
            if (_this.resizeThrottleTimeout) {
              // Cancel the resize
              clearTimeout(_this.resizeThrottleTimeout);
            }

            _this.resizeThrottleTimeout = setTimeout(function () {
              _this.scaleCanvas();
            }, 100);
          });

          resolve();
        } catch (error) {
          reject(error);
        }
      });
    }

    // Function to scale the canvas to look nice and crisp

  }, {
    key: 'scaleCanvas',
    value: function scaleCanvas() {

      // Reset scale
      this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);

      // Need to set the attributes to match any css
      // https://stackoverflow.com/questions/2588181/canvas-is-stretched-when-using-css-but-normal-with-width-height-properties
      this.canvasElement.width = this.canvasElement.clientWidth;
      this.canvasElement.height = this.canvasElement.clientHeight;

      // Scale the canvas to the offsetWidth
      // Which will return the calculated width from css
      this.canvasContext.scale(this.canvasElement.clientWidth / GAMEBOY_CAMERA_WIDTH, this.canvasElement.clientHeight / GAMEBOY_CAMERA_HEIGHT);

      // Stop the image blurring, this must be called after the scale
      // https://stackoverflow.com/questions/18547042/resizing-a-canvas-image-without-blurring-it
      this.canvasContext.imageSmoothingEnabled = false;
    }
  }, {
    key: 'renderFrame',
    value: function renderFrame() {
      // Draw the pixels
      // 160x144
      // Split off our image Data
      var imageDataArray = [];

      for (var y = 0; y < GAMEBOY_CAMERA_HEIGHT; y++) {
        for (var x = 0; x < GAMEBOY_CAMERA_WIDTH; x++) {

          var pixelIndex = WASMBOY_MEMORY_CURRENT_RENDERED_FRAME + x + y * GAMEBOY_CAMERA_WIDTH;
          var color = this.wasmByteMemory[pixelIndex];

          // Doing graphics using second answer on:
          // https://stackoverflow.com/questions/4899799/whats-the-best-way-to-set-a-single-pixel-in-an-html5-canvas
          // Image Data mapping
          var imageDataIndex = (x + y * GAMEBOY_CAMERA_WIDTH) * 4;
          var rgba = [];
          var alpha = 255;

          if (color) {
            if (color === 1) {
              rgba = [255, 255, 255, alpha];
            } else if (color === 2) {
              rgba = [211, 211, 211, alpha];
            } else if (color === 3) {
              rgba = [169, 169, 169, alpha];
            } else {
              rgba = [0, 0, 0, alpha];
            }
          } else {
            // TODO: Remove this testing code:
            rgba = [255, 0, 0, 1];
          }

          for (var i = 0; i < rgba.length; i++) {
            imageDataArray[imageDataIndex + i] = rgba[i];
          }
        }
      }

      // Add our new imageData
      for (var _i = 0; _i < imageDataArray.length; _i++) {
        this.canvasImageData.data[_i] = imageDataArray[_i];
      }
      this.canvasContext.putImageData(this.canvasImageData, 0, 0);
      // drawImage to apply our canvas scale
      this.canvasContext.drawImage(this.canvasElement, 0, 0);
    }
  }]);
  return WasmBoyGraphicsService;
}();

var WasmBoyGraphics = new WasmBoyGraphicsService();

// Tons of help from:

// Define our constants
var DEFAULT_AUDIO_LATENCY = 0.1;
// https://docs.google.com/spreadsheets/d/17xrEzJk5-sCB9J2mMJcVnzhbE-XH_NvczVSQH9OHvRk/edit?usp=sharing
var WASMBOY_MEMORY_SOUND_INDEX = 0x053800;
var WASMBOY_SAMPLE_RATE = 48000;
// NOTE: Giving a really large sample rate gives more latency, but less pops!
var WASMBOY_MIN_NUMBER_OF_SAMPLES = 4096;

var WasmBoyAudioService = function () {
  function WasmBoyAudioService() {
    classCallCheck(this, WasmBoyAudioService);

    // Wasmboy instance and memory
    this.wasmInstance = undefined;
    this.wasmByteMemory = undefined;

    this.audioContext = undefined;
    this.audioBuffer = undefined;
    // The play time for our audio samples
    this.audioPlaytime = 0;
  }

  createClass(WasmBoyAudioService, [{
    key: 'initialize',
    value: function initialize(wasmInstance, wasmByteMemory) {
      this.wasmInstance = wasmInstance;
      this.wasmByteMemory = wasmByteMemory;

      // Get our Audio context
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      return Promise$1.resolve();
    }
  }, {
    key: 'playAudio',
    value: function playAudio() {

      // Wait until we fill the queue
      if (this.wasmInstance.exports.getAudioQueueIndex() < WASMBOY_MIN_NUMBER_OF_SAMPLES) {
        return;
      }

      // Check if we made it in time
      // Idea from: https://github.com/binji/binjgb/blob/master/demo/demo.js
      var audioContextCurrentTime = this.audioContext.currentTime;
      var audioContextCurrentTimeWithLatency = audioContextCurrentTime + DEFAULT_AUDIO_LATENCY;
      this.audioPlaytime = this.audioPlaytime || audioContextCurrentTimeWithLatency;

      if (this.audioPlaytime < audioContextCurrentTime) {
        // We took too long, or something happen and hiccup'd the emulator, reset audio playback times
        console.log('[Wasmboy] Reseting Audio Playback time: ' + this.audioPlaytime.toFixed(2) + ' < ' + audioContextCurrentTimeWithLatency.toFixed(2));
        this.audioPlaytime = audioContextCurrentTimeWithLatency;
      } else {
        // We made it! Go ahead and grab and play the pcm samples

        var wasmBoyNumberOfSamples = this.wasmInstance.exports.getAudioQueueIndex();

        this.audioBuffer = this.audioContext.createBuffer(2, wasmBoyNumberOfSamples, WASMBOY_SAMPLE_RATE);
        var leftChannelBuffer = this.audioBuffer.getChannelData(0);
        var rightChannelBuffer = this.audioBuffer.getChannelData(1);

        // Our index on our left/right buffers
        var bufferIndex = 0;

        // Iterate through our samples
        // * 2 For Left and right
        for (var i = WASMBOY_MEMORY_SOUND_INDEX; i - WASMBOY_MEMORY_SOUND_INDEX < wasmBoyNumberOfSamples * 2; i++) {

          // Get our audio sample
          var audioSample = this.wasmByteMemory[i];

          // Subtract 1 as it is added so the value is not empty
          audioSample -= 1;
          // Divide by 127 to get back to our float scale
          audioSample = audioSample / 127;
          // Subtract 1 to regain our sign
          audioSample -= 1;

          // Find which channel the sample is going to
          // Always Left / right, increase index
          if ((i - WASMBOY_MEMORY_SOUND_INDEX) % 2 == 0) {
            leftChannelBuffer[bufferIndex] = audioSample;
          } else {
            rightChannelBuffer[bufferIndex] = audioSample;
            // Increase the buffer index, since there are two samples (left and right) per index of a sample
            bufferIndex += 1;
          }

          // Clear the value
          this.wasmByteMemory[i] = 0;
        }

        // Reset the Audio Queue
        this.wasmInstance.exports.resetAudioQueue();

        // Get an AudioBufferSourceNode.
        // This is the AudioNode to use when we want to play an AudioBuffer
        var source = this.audioContext.createBufferSource();

        // set the buffer in the AudioBufferSourceNode
        source.buffer = this.audioBuffer;

        // connect the AudioBufferSourceNode to the
        // destination so we can hear the sound
        source.connect(this.audioContext.destination);

        // start the source playing
        source.start(this.audioPlaytime);

        // Set our new audio playtime goal
        this.audioPlaytime = this.audioPlaytime + wasmBoyNumberOfSamples / WASMBOY_SAMPLE_RATE;
      }
    }
  }, {
    key: 'debugSaveCurrentAudioBufferToWav',
    value: function debugSaveCurrentAudioBufferToWav() {

      if (!this.audioBuffer) {
        return;
      }

      // https://www.npmjs.com/package/audiobuffer-to-wav
      var toWav = require('audiobuffer-to-wav');
      // https://github.com/Jam3/audiobuffer-to-wav/blob/master/demo/index.js

      var wav = toWav(this.audioBuffer);
      var blob = new window.Blob([new DataView(wav)], {
        type: 'audio/wav'
      });

      var url = window.URL.createObjectURL(blob);
      var anchor = document.createElement('a');
      document.body.appendChild(anchor);
      anchor.style = 'display: none';
      anchor.href = url;
      anchor.download = 'audio.wav';
      anchor.click();
      window.URL.revokeObjectURL(url);
    }
  }]);
  return WasmBoyAudioService;
}();

var WasmBoyAudio = new WasmBoyAudioService();

// Define a keyboard key schema
var keyInputSchema = {
  ACTIVE: false,
  KEY_CODE: undefined

  // Define a gamepad button schema
  // https://w3c.github.io/gamepad/#remapping
};var gamepadInputSchema = {
  ACTIVE: false,
  BUTTON_ID: undefined,
  JOYSTICK: {
    AXIS_ID: undefined,
    IS_POSITIVE: undefined
  }
};

var touchInputSchema = {
  ACTIVE: false,
  ELEMENT: undefined,
  TYPE: undefined,
  DIRECTION: undefined,
  EVENT_HANDLER: undefined,
  BOUNDING_RECT: undefined

  // Define our finaly kerboard schema here
};var keyMapSchema = {
  UP: {
    KEYBOARD: [],
    GAMEPAD: [],
    TOUCHPAD: []
  },
  RIGHT: {
    KEYBOARD: [],
    GAMEPAD: [],
    TOUCHPAD: []
  },
  DOWN: {
    KEYBOARD: [],
    GAMEPAD: [],
    TOUCHPAD: []
  },
  LEFT: {
    KEYBOARD: [],
    GAMEPAD: [],
    TOUCHPAD: []
  },
  A: {
    KEYBOARD: [],
    GAMEPAD: [],
    TOUCHPAD: []
  },
  B: {
    KEYBOARD: [],
    GAMEPAD: [],
    TOUCHPAD: []
  },
  SELECT: {
    KEYBOARD: [],
    GAMEPAD: [],
    TOUCHPAD: []
  },
  START: {
    KEYBOARD: [],
    GAMEPAD: [],
    TOUCHPAD: []
  }
};

function getKeyInput(keyCode) {
  var input = Object.assign({}, keyInputSchema);
  input.KEY_CODE = keyCode;
  return input;
}

function getGamepadInput(gamepadButtonId, axisId, axisIsPositive) {
  var input = Object.assign({}, gamepadInputSchema);
  input.JOYSTICK = Object.assign({}, gamepadInputSchema.JOYSTICK);
  if (gamepadButtonId || gamepadButtonId === 0) {
    input.BUTTON_ID = gamepadButtonId;
  } else if (axisId !== undefined && axisIsPositive !== undefined) {
    input.JOYSTICK.AXIS_ID = axisId;
    input.JOYSTICK.IS_POSITIVE = axisIsPositive;
  }
  return input;
}

function getTouchInput(element, type, direction, eventHandler) {
  var input = Object.assign({}, touchInputSchema);

  // TODO: Check the type for a valid type

  // Add our passed parameters
  input.ELEMENT = element;
  input.TYPE = type;
  input.DIRECTION = direction;
  input.EVENT_HANDLER = eventHandler;

  // Add our bounding rect
  var boundingRect = input.ELEMENT.getBoundingClientRect();
  input.BOUNDING_RECT = boundingRect;

  // Define our eventListener functions
  var eventListenerCallback = function eventListenerCallback(event) {
    if (input.EVENT_HANDLER) {
      input.EVENT_HANDLER(event);
    }
  };

  // Add event listeners to the element
  input.ELEMENT.addEventListener("touchstart", eventListenerCallback);
  input.ELEMENT.addEventListener("touchmove", eventListenerCallback);
  input.ELEMENT.addEventListener("touchend", eventListenerCallback);
  input.ELEMENT.addEventListener("mousedown", eventListenerCallback);
  input.ELEMENT.addEventListener("mouseup", eventListenerCallback);

  return input;
}

function KeyMapSchema() {
  return Object.assign({}, keyMapSchema);
}

var Key = {

  BACKSPACE: 8,
  TAB: 9,
  RETURN: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  ESCAPE: 27,
  SPACE: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,

  ARROW_LEFT: 37,
  ARROW_UP: 38,
  ARROW_RIGHT: 39,
  ARROW_DOWN: 40,

  W: 87,
  A: 65,
  S: 83,
  D: 68,
  Q: 81,
  E: 69,
  X: 88,
  Z: 90,

  SEMI_COLON: 186,
  SINGLE_QUOTE: 222,
  BACK_SLASH: 220,

  NUMPAD_0: 96,
  NUMPAD_1: 97,
  NUMPAD_2: 98,
  NUMPAD_3: 99,
  NUMPAD_4: 100,
  NUMPAD_5: 101,
  NUMPAD_6: 102,
  NUMPAD_7: 103,
  NUMPAD_8: 104,
  NUMPAD_9: 105
};

var keymap = KeyMapSchema();

// Up
keymap.UP.KEYBOARD.push(getKeyInput(Key.ARROW_UP));
keymap.UP.KEYBOARD.push(getKeyInput(Key.W));
keymap.UP.KEYBOARD.push(getKeyInput(Key.NUMPAD_8));
keymap.UP.GAMEPAD.push(getGamepadInput(12));
keymap.UP.GAMEPAD.push(getGamepadInput(false, 1, false));
keymap.UP.GAMEPAD.push(getGamepadInput(false, 3, false));

// Right
keymap.RIGHT.KEYBOARD.push(getKeyInput(Key.ARROW_RIGHT));
keymap.RIGHT.KEYBOARD.push(getKeyInput(Key.D));
keymap.RIGHT.KEYBOARD.push(getKeyInput(Key.NUMPAD_6));
keymap.RIGHT.GAMEPAD.push(getGamepadInput(15));
keymap.RIGHT.GAMEPAD.push(getGamepadInput(false, 0, true));
keymap.RIGHT.GAMEPAD.push(getGamepadInput(false, 2, true));

// Down
keymap.DOWN.KEYBOARD.push(getKeyInput(Key.ARROW_DOWN));
keymap.DOWN.KEYBOARD.push(getKeyInput(Key.S));
keymap.DOWN.KEYBOARD.push(getKeyInput(Key.NUMPAD_5));
keymap.DOWN.KEYBOARD.push(getKeyInput(Key.NUMPAD_2));
keymap.DOWN.GAMEPAD.push(getGamepadInput(13));
keymap.DOWN.GAMEPAD.push(getGamepadInput(false, 1, true));
keymap.DOWN.GAMEPAD.push(getGamepadInput(false, 3, true));

// Left
keymap.LEFT.KEYBOARD.push(getKeyInput(Key.ARROW_LEFT));
keymap.LEFT.KEYBOARD.push(getKeyInput(Key.A));
keymap.LEFT.KEYBOARD.push(getKeyInput(Key.NUMPAD_4));
keymap.LEFT.GAMEPAD.push(getGamepadInput(14));
keymap.LEFT.GAMEPAD.push(getGamepadInput(false, 0, false));
keymap.LEFT.GAMEPAD.push(getGamepadInput(false, 2, false));

// A
keymap.A.KEYBOARD.push(getKeyInput(Key.X));
keymap.A.KEYBOARD.push(getKeyInput(Key.SEMI_COLON));
keymap.A.KEYBOARD.push(getKeyInput(Key.NUMPAD_7));
keymap.A.GAMEPAD.push(getGamepadInput(0));
keymap.A.GAMEPAD.push(getGamepadInput(1));

// B
keymap.B.KEYBOARD.push(getKeyInput(Key.Z));
keymap.B.KEYBOARD.push(getKeyInput(Key.ESCAPE));
keymap.B.KEYBOARD.push(getKeyInput(Key.SINGLE_QUOTE));
keymap.B.KEYBOARD.push(getKeyInput(Key.BACKSPACE));
keymap.B.KEYBOARD.push(getKeyInput(Key.NUMPAD_9));
keymap.B.GAMEPAD.push(getGamepadInput(2));
keymap.B.GAMEPAD.push(getGamepadInput(3));

// Start
keymap.START.KEYBOARD.push(getKeyInput(Key.RETURN));
keymap.START.KEYBOARD.push(getKeyInput(Key.SPACE));
keymap.START.KEYBOARD.push(getKeyInput(Key.NUMPAD_3));
keymap.START.GAMEPAD.push(getGamepadInput(9));

// Select
keymap.SELECT.KEYBOARD.push(getKeyInput(Key.SHIFT));
keymap.SELECT.KEYBOARD.push(getKeyInput(Key.TAB));
keymap.SELECT.KEYBOARD.push(getKeyInput(Key.BACK_SLASH));
keymap.SELECT.KEYBOARD.push(getKeyInput(Key.NUMPAD_1));
keymap.SELECT.GAMEPAD.push(getGamepadInput(8));

var KEYMAP = keymap;

var classCallCheck$1 = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass$1 = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

// Helpers for accessing gamepad
// Similar to: https://github.com/torch2424/picoDeploy/blob/master/src/assets/3pLibs/pico8gamepad/pico8gamepad.js
function getAnalogStickAxis(gamepad, axisId) {
  return gamepad.axes[axisId] || 0.0;
}

function isButtonPressed(gamepad, buttonId) {
  return gamepad.buttons[buttonId] ? gamepad.buttons[buttonId].pressed : false;
}

var ResponsiveGamepadService = function () {
  function ResponsiveGamepadService() {
    classCallCheck$1(this, ResponsiveGamepadService);

    // Our settings
    this.gamepadAnalogStickDeadZone = 0.25;
    this.keyMapKeys = Object.keys(KeyMapSchema());
    this.keyMap = KEYMAP;
  }

  createClass$1(ResponsiveGamepadService, [{
    key: 'initialize',
    value: function initialize(keyMap) {
      var _this = this;

      // Add our key event listeners
      window.addEventListener('keyup', function (event) {
        _this.updateKeyboard(event);
      });
      window.addEventListener('keydown', function (event) {
        _this.updateKeyboard(event);
      });

      // Add a resize listen to update the gamepad rect on resize
      window.addEventListener("resize", function () {
        _this.updateTouchpadRect();
      });

      if (keyMap) {
        this.keyMap = keyMap;
      }
    }
  }, {
    key: 'addTouchInput',
    value: function addTouchInput(keyMapKey, element, type, direction) {
      var _this2 = this;

      // Declare our touch input
      // TODO: May have to add the event handler after getting the input
      var touchInput = void 0;
      touchInput = getTouchInput(element, type, direction, function (event) {
        _this2.updateTouchpad(keyMapKey, touchInput, event);
      });

      // Add the input to our keymap
      this.keyMap[keyMapKey].TOUCHPAD.push(touchInput);
    }
  }, {
    key: 'getState',
    value: function getState() {
      var _this3 = this;

      // Keyboard handled by listeners on window

      // Update the gamepad state
      this.updateGamepad();

      // Touch Handled by listeners on touchInputs

      // Create an abstracted controller state
      var controllerState = {};

      // Loop through our Keys, and quickly build our controller state
      this.keyMapKeys.forEach(function (key) {

        // Find if any of the keyboard, gamepad or touchpad buttons are pressed
        var keyboardState = _this3.keyMap[key].KEYBOARD.some(function (keyInput) {
          return keyInput.ACTIVE;
        });

        if (keyboardState) {
          controllerState[key] = true;
          return;
        }

        // Find if any of the keyboard, gamepad or touchpad buttons are pressed
        var gamepadState = _this3.keyMap[key].GAMEPAD.some(function (gamepadInput) {
          return gamepadInput.ACTIVE;
        });

        if (gamepadState) {
          controllerState[key] = true;
          return;
        }

        // Find if any of the keyboard, gamepad or touchpad buttons are pressed
        var touchState = _this3.keyMap[key].TOUCHPAD.some(function (touchInput) {
          return touchInput.ACTIVE;
        });

        if (touchState) {
          controllerState[key] = true;
          return;
        }

        controllerState[key] = false;
      });

      // Return the controller state in case we need something from it
      return controllerState;
    }

    // Function to handle keyboard update events

  }, {
    key: 'updateKeyboard',
    value: function updateKeyboard(keyEvent) {
      var _this4 = this;

      // Get the new state of the key
      var isPressed = false;
      if (keyEvent.type === 'keydown') {
        isPressed = true;
      }

      // Loop through our keys
      this.keyMapKeys.forEach(function (key) {
        _this4.keyMap[key].KEYBOARD.forEach(function (keyInput, index) {
          if (keyInput.KEY_CODE === keyEvent.keyCode) {
            _this4.keyMap[key].KEYBOARD[index].ACTIVE = isPressed;
          }
        });
      });
    }

    // Function to check the gamepad API for the gamepad state

  }, {
    key: 'updateGamepad',
    value: function updateGamepad() {
      var _this5 = this;

      // Similar to: https://github.com/torch2424/picoDeploy/blob/master/src/assets/3pLibs/pico8gamepad/pico8gamepad.js
      // Gampad Diagram: https://www.html5rocks.com/en/tutorials/doodles/gamepad/#toc-gamepadinfo
      var gamepads = navigator.getGamepads ? navigator.getGamepads() : [];

      var _loop = function _loop(i) {

        // Get our current gamepad
        var gamepad = gamepads[i];

        if (!gamepad) {
          return 'continue';
        }

        // Loop through our keys
        _this5.keyMapKeys.forEach(function (key) {
          _this5.keyMap[key].GAMEPAD.forEach(function (gamepadInput, index) {

            // Check if we are a gamepad button
            if (_this5.keyMap[key].GAMEPAD[index].BUTTON_ID || _this5.keyMap[key].GAMEPAD[index].BUTTON_ID === 0) {
              _this5.keyMap[key].GAMEPAD[index].ACTIVE = isButtonPressed(gamepad, _this5.keyMap[key].GAMEPAD[index].BUTTON_ID);
            }

            // Check if we are an axis
            if (_this5.keyMap[key].GAMEPAD[index].JOYSTICK.AXIS_ID !== undefined && _this5.keyMap[key].GAMEPAD[index].JOYSTICK.IS_POSITIVE !== undefined) {
              if (_this5.keyMap[key].GAMEPAD[index].JOYSTICK.IS_POSITIVE) {
                _this5.keyMap[key].GAMEPAD[index].ACTIVE = getAnalogStickAxis(gamepad, _this5.keyMap[key].GAMEPAD[index].JOYSTICK.AXIS_ID) > +_this5.gamepadAnalogStickDeadZone;
              } else {
                _this5.keyMap[key].GAMEPAD[index].ACTIVE = getAnalogStickAxis(gamepad, _this5.keyMap[key].GAMEPAD[index].JOYSTICK.AXIS_ID) < -_this5.gamepadAnalogStickDeadZone;
              }
            }
          });
        });
      };

      for (var i = 0; i < gamepads.length; i++) {
        var _ret = _loop(i);

        if (_ret === 'continue') continue;
      }
    }

    // Function to update button position and size

  }, {
    key: 'updateTouchpadRect',
    value: function updateTouchpadRect() {
      var _this6 = this;

      // Read from the DOM, and get each of our elements position, doing this here, as it is best to read from the dom in sequence
      // use element.getBoundingRect() top, bottom, left, right to get clientX and clientY in touch events :)
      // https://stackoverflow.com/questions/442404/retrieve-the-position-x-y-of-an-html-element
      //console.log("GamepadComponent: Updating Rect()...");
      this.keyMapKeys.forEach(function (key) {
        _this6.keyMap[key].TOUCHPAD.forEach(function (touchInput, index) {
          var boundingRect = _this6.keyMap[key].TOUCHPAD[index].ELEMENT.getBoundingClientRect();
          _this6.keyMap[key].TOUCHPAD[index].BOUNDING_RECT = boundingRect;
        });
      });
    }

    // Reset all Diretion keys for a DPAD for touch Inputs

  }, {
    key: 'resetTouchDpad',
    value: function resetTouchDpad() {
      var _this7 = this;

      var dpadKeys = ['UP', 'RIGHT', 'DOWN', 'LEFT'];

      dpadKeys.forEach(function (dpadKey) {
        _this7.keyMap[dpadKey].TOUCHPAD.forEach(function (touchInput) {
          touchInput.ACTIVE = false;
        });
      });
    }

    // Function called on an event of a touchInput SVG Element

  }, {
    key: 'updateTouchpad',
    value: function updateTouchpad(keyMapKey, touchInput, event) {

      if (!event || event.type.includes('touch') && !event.touches) return;

      //event.stopPropagation();
      event.preventDefault();

      //this.debugCurrentTouch(event);

      // Check for active event types
      if (event.type === "touchstart" || event.type === "touchmove" || event.type === "mousedown") {
        // Active

        if (touchInput.TYPE === 'DPAD') {

          // Calculate for the correct key
          // Only using the first touch, since we shouldn't be having two fingers on the dpad
          var touch = void 0;
          if (event.type.includes('touch')) {
            touch = event.touches[0];
          } else if (event.type.includes('mouse')) {
            touch = event;
          }

          // Find if the horizontal or vertical influence is greater
          // Find our centers of our rectangles, and our unbiased X Y values on the rect
          var rectCenterX = (touchInput.BOUNDING_RECT.right - touchInput.BOUNDING_RECT.left) / 2;
          var rectCenterY = (touchInput.BOUNDING_RECT.bottom - touchInput.BOUNDING_RECT.top) / 2;
          var touchX = touch.clientX - touchInput.BOUNDING_RECT.left;
          var touchY = touch.clientY - touchInput.BOUNDING_RECT.top;

          // Lesson From: picoDeploy
          // Fix for shoot button causing the character to move right on multi touch error
          // + 50 for some buffer
          if (touchX > rectCenterX + touchInput.BOUNDING_RECT.width / 2 + 50) {
            // Ignore the event
            return;
          }

          // Create an additonal influece for horizontal, to make it feel better
          var horizontalInfluence = touchInput.BOUNDING_RECT.width / 8;

          // Determine if we are horizontal or vertical
          var isHorizontal = Math.abs(rectCenterX - touchX) + horizontalInfluence > Math.abs(rectCenterY - touchY);

          // Find if left or right from width, vice versa for height
          if (isHorizontal) {
            // Add a horizontal dead zone
            var deadzoneSize = touchInput.BOUNDING_RECT.width / 20;
            if (Math.abs(touchInput.BOUNDING_RECT.width / 2 - touchX) > deadzoneSize) {

              var isLeft = touchX < touchInput.BOUNDING_RECT.width / 2;

              if (isLeft && touchInput.DIRECTION === 'LEFT') {
                touchInput.ACTIVE = true;
              } else if (!isLeft && touchInput.DIRECTION === 'RIGHT') {
                touchInput.ACTIVE = true;
              } else {
                touchInput.ACTIVE = false;
              }
            }
          } else {
            var isUp = touchY < touchInput.BOUNDING_RECT.height / 2;
            if (isUp && touchInput.DIRECTION === 'UP') {
              touchInput.ACTIVE = true;
            } else if (!isUp && touchInput.DIRECTION === 'DOWN') {
              touchInput.ACTIVE = true;
            } else {
              touchInput.ACTIVE = false;
            }
          }
        }

        // Button Type
        if (touchInput.TYPE === 'BUTTON') {
          touchInput.ACTIVE = true;
        }
      } else {
        // Not active

        // Handle Dpad Type
        if (touchInput.TYPE === 'DPAD') {
          this.resetTouchDpad();
        }

        // Button Type
        if (touchInput.TYPE === 'BUTTON') {
          touchInput.ACTIVE = false;
        }
      }
    }
  }]);
  return ResponsiveGamepadService;
}();

// Exports


var ResponsiveGamepad = new ResponsiveGamepadService();

var WasmBoyControllerService = function () {
  function WasmBoyControllerService() {
    classCallCheck(this, WasmBoyControllerService);

    // Our wasm instance
    this.wasmInstance = undefined;
  }

  createClass(WasmBoyControllerService, [{
    key: 'initialize',
    value: function initialize(wasmInstance) {
      this.wasmInstance = wasmInstance;

      ResponsiveGamepad.initialize();

      return Promise$1.resolve();
    }
  }, {
    key: 'addTouchInput',
    value: function addTouchInput(keyMapKey, element, type, direction) {
      ResponsiveGamepad.addTouchInput(keyMapKey, element, type, direction);
    }
  }, {
    key: 'updateController',
    value: function updateController() {

      // Create an abstracted controller state
      var controllerState = ResponsiveGamepad.getState();

      // Set the new controller state on the instance
      this.wasmInstance.exports.setJoypadState(controllerState.UP ? 1 : 0, controllerState.RIGHT ? 1 : 0, controllerState.DOWN ? 1 : 0, controllerState.LEFT ? 1 : 0, controllerState.A ? 1 : 0, controllerState.B ? 1 : 0, controllerState.SELECT ? 1 : 0, controllerState.START ? 1 : 0);

      // Return the controller state in case we need something from it
      return controllerState;
    }
  }]);
  return WasmBoyControllerService;
}();

var WasmBoyController = new WasmBoyControllerService();

// Get our idb instance, and initialize to asn idb-keyval
// This is so we don't get the default keyval DB name. And will allow
// Parent projects to use the slimmer idb keyval
// https://www.npmjs.com/package/idb
var idb = require('idb');

var keyval = false;

// Get our idb dPromise
if (typeof window !== 'undefined') {
  var dbPromise = idb.open('wasmboy', 1, function (upgradeDB) {
    upgradeDB.createObjectStore('keyval');
  });

  // Get our idb-keyval instance
  keyval = {
    get: function get(key) {
      return dbPromise.then(function (db) {
        return db.transaction('keyval').objectStore('keyval').get(key);
      });
    },
    set: function set(key, val) {
      return dbPromise.then(function (db) {
        var tx = db.transaction('keyval', 'readwrite');
        tx.objectStore('keyval').put(val, key);
        return tx.complete;
      });
    },
    delete: function _delete(key) {
      return dbPromise.then(function (db) {
        var tx = db.transaction('keyval', 'readwrite');
        tx.objectStore('keyval').delete(key);
        return tx.complete;
      });
    },
    clear: function clear() {
      return dbPromise.then(function (db) {
        var tx = db.transaction('keyval', 'readwrite');
        tx.objectStore('keyval').clear();
        return tx.complete;
      });
    },
    keys: function keys() {
      return dbPromise.then(function (db) {
        var tx = db.transaction('keyval');
        var keys = [];
        var store = tx.objectStore('keyval');

        // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.
        // openKeyCursor isn't supported by Safari, so we fall back
        (store.iterateKeyCursor || store.iterateCursor).call(store, function (cursor) {
          if (!cursor) return;
          keys.push(cursor.key);
          cursor.continue();
        });

        return tx.complete.then(function () {
          return keys;
        });
      });
    }
  };
}

var idbKeyval = keyval;

// Going to set the key for idbKeyval as the cartridge header.
// Then, for each cartridge, it will return an object.
// there will be a cartridgeRam Key, settings Key, and a saveState key
// Not going to make one giant object, as we want to keep idb transactions light and fast

// Declare some memory constants
var MEMORY_ADDRESSES = {
  CARTRIDGE_RAM: 0x008400,
  CARTRIDGE_ROM: 0x073800,
  WASMBOY_INTERNAL_STATE: {
    LOCATION: 0x000000,
    SIZE: 0x000400
  },
  GAMEBOY_MEMORY: {
    LOCATION: 0x000400,
    SIZE: 0x008000
  }
};

var WASMBOY_UNLOAD_STORAGE = 'WASMBOY_UNLOAD_STORAGE';

//  Will save the state in parts, to easy memory map changes:
// https://docs.google.com/spreadsheets/d/17xrEzJk5-sCB9J2mMJcVnzhbE-XH_NvczVSQH9OHvRk/edit?usp=sharing
var WASMBOY_SAVE_STATE_SCHEMA = {
  wasmBoyMemory: {
    wasmBoyInternalState: [],
    gameBoyMemory: [],
    cartridgeRam: []
  },
  date: undefined,
  name: undefined,
  isAuto: undefined

  // Private function to get the cartridge header
};var getCartridgeHeader = function getCartridgeHeader(wasmByteMemory) {
  // Header is at 0x0134 - 0x014F
  // http://gbdev.gg8.se/wiki/articles/The_Cartridge_Header
  var headerLength = 0x014F - 0x0134;
  var headerArray = new Uint8Array(headerLength);
  for (var i = 0; i <= headerLength; i++) {
    // Get the CARTRIDGE_ROM + the offset to point us at the header, plus the current byte
    headerArray[i] = wasmByteMemory[MEMORY_ADDRESSES.CARTRIDGE_ROM + 0x0134 + i];
  }

  return headerArray;
};

// Private function to get the caretridge ram
var getCartridgeRam = function getCartridgeRam(wasmByteMemory) {
  // Depening on the rom type, we will have different ram sizes.
  // Due memory restrictions described in:
  // https://developers.google.com/web/fundamentals/instant-and-offline/web-storage/offline-for-pwa
  // We will make sure to only store as much as we need per ROM :)

  // Similar to `initializeCartridgeType()` in `wasm/memory/memory.ts`
  // We will determine our cartridge type
  // Get our game MBC type from the cartridge header
  // http://gbdev.gg8.se/wiki/articles/The_Cartridge_Header
  var cartridgeType = wasmByteMemory[MEMORY_ADDRESSES.CARTRIDGE_ROM + 0x0147];

  var ramSize = undefined;
  if (cartridgeType === 0x00) {
    // No memory for this rom type
    return false;
  } else if (cartridgeType >= 0x01 && cartridgeType <= 0x03) {
    // MBC1 32KB of Ram
    ramSize = 0x8000;
  } else if (cartridgeType >= 0x05 && cartridgeType <= 0x06) {
    // MBC2 512X4 Bytes, 2KB
    ramSize = 0x800;
  } else if (cartridgeType >= 0x0F && cartridgeType <= 0x13) {
    // MBC3 32KB of Ram
    ramSize = 0x8000;
  } else if (cartridgeType >= 0x19 && cartridgeType <= 0x1E) {
    // MBC5 128KB of Ram
    ramSize = 0x20000;
  }

  if (!ramSize) {
    return false;
  }

  // Finally fill our cartridgeRam from the ram in memory
  var cartridgeRam = new Uint8Array(ramSize);

  for (var i = 0; i < ramSize; i++) {
    cartridgeRam[i] = wasmByteMemory[MEMORY_ADDRESSES.CARTRIDGE_RAM + i];
  }

  return cartridgeRam;
};

// Function to return a save state of the current memory
var getSaveState = function getSaveState(wasmByteMemory) {
  // Simply read up to: 0x0083FF,
  // then append our catridge ram
  var cartridgeRam = getCartridgeRam(wasmByteMemory);

  var wasmBoyInternalState = new Uint8Array(MEMORY_ADDRESSES.WASMBOY_INTERNAL_STATE.SIZE);
  var gameBoyMemory = new Uint8Array(MEMORY_ADDRESSES.GAMEBOY_MEMORY.SIZE);

  for (var i = 0; i < MEMORY_ADDRESSES.WASMBOY_INTERNAL_STATE.SIZE; i++) {
    wasmBoyInternalState[i] = wasmByteMemory[i + MEMORY_ADDRESSES.WASMBOY_INTERNAL_STATE.LOCATION];
  }

  for (var _i = 0; _i < MEMORY_ADDRESSES.GAMEBOY_MEMORY.SIZE; _i++) {
    gameBoyMemory[_i] = wasmByteMemory[_i + MEMORY_ADDRESSES.GAMEBOY_MEMORY.LOCATION];
  }

  var saveState = Object.assign({}, WASMBOY_SAVE_STATE_SCHEMA);

  saveState.wasmBoyMemory.wasmBoyInternalState = wasmBoyInternalState;
  saveState.wasmBoyMemory.gameBoyMemory = gameBoyMemory;
  saveState.wasmBoyMemory.cartridgeRam = cartridgeRam;
  saveState.date = Date.now();

  return saveState;
};

var loadSaveState = function loadSaveState(wasmByteMemory, saveState) {

  for (var i = 0; i < MEMORY_ADDRESSES.WASMBOY_INTERNAL_STATE.SIZE; i++) {
    wasmByteMemory[i + MEMORY_ADDRESSES.WASMBOY_INTERNAL_STATE.LOCATION] = saveState.wasmBoyMemory.wasmBoyInternalState[i];
  }

  for (var _i2 = 0; _i2 < MEMORY_ADDRESSES.GAMEBOY_MEMORY.SIZE; _i2++) {
    wasmByteMemory[_i2 + MEMORY_ADDRESSES.GAMEBOY_MEMORY.LOCATION] = saveState.wasmBoyMemory.gameBoyMemory[_i2];
  }

  for (var _i3 = 0; _i3 < saveState.wasmBoyMemory.cartridgeRam.length; _i3++) {
    wasmByteMemory[_i3 + MEMORY_ADDRESSES.CARTRIDGE_RAM] = saveState.wasmBoyMemory.cartridgeRam[_i3];
  }

  return true;
};

var WasmBoyMemoryService = function () {
  function WasmBoyMemoryService() {
    classCallCheck(this, WasmBoyMemoryService);

    this.wasmInstance = undefined;
    this.wasmByteMemory = undefined;
  }

  createClass(WasmBoyMemoryService, [{
    key: 'initialize',
    value: function initialize(wasmInstance, wasmByteMemory, includeBootRom) {
      var _this = this;

      this.wasmInstance = wasmInstance;
      this.wasmByteMemory = wasmByteMemory;

      // Set listeners to ensure we save our cartridge ram before closing
      window.addEventListener("beforeunload", function () {
        // Need to add a retrun value, and force all code in the block to be sync
        // https://stackoverflow.com/questions/7255649/window-onbeforeunload-not-working
        // http://vaughnroyko.com/idbonbeforeunload/
        // https://bugzilla.mozilla.org/show_bug.cgi?id=870645

        // Solution:
        // ~~Try to force sync: https://www.npmjs.com/package/deasync~~ Didn't work, requires fs
        // Save to local storage, and pick it back up in init: https://bugs.chromium.org/p/chromium/issues/detail?id=144862

        // TODO: Ensure that reloading without loading the game rom, and not the game ram will overwrite our saved ram

        // Get our cartridge ram and header
        var header = getCartridgeHeader(_this.wasmByteMemory);
        var cartridgeRam = getCartridgeRam(_this.wasmByteMemory);

        // Get our save state, and un type our arrays
        var saveState = getSaveState(_this.wasmByteMemory);
        var saveStateMemoryKeys = Object.keys(saveState.wasmBoyMemory);
        for (var i = 0; i < saveStateMemoryKeys.length; i++) {
          saveState.wasmBoyMemory[saveStateMemoryKeys[i]] = Array.prototype.slice.call(saveState.wasmBoyMemory[saveStateMemoryKeys[i]]);
        }

        // Set isAuto
        saveState.isAuto = true;

        // Need to vonert types arrays, and back, or selse wll get indexed JSON
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays
        localStorage.setItem(WASMBOY_UNLOAD_STORAGE, JSON.stringify({
          header: Array.prototype.slice.call(header),
          cartridgeRam: Array.prototype.slice.call(cartridgeRam),
          saveState: saveState
        }));

        return null;
      }, false);

      // Load any unloaded storage in our localStorage
      var unloadStorage = localStorage.getItem(WASMBOY_UNLOAD_STORAGE);
      if (unloadStorage) {
        var unloadStorageObject = JSON.parse(unloadStorage);
        localStorage.removeItem(WASMBOY_UNLOAD_STORAGE);

        var header = new Uint8Array(unloadStorageObject.header);
        var cartridgeRam = new Uint8Array(unloadStorageObject.cartridgeRam);

        // Get our save state, and re-type our array
        var saveState = unloadStorageObject.saveState;
        if (saveState) {
          var saveStateMemoryKeys = Object.keys(saveState.wasmBoyMemory);
          for (var i = 0; i < saveStateMemoryKeys.length; i++) {
            saveState.wasmBoyMemory[saveStateMemoryKeys[i]] = new Uint8Array(saveState.wasmBoyMemory[saveStateMemoryKeys[i]]);
          }
        }

        this.saveCartridgeRam(header, cartridgeRam).then(function () {
          _this.saveState(header, saveState).then(function () {
            return Promise$1.resolve();
          }).catch(function (error) {
            return Promise$1.reject(error);
          });
        }).catch(function (error) {
          return Promise$1.reject(error);
        });
      } else {
        return Promise$1.resolve();
      }
    }
  }, {
    key: 'initializeHeadless',
    value: function initializeHeadless(wasmInstance, wasmByteMemory) {
      this.wasmInstance = wasmInstance;
      this.wasmByteMemory = wasmByteMemory;
    }
  }, {
    key: 'clearMemory',
    value: function clearMemory() {
      // Clear Wasm memory
      // https://docs.google.com/spreadsheets/d/17xrEzJk5-sCB9J2mMJcVnzhbE-XH_NvczVSQH9OHvRk/edit?usp=sharing
      for (var i = 0; i <= this.wasmByteMemory.length; i++) {
        this.wasmByteMemory[i] = 0;
      }
    }
  }, {
    key: 'loadCartridgeRom',
    value: function loadCartridgeRom(gameBytes, bootRom) {

      // Load the game data into actual memory
      for (var i = 0; i < gameBytes.length; i++) {
        if (gameBytes[i]) {
          this.wasmByteMemory[MEMORY_ADDRESSES.CARTRIDGE_ROM + i] = gameBytes[i];
        }
      }

      // TODO: Handle getting a boot rom
      this.wasmInstance.exports.initialize(0);
    }

    // Function to save the cartridge ram
    // This emulates the cartridge having a battery to
    // Keep things like Pokemon Save data in memory
    // Also allows passing in a a Uint8Array header and ram to be set manually

  }, {
    key: 'saveCartridgeRam',
    value: function saveCartridgeRam(passedHeader, passedCartridgeRam) {
      var _this2 = this;

      return new Promise$1(function (resolve, reject) {
        // Get the entire header in byte memory
        // Each version of a rom can have similar title and checksums
        // Therefore comparing all of it should help with this :)
        // https://drive.google.com/file/d/0B7y-o-Uytiv9OThXWXFCM1FPbGs/view
        var header = void 0;
        var cartridgeRam = void 0;
        if (passedHeader && passedCartridgeRam) {
          header = passedHeader;
          cartridgeRam = passedCartridgeRam;
        } else {
          header = getCartridgeHeader(_this2.wasmByteMemory);
          cartridgeRam = getCartridgeRam(_this2.wasmByteMemory);
        }

        if (!header || !cartridgeRam) {
          console.error('Error parsing the cartridgeRam or cartridge header', header, cartridgeRam);
          reject('Error parsing the cartridgeRam or cartridge header');
        }

        // Get our cartridge object
        idbKeyval.get(header).then(function (cartridgeObject) {

          if (!cartridgeObject) {
            cartridgeObject = {};
          }

          // Set the cartridgeRam to our cartridgeObject
          cartridgeObject.cartridgeRam = cartridgeRam;

          idbKeyval.set(header, cartridgeObject).then(function () {
            resolve();
          }).catch(function (error) {
            reject(error);
          });
        }).catch(function (error) {
          reject(error);
        });
      });
    }

    // function to load the cartridge ram
    // opposite of above

  }, {
    key: 'loadCartridgeRam',
    value: function loadCartridgeRam() {
      var _this3 = this;

      return new Promise$1(function (resolve, reject) {
        // Get the entire header in byte memory
        // Each version of a rom can have similar title and checksums
        // Therefore comparing all of it should help with this :)
        // https://drive.google.com/file/d/0B7y-o-Uytiv9OThXWXFCM1FPbGs/view
        var header = getCartridgeHeader(_this3.wasmByteMemory);

        if (!header) {
          reject('Error parsing the cartridge header');
        }

        idbKeyval.get(header).then(function (cartridgeObject) {

          if (!cartridgeObject || !cartridgeObject.cartridgeRam) {
            resolve();
            return;
          }

          // Set the cartridgeRam
          for (var i = 0; i < cartridgeObject.cartridgeRam.length; i++) {
            _this3.wasmByteMemory[MEMORY_ADDRESSES.CARTRIDGE_RAM + i] = cartridgeObject.cartridgeRam[i];
          }
          resolve();
        }).catch(function (error) {
          reject(error);
        });
      });
    }

    // Function to save the state to the indexeddb

  }, {
    key: 'saveState',
    value: function saveState(passedHeader, passedSaveState) {
      var _this4 = this;

      return new Promise$1(function (resolve, reject) {

        // Save our internal wasmboy state to memory
        _this4.wasmInstance.exports.saveState();

        // Get our save state
        var saveState = void 0;
        var header = void 0;
        if (passedHeader && passedSaveState) {
          saveState = passedSaveState;
          header = passedHeader;
        } else {
          saveState = getSaveState(_this4.wasmByteMemory);
          header = getCartridgeHeader(_this4.wasmByteMemory);
        }

        if (!header) {
          reject('Error parsing the cartridge header');
        }

        idbKeyval.get(header).then(function (cartridgeObject) {

          if (!cartridgeObject) {
            cartridgeObject = {};
          }

          if (!cartridgeObject.saveStates) {
            cartridgeObject.saveStates = [];
          }

          cartridgeObject.saveStates.push(saveState);

          idbKeyval.set(header, cartridgeObject).then(function () {
            resolve();
          }).catch(function (error) {
            reject(error);
          });
        }).catch(function (error) {
          reject(error);
        });
      });
    }
  }, {
    key: 'loadState',
    value: function loadState(saveStateIndex) {
      var _this5 = this;

      return new Promise$1(function (resolve, reject) {

        var header = getCartridgeHeader(_this5.wasmByteMemory);

        if (!header) {
          reject('Error parsing the cartridge header');
        }

        idbKeyval.get(header).then(function (cartridgeObject) {

          if (!cartridgeObject || !cartridgeObject.saveStates) {
            reject('No Cartridge Object or saveStates array found');
            return;
          }

          // Get a default saveStateIndex
          if (!saveStateIndex) {
            // Default to the latest save state, or but attempt to default to the first non-auto save state
            saveStateIndex = cartridgeObject.saveStates.length - 1;
            for (var i = cartridgeObject.saveStates.length - 1; i >= 0; i--) {
              if (!cartridgeObject.saveStates[i].isAuto) {
                saveStateIndex = i;
                i = -1;
              }
            }
          }
          loadSaveState(_this5.wasmByteMemory, cartridgeObject.saveStates[saveStateIndex]);

          // Load back out internal wasmboy state from memory
          _this5.wasmInstance.exports.loadState();

          resolve();
        }).catch(function (error) {
          reject(error);
        });
      });
    }

    // Function to return the current cartridge object

  }, {
    key: 'getCartridgeObject',
    value: function getCartridgeObject() {
      var header = getCartridgeHeader(this.wasmByteMemory);
      return idbKeyval.get(header);
    }
  }]);
  return WasmBoyMemoryService;
}();

// Create a singleton to export


var WasmBoyMemory = new WasmBoyMemoryService();

// Polyfill for raf for testing in node, defaults to builtin window.requestAnimationFrame
var raf = require('raf');

// Constant to define wasm memory size on instantiation
var WASMBOY_MEMORY_SIZE = 0x87FFFF;

var WasmBoyLib = function () {

  // Start the request to our wasm module
  function WasmBoyLib() {
    classCallCheck(this, WasmBoyLib);

    this.wasmInstance = undefined;
    this.wasmByteMemory = undefined;
    this.headless = false;
    this.canvasElement = undefined;
    this.paused = false;
    this.ready = false;

    // Test properties
    this.frameSkip = 0;

    // TODO: Remove this debug code
    this.logRequest = false;
  }

  // Function to initialize our Wasmboy


  createClass(WasmBoyLib, [{
    key: 'initialize',
    value: function initialize(canvasElement) {
      this.headless = false;
      this.canvasElement = canvasElement;
      this.frameSkip = 0;
    }

    // Function to intialize WasmBoy For Headless
    // TODO: Allow passing a speed for how many frames to render per second
    // Will hopefully speed up testing

  }, {
    key: 'initializeHeadless',
    value: function initializeHeadless(frameSkip) {
      this.headless = true;
      if (frameSkip) {
        this.frameSkip = frameSkip;
      }
    }

    // Finish request for wasm module, and fetch game

  }, {
    key: 'loadGame',
    value: function loadGame(game) {
      var _this = this;

      // Getting started with wasm
      // http://webassembly.org/getting-started/js-api/
      this.ready = false;
      return new Promise$1(function (resolve, reject) {

        // Get our promises
        var initPromises = [_this._fetchGameAsByteArray(game)];
        if (!_this.wasmInstance) {
          initPromises.push(_this._getWasmInstance());
        } else if (!_this.headless) {
          initPromises.push(WasmBoyMemory.saveCartridgeRam());
        }

        Promise$1.all(initPromises).then(function (responses) {

          // Pause the game in case it was running, and set to not ready
          _this.pauseGame();
          _this.ready = false;

          // raf to ensure the game is not running while we paused
          raf(function () {

            // Check if we are running headless
            if (_this.headless) {
              WasmBoyMemory.initializeHeadless(_this.wasmInstance, _this.wasmByteMemory);
              // Clear what is currently in memory, then load the cartridge memory
              WasmBoyMemory.clearMemory();
              // TODO: Handle passing a boot rom
              WasmBoyMemory.loadCartridgeRom(responses[0], false);
              _this.ready = true;
              resolve();
            } else {
              // Finally intialize all of our services
              // Initialize our services
              Promise$1.all([WasmBoyGraphics.initialize(_this.canvasElement, _this.wasmInstance, _this.wasmByteMemory), WasmBoyAudio.initialize(_this.wasmInstance, _this.wasmByteMemory), WasmBoyController.initialize(_this.wasmInstance), WasmBoyMemory.initialize(_this.wasmInstance, _this.wasmByteMemory)]).then(function () {

                // Clear what is currently in memory, then load the carttridge memory
                WasmBoyMemory.clearMemory();
                // TODO: Handle passing a boot rom
                WasmBoyMemory.loadCartridgeRom(responses[0], false);

                // Load the game's cartridge ram
                WasmBoyMemory.loadCartridgeRam().then(function () {
                  _this.ready = true;
                  resolve();
                }).catch(function (error) {
                  reject(error);
                });
              }).catch(function (error) {
                reject(error);
              });
            }
          });
        }).catch(function (error) {
          reject(error);
        });
      });
    }

    // Function to start the game

  }, {
    key: 'startGame',
    value: function startGame() {
      return this.resumeGame();
    }
  }, {
    key: 'resumeGame',
    value: function resumeGame() {
      var _this2 = this;

      if (!this.ready) {
        return false;
      }

      // Un-pause the game
      this.paused = false;

      raf(function () {
        _this2._emulationLoop();
      });
    }
  }, {
    key: 'pauseGame',
    value: function pauseGame() {
      this.paused = true;
    }

    // Function to return the current game object in memory

  }, {
    key: 'getWasmBoyMemoryForLoadedGame',
    value: function getWasmBoyMemoryForLoadedGame() {
      return WasmBoyMemory.getCartridgeObject();
    }
  }, {
    key: 'saveState',
    value: function saveState() {
      var _this3 = this;

      // Pause the game in case it was running, and set to not ready
      this.pauseGame();

      // raf to ensure the game is not running while we paused
      raf(function () {
        // Save our state to wasmMemory
        WasmBoyMemory.saveState().then(function () {
          _this3.resumeGame();
        });
      });
    }
  }, {
    key: 'loadState',
    value: function loadState() {
      var _this4 = this;

      // Pause the game in case it was running, and set to not ready
      this.pauseGame();

      // raf to ensure the game is not running while we paused
      raf(function () {

        WasmBoyMemory.loadState().then(function () {
          _this4.resumeGame();
        });
      });
    }

    // Loop performed to keep the emulator continuosly running

  }, {
    key: '_emulationLoop',
    value: function _emulationLoop() {
      var _this5 = this;

      // Offload as much of this as possible to WASM
      // Feeding wasm bytes is probably going to slow things down, would be nice to just place the game in wasm memory
      // And read from there

      // Update (Execute a frame)
      var response = this.wasmInstance.exports.update();
      // Allow skipping render and animation frame steps to skip frames.
      // Useful for speeding up tests
      if (this.frameSkip) {
        for (var i = 0; i < this.frameSkip; i++) {
          response = this.wasmInstance.exports.update();
        }
      }

      if (response > 0) {

        if (!this.headless) {
          // Play the audio
          WasmBoyAudio.playAudio();

          // Render the display
          WasmBoyGraphics.renderFrame();

          // Get the controller state, and pass to wasm
          // NOTE: Sets the joypad state on the wasm instance for us
          WasmBoyController.updateController();
        }

        // Run another frame
        if (!this.paused) {

          raf(function () {
            _this5._emulationLoop();
          });
        }
        return true;
      } else {
        console.log('Wasmboy Crashed!');
        console.log('Program Counter: 0x' + this.wasmInstance.exports.getProgramCounter().toString(16));
        console.log('Opcode: 0x' + this.wasmByteMemory[this.wasmInstance.exports.getProgramCounter()].toString(16));
      }
    }

    // Private funciton to returna promise to our wasmModule

  }, {
    key: '_getWasmInstance',
    value: function _getWasmInstance() {
      var _this6 = this;

      return new Promise$1(function (resolve, reject) {

        if (_this6.wasmInstance) {
          resolve(_this6.wasmInstance);
        }

        // Get our wasm instance from our wasmModule
        wasmModule({
          env: {
            log: function log(message, numArgs, arg0, arg1, arg2, arg3, arg4, arg5) {
              // Grab our string
              var len = new Uint32Array(_this6.wasmInstance.exports.memory.buffer, message, 1)[0];
              var str = String.fromCharCode.apply(null, new Uint16Array(_this6.wasmInstance.exports.memory.buffer, message + 4, len));
              if (numArgs > 0) str = str.replace("$0", arg0);
              if (numArgs > 1) str = str.replace("$1", arg1);
              if (numArgs > 2) str = str.replace("$2", arg2);
              if (numArgs > 3) str = str.replace("$3", arg3);
              if (numArgs > 4) str = str.replace("$4", arg4);
              if (numArgs > 5) str = str.replace("$5", arg5);

              // Log the string if no throttle
              console.log("[WasmBoy] " + str);
            },
            hexLog: function hexLog(numArgs, arg0, arg1, arg2, arg3, arg4, arg5) {

              if (!_this6.logRequest) {

                // Comment this line to disable throttle
                _this6.logRequest = true;

                // Grab our arguments, and log as hex
                var logString = '[WasmBoy]';
                if (numArgs > 0) logString += ' 0x' + arg0.toString(16) + ' ';
                if (numArgs > 1) logString += ' 0x' + arg1.toString(16) + ' ';
                if (numArgs > 2) logString += ' 0x' + arg2.toString(16) + ' ';
                if (numArgs > 3) logString += ' 0x' + arg3.toString(16) + ' ';
                if (numArgs > 4) logString += ' 0x' + arg4.toString(16) + ' ';
                if (numArgs > 5) logString += ' 0x' + arg5.toString(16) + ' ';

                setTimeout(function () {
                  console.log(logString);
                  _this6.logRequest = false;
                }, 250);
              }
            }
          }
        }).then(function (instantiatedWasm) {
          // Using || since rollup and webpack wasm loaders will return differently
          var instance = _this6.wasmInstance = instantiatedWasm.instance || instantiatedWasm;
          var module = instantiatedWasm.module;

          // Get our memory from our wasm instance
          var memory = instance.exports.memory;

          // Grow memory to wasmboy memory map
          // https://docs.google.com/spreadsheets/d/17xrEzJk5-sCB9J2mMJcVnzhbE-XH_NvczVSQH9OHvRk/edit?usp=sharing
          // TODO: Scale Memory as needed with Cartridge size
          if (memory.buffer.byteLength < WASMBOY_MEMORY_SIZE) {
            memory.grow(136);
          }

          // Will stay in sync
          _this6.wasmByteMemory = new Uint8Array(_this6.wasmInstance.exports.memory.buffer);

          resolve(_this6.wasmInstance);
        });
      });
    }

    // Private function to fetch a game

  }, {
    key: '_fetchGameAsByteArray',
    value: function _fetchGameAsByteArray(game) {
      return new Promise$1(function (resolve, reject) {
        if (ArrayBuffer.isView(game) && game.constructor === Uint8Array) {
          // Simply resolve with the input
          resolve(game);
          return;
        } else if ((typeof game === 'undefined' ? 'undefined' : _typeof(game)) === 'object' && game.size) {
          // Read the file object
          // https://www.javascripture.com/FileReader#readAsArrayBuffer_Blob
          var fileReader = new FileReader();
          fileReader.onload = function () {
            var byteArray = new Uint8Array(fileReader.result);
            resolve(byteArray);
          };
          fileReader.readAsArrayBuffer(game);
        } else {
          // Fetch the file
          index(game).then(function (blob) {
            return blob.arrayBuffer();
          }).then(function (bytes) {
            var byteArray = new Uint8Array(bytes);
            resolve(byteArray);
          });
        }
      });
    }
  }]);
  return WasmBoyLib;
}();

var WasmBoy = new WasmBoyLib();

exports.WasmBoy = WasmBoy;
exports.WasmBoyAudio = WasmBoyAudio;
exports.WasmBoyGraphics = WasmBoyGraphics;
exports.WasmBoyController = WasmBoyController;
exports.WasmBoyMemory = WasmBoyMemory;

Object.defineProperty(exports, '__esModule', { value: true });

})));
