{"version":3,"sources":["wasm/cpu/index.ts","wasm/helpers/index.ts","wasm/memory/store.ts","wasm/memory/writeTraps.ts","wasm/memory/memory.ts","wasm/memory/banking.ts","wasm/graphics/graphics.ts","wasm/memory/memoryMap.ts","wasm/sound/sound.ts","wasm/sound/registers.ts","wasm/memory/load.ts","wasm/memory/readTraps.ts","wasm/joypad/index.ts","wasm/sound/channel1.ts","wasm/sound/length.ts","wasm/sound/channel2.ts","wasm/sound/channel3.ts","wasm/sound/channel4.ts","wasm/sound/frequency.ts","wasm/sound/envelope.ts","wasm/cpu/opcodes.ts","wasm/cpu/flags.ts","wasm/cpu/instructions.ts","wasm/cpu/cbOpcodes.ts","wasm/interrupts/index.ts","wasm/timers/index.ts","wasm/graphics/lcd.ts","wasm/graphics/background.ts","wasm/graphics/renderUtils.ts","wasm/graphics/window.ts","wasm/graphics/sprites.ts","wasm/sound/duty.ts","wasm/index.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["// NOTE: Code is very verbose, and will have some copy pasta'd lines.\n// Reason being, I want the code to be very accessible for errors later on.\n// Also, the benefit on splitting into functions is organizarion, and keeping things DRY.\n// But since I highly doubt the GB CPU will be changing, DRY is no longer an issue\n// And the verbosity / ease of use is more important, imo.\n\n// NOTE: Commands like SUB B, or AND C, without a second parameter, actually refer SUB A, B or AND A, C\n\n// Resources:\n// https://github.com/AssemblyScript/assemblyscript/wiki/Built-in-functions\n// https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n\n\nexport {\n  setZeroFlag,\n  getZeroFlag\n} from './flags';\n\nimport {\n  eightBitStoreIntoGBMemory,\n  eightBitLoadFromGBMemory,\n  initializeCartridge,\n  getSaveStateMemoryOffset,\n  loadBooleanDirectlyFromWasmMemory,\n  storeBooleanDirectlyToWasmMemory\n} from '../memory/index';\n\nimport {\n  initializeSound\n} from '../sound/index'\n\nimport {\n  log\n} from '../helpers/index';\n\n// Everything Static as class instances just aren't quite there yet\n// https://github.com/AssemblyScript/assemblyscript/blob/master/tests/compiler/showcase.ts\nexport class Cpu {\n\n  // Clock Speed to determine all kinds of other values\n  static clockSpeed: i32 = 4194304;\n\n  // 8-bit Cpu.registers\n  static registerA: u8 = 0;\n  static registerB: u8 = 0;\n  static registerC: u8 = 0;\n  static registerD: u8 = 0;\n  static registerE: u8 = 0;\n  static registerH: u8 = 0;\n  static registerL: u8 = 0;\n  static registerF: u8 = 0;\n\n  // 16-bit Cpu.registers\n  static stackPointer: u16 = 0;\n  // Boot rom from 0x00 to 0x99, all games start at 0x100\n  static programCounter: u16 = 0x00;\n\n  // Current number of cycles, shouldn't execeed max number of cycles\n  static currentCycles: i32 = 0;\n  static CLOCK_SPEED: i32 = 4194304;\n  static MAX_CYCLES_PER_FRAME : i32 = 69905;\n\n  // HALT and STOP instructions need to stop running opcodes, but simply check timers\n  // https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n  // Matt said is should work to, so it must work!\n  static isHalted: boolean = false;\n  static isStopped: boolean = false;\n\n  // Debugging properties\n  static previousOpcode: u8 = 0x00;\n\n  // Save States\n\n  static saveStateSlot: u16 = 0;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    // Registers\n    store<u8>(getSaveStateMemoryOffset(0x00, Cpu.saveStateSlot), Cpu.registerA);\n    store<u8>(getSaveStateMemoryOffset(0x01, Cpu.saveStateSlot), Cpu.registerB);\n    store<u8>(getSaveStateMemoryOffset(0x02, Cpu.saveStateSlot), Cpu.registerC);\n    store<u8>(getSaveStateMemoryOffset(0x03, Cpu.saveStateSlot), Cpu.registerD);\n    store<u8>(getSaveStateMemoryOffset(0x04, Cpu.saveStateSlot), Cpu.registerE);\n    store<u8>(getSaveStateMemoryOffset(0x05, Cpu.saveStateSlot), Cpu.registerH);\n    store<u8>(getSaveStateMemoryOffset(0x06, Cpu.saveStateSlot), Cpu.registerL);\n    store<u8>(getSaveStateMemoryOffset(0x07, Cpu.saveStateSlot), Cpu.registerF);\n\n    store<u16>(getSaveStateMemoryOffset(0x08, Cpu.saveStateSlot), Cpu.stackPointer);\n    store<u16>(getSaveStateMemoryOffset(0x0A, Cpu.saveStateSlot), Cpu.programCounter);\n\n    store<i32>(getSaveStateMemoryOffset(0x0C, Cpu.saveStateSlot), Cpu.currentCycles);\n\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x11, Cpu.saveStateSlot), Cpu.isHalted);\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x12, Cpu.saveStateSlot), Cpu.isStopped);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    // Registers\n    Cpu.registerA = load<u8>(getSaveStateMemoryOffset(0x00, Cpu.saveStateSlot));\n    Cpu.registerB = load<u8>(getSaveStateMemoryOffset(0x01, Cpu.saveStateSlot));\n    Cpu.registerC = load<u8>(getSaveStateMemoryOffset(0x02, Cpu.saveStateSlot));\n    Cpu.registerD = load<u8>(getSaveStateMemoryOffset(0x03, Cpu.saveStateSlot));\n    Cpu.registerE = load<u8>(getSaveStateMemoryOffset(0x04, Cpu.saveStateSlot));\n    Cpu.registerH = load<u8>(getSaveStateMemoryOffset(0x05, Cpu.saveStateSlot));\n    Cpu.registerL = load<u8>(getSaveStateMemoryOffset(0x06, Cpu.saveStateSlot));\n    Cpu.registerF = load<u8>(getSaveStateMemoryOffset(0x07, Cpu.saveStateSlot));\n\n    Cpu.stackPointer = load<u16>(getSaveStateMemoryOffset(0x08, Cpu.saveStateSlot));\n    Cpu.programCounter = load<u16>(getSaveStateMemoryOffset(0x0A, Cpu.saveStateSlot));\n\n    Cpu.currentCycles = load<i32>(getSaveStateMemoryOffset(0x0C, Cpu.saveStateSlot));\n\n    Cpu.isHalted = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x11, Cpu.saveStateSlot));\n    Cpu.isStopped = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x12, Cpu.saveStateSlot));\n  }\n}\n\nexport function initialize(includeBootRom: u8): void {\n  log(\"initializing (includeBootRom=$0)\", 1, includeBootRom);\n  // TODO: depending on the boot rom, initialization may be different\n  // From: http://www.codeslinger.co.uk/pages/projects/gameboy/hardware.html\n  // All values default to zero in memory, so not setting them yet\n  if(includeBootRom <= 0) {\n    Cpu.programCounter = 0x100;\n    Cpu.registerA = 0x01;\n    Cpu.registerF = 0xB0;\n    Cpu.registerB = 0x00;\n    Cpu.registerC = 0x13;\n    Cpu.registerD = 0x00;\n    Cpu.registerE = 0xD8;\n    Cpu.registerH = 0x01;\n    Cpu.registerL = 0x4D;\n    Cpu.stackPointer = 0xFFFE;\n    eightBitStoreIntoGBMemory(0xFF10, 0x80);\n    eightBitStoreIntoGBMemory(0xFF11, 0xBF);\n    eightBitStoreIntoGBMemory(0xFF12, 0xF3);\n    eightBitStoreIntoGBMemory(0xFF14, 0xBF);\n    eightBitStoreIntoGBMemory(0xFF16, 0x3F);\n    eightBitStoreIntoGBMemory(0xFF17, 0x00);\n    eightBitStoreIntoGBMemory(0xFF19, 0xBF);\n    eightBitStoreIntoGBMemory(0xFF1A, 0x7F);\n    eightBitStoreIntoGBMemory(0xFF1B, 0xFF);\n    eightBitStoreIntoGBMemory(0xFF1C, 0x9F);\n    eightBitStoreIntoGBMemory(0xFF1E, 0xBF);\n    eightBitStoreIntoGBMemory(0xFF20, 0xFF);\n    eightBitStoreIntoGBMemory(0xFF23, 0xBF);\n    eightBitStoreIntoGBMemory(0xFF24, 0x77);\n    eightBitStoreIntoGBMemory(0xFF25, 0xF3);\n    eightBitStoreIntoGBMemory(0xFF26, 0xF1);\n    eightBitStoreIntoGBMemory(0xFF40, 0x91);\n    eightBitStoreIntoGBMemory(0xFF47, 0xFC);\n    eightBitStoreIntoGBMemory(0xFF48, 0xFF);\n    eightBitStoreIntoGBMemory(0xFF49, 0xFF);\n  }\n\n  // Call our memory to initialize our cartridge type\n  initializeCartridge();\n\n  // Initialize our sound registers\n  initializeSound();\n}\n\n// Private function for our relative jumps\nexport function relativeJump(value: u8): void {\n  // Need to convert the value to i8, since in this case, u8 can be negative\n  let relativeJumpOffset: i8 = <i8> value;\n\n  Cpu.programCounter += relativeJumpOffset;\n  // Realtive jump, using bgb debugger\n  // and my debugger shows,\n  // on JR you need to jump to the relative jump offset,\n  // However, if the jump fails (such as conditional), only jump +2 in total\n\n  Cpu.programCounter += 1;\n}\n","import {\n  getCarryFlag\n} from '../cpu/flags';\n\n// Grouped registers\n// possible overload these later to performace actions\n// AF, BC, DE, HL\nexport function concatenateBytes(highByte: u8, lowByte: u8): u16 {\n  //https://stackoverflow.com/questions/38298412/convert-two-bytes-into-signed-16-bit-integer-in-javascript\n  let highByteExpanded: u16 = <u16>highByte;\n  return (((highByteExpanded & 0xFF) << 8) | (lowByte & 0xFF))\n}\n\nexport function splitHighByte(groupedByte: u16): u8 {\n  return <u8>((groupedByte & 0xFF00) >> 8);\n}\n\nexport function splitLowByte(groupedByte: u16): u8 {\n  return <u8>groupedByte & 0x00FF;\n}\n\nexport function rotateByteLeft(value: u8): u8 {\n  // Rotate left\n  // https://stackoverflow.com/questions/19204750/how-do-i-perform-a-circular-rotation-of-a-byte\n  // 4-bit example:\n  // 1010 -> 0100 | 0001\n  return (value << 1) | (value >> 7);\n}\n\nexport function rotateByteLeftThroughCarry(value: u8): u8 {\n  // Example: https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n  // Through carry meaning, instead of raotating the bit that gets dropped off, but the carry there instead\n  value = (value << 1) | getCarryFlag();\n  return value;\n}\n\nexport function rotateByteRight(value: u8): u8 {\n  // Rotate right\n  // 4-bit example:\n  // 1010 -> 0101 | 0000\n  return (value >> 1) | (value << 7);\n}\n\nexport function rotateByteRightThroughCarry(value: u8): u8 {\n  // Example: https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n  // Through carry meaning, instead of raotating the bit that gets dropped off, put the carry there instead\n  value = (value >> 1) | (getCarryFlag() << 7);\n  return value;\n}\n\nexport function setBitOnByte(bitPosition: u8, byte: u8): u8 {\n  let byteOfBitToSet: u8 = (0x01 << bitPosition);\n  byte = byte | byteOfBitToSet;\n  return byte;\n}\n\nexport function resetBitOnByte(bitPosition: u8, byte: u8): u8 {\n  let byteOfBitToSet: u8 = (0x01 << bitPosition);\n  byte = byte & ~(byteOfBitToSet);\n  return byte;\n}\n\nexport function checkBitOnByte(bitPosition: u8, byte: u8): boolean {\n  let byteOfBitToCheck: u8 = (0x01 << bitPosition);\n  byte = byte & byteOfBitToCheck;\n  if(byte > 0) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nnamespace env {\n  export declare function log(message: string, numArgs: i32, arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: i32, arg5: i32): void;\n  export declare function hexLog(numArgs: i32, arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: i32, arg5: i32): void;\n}\n\nexport function log(message: string, numArgs: i32 = 0, arg0: i32 = 0, arg1: i32 = 0, arg2: i32 = 0, arg3: i32 = 0, arg4: i32 = 0, arg5: i32 = 0): void {\n  env.log(message, numArgs, arg0, arg1, arg2, arg3, arg4, arg5);\n}\n\nexport function hexLog(numArgs: i32 = 0, arg0: i32 = 0, arg1: i32 = 0, arg2: i32 = 0, arg3: i32 = 0, arg4: i32 = 0, arg5: i32 = 0): void {\n  env.hexLog(numArgs, arg0, arg1, arg2, arg3, arg4, arg5);\n}\n","// Store / Write memory access\nimport {\n  checkWriteTraps\n} from './writeTraps';\nimport {\n  getWasmBoyOffsetFromGameBoyOffset\n} from './memoryMap';\nimport {\n  splitHighByte,\n  splitLowByte\n} from '../helpers/index';\n\nexport function eightBitStoreIntoGBMemory(offset: u16, value: u8): void {\n  if(checkWriteTraps(offset, <u16>value, true)) {\n    _eightBitStoreIntoWasmBoyMemory(offset, value);\n  }\n}\n\nexport function sixteenBitStoreIntoGBMemory(offset: u16, value: u16): void {\n\n  // Dividing into two seperate eight bit calls to help with debugging tilemap overwrites\n  // Split the value into two seperate bytes\n  let highByte: u8 = splitHighByte(value);\n  let lowByte: u8 = splitLowByte(value);\n  let nextOffset: u16 = offset + 1;\n\n  if(checkWriteTraps(offset, lowByte, false)) {\n    _eightBitStoreIntoWasmBoyMemory(offset, lowByte);\n  }\n\n  if(checkWriteTraps(nextOffset, highByte, false)) {\n    _eightBitStoreIntoWasmBoyMemory(nextOffset, highByte);\n  }\n}\n\nexport function eightBitStoreIntoGBMemorySkipTraps(offset: u16, value: u8): void {\n  _eightBitStoreIntoWasmBoyMemory(offset, value);\n}\n\nexport function sixteenBitStoreIntoGBMemorySkipTraps(offset: u16, value: u16): void {\n\n  // Dividing into two seperate eight bit calls to help with debugging tilemap overwrites\n  // Split the value into two seperate bytes\n  let highByte: u8 = splitHighByte(value);\n  let lowByte: u8 = splitLowByte(value);\n  let nextOffset: u16 = offset + 1;\n\n  _eightBitStoreIntoWasmBoyMemory(offset, lowByte);\n  _eightBitStoreIntoWasmBoyMemory(nextOffset, highByte);\n}\n\nfunction _eightBitStoreIntoWasmBoyMemory(gameboyOffset: u16, value: u8): void {\n  let wasmboyOffset: u32 = getWasmBoyOffsetFromGameBoyOffset(gameboyOffset);\n\n  store<u8>(wasmboyOffset, value);\n}\n\nexport function storeBooleanDirectlyToWasmMemory(offset: u32, value: boolean): void {\n  if (value) {\n    store<u8>(offset, 0x01);\n  } else {\n    store<u8>(offset, 0x00);\n  }\n}\n","import {\n  Memory\n} from './memory';\nimport {\n  Graphics\n} from '../graphics/graphics';\nimport {\n  handledWriteToSoundRegister\n} from '../sound/registers';\nimport {\n  handleBanking\n} from './banking';\nimport {\n  eightBitStoreIntoGBMemorySkipTraps,\n  sixteenBitStoreIntoGBMemorySkipTraps\n} from './store';\nimport {\n  eightBitLoadFromGBMemory,\n  eightBitLoadFromGBMemorySkipTraps,\n  sixteenBitLoadFromGBMemory\n} from './load';\nimport {\n  checkBitOnByte\n} from '../helpers/index';\n\n// Internal function to trap any modify data trying to be written to Gameboy memory\n// Follows the Gameboy memory map\nexport function checkWriteTraps(offset: u16, value: u16, isEightBitStore: boolean): boolean {\n\n  // Handle banking\n  if(offset < Memory.videoRamLocation) {\n    handleBanking(offset, value);\n    return false;\n  }\n\n  // Check the graphics mode to see if we can write to VRAM\n  // http://gbdev.gg8.se/wiki/articles/Video_Display#Accessing_VRAM_and_OAM\n  if(offset >= Memory.videoRamLocation && offset < Memory.cartridgeRamLocation) {\n    // Can only read/write from VRAM During Modes 0 - 2\n    // See graphics/lcd.ts\n    if (Graphics.currentLcdMode > 2) {\n      return false;\n    }\n  }\n\n  // Be sure to copy everything in EchoRam to Work Ram\n  if(offset >= Memory.echoRamLocation && offset < Memory.spriteInformationTableLocation) {\n    // TODO: Also write to Work Ram\n    if(isEightBitStore) {\n      eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n    } else {\n      sixteenBitStoreIntoGBMemorySkipTraps(offset, value);\n    }\n  }\n\n  // Also check for individal writes\n  // Can only read/write from OAM During Modes 0 - 1\n  // See graphics/lcd.ts\n  if(offset >= Memory.spriteInformationTableLocation && offset <= Memory.spriteInformationTableLocationEnd) {\n    // Can only read/write from OAM During Mode 2\n    // See graphics/lcd.ts\n    if (Graphics.currentLcdMode !== 2) {\n      return false;\n    }\n  }\n\n  if(offset >= Memory.unusableMemoryLocation && offset <= Memory.unusableMemoryEndLocation) {\n    return false;\n  }\n\n  // Trap our divider register from our timers\n  if(offset === 0xFF04) {\n    eightBitStoreIntoGBMemorySkipTraps(offset, 0);\n    return false;\n  }\n\n  // Sound\n  if(offset >= 0xFF10 && offset <= 0xFF26) {\n    if(handledWriteToSoundRegister(offset, value)) {\n      return false;\n    }\n  }\n\n  // reset the current scanline if the game tries to write to it\n  if (offset === 0xFF44) {\n    eightBitStoreIntoGBMemorySkipTraps(offset, 0);\n    return false;\n  }\n\n  // Do the direct memory access transfer for spriteInformationTable\n  // Check the graphics mode to see if we can write to VRAM\n  // http://gbdev.gg8.se/wiki/articles/Video_Display#Accessing_VRAM_and_OAM\n  if (offset === 0xFF46) {\n    // otherwise, performa the DMA transfer\n    _dmaTransfer(<u8>value) ;\n  }\n\n  return true;\n}\n\nfunction _dmaTransfer(sourceAddressOffset: u8): void {\n\n  let sourceAddress: u16 = <u16>sourceAddressOffset;\n  sourceAddress = (sourceAddress << 8);\n\n  for(let i: u16 = 0; i < 0xA0; i++) {\n    let spriteInformationByte: u8 = eightBitLoadFromGBMemorySkipTraps(sourceAddress + i);\n    let spriteInformationAddress: u16 = Memory.spriteInformationTableLocation + i;\n    eightBitStoreIntoGBMemorySkipTraps(spriteInformationAddress, spriteInformationByte);\n  }\n}\n","// WasmBoy memory map:\n// https://docs.google.com/spreadsheets/d/17xrEzJk5-sCB9J2mMJcVnzhbE-XH_NvczVSQH9OHvRk/edit?usp=sharing\n\nimport {\n  checkBitOnByte,\n  hexLog\n} from '../helpers/index';\nimport {\n  eightBitLoadFromGBMemory,\n  loadBooleanDirectlyFromWasmMemory\n} from './load';\nimport {\n  storeBooleanDirectlyToWasmMemory\n} from './store';\nimport {\n  handleBanking\n} from './banking';\n\nexport class Memory {\n\n  // ----------------------------------\n  // Gameboy Memory Map\n  // ----------------------------------\n  // https://github.com/AntonioND/giibiiadvance/blob/master/docs/TCAGBD.pdf\n  // http://gameboy.mongenel.com/dmg/asmmemmap.html\n  // using Arrays, first index is start, second is end\n  static cartridgeRomLocation: u16 = 0x0000;\n\n  static switchableCartridgeRomLocation: u16 = 0x4000;\n\n  static videoRamLocation: u16 = 0x8000;\n\n  static cartridgeRamLocation: u16 = 0xA000;\n\n  static internalRamBankZeroLocation: u16 = 0xC000;\n\n  // This ram bank is switchable\n  static internalRamBankOneLocation: u16 = 0xD000;\n\n  static echoRamLocation: u16 = 0xE000;\n\n  static spriteInformationTableLocation: u16 = 0xFE00;\n\n  static spriteInformationTableLocationEnd: u16 = 0xFE9F;\n\n  static unusableMemoryLocation: u16 = 0xFEA0;\n  static unusableMemoryEndLocation: u16 = 0xFEFF;\n\n  // Hardware I/O, 0xFF00 -> 0xFF7F\n  // Zero Page, 0xFF80 -> 0xFFFE\n  // Intterupt Enable Flag, 0xFFFF\n\n  // ----------------------------------\n  // Wasmboy Memory Map\n  // ----------------------------------\n  static gameBoyInternalMemoryLocation: u32 = 0x000400;\n  static videoOutputLocation: u32 = 0x028400;\n  static currentFrameVideoOutputLocation: u32 = Memory.videoOutputLocation;\n  static frameInProgressVideoOutputLocation: u32 = Memory.currentFrameVideoOutputLocation + (160 * 144);\n  static soundOutputLocation: u32 = 0x053800;\n\n  // Passed in Game backup or ROM from the user\n  static gameBytesLocation: u32 = 0x073800;\n  static gameRamBanksLocation: u32 = 0x008400;\n\n  // ----------------------------------\n  // Rom/Ram Banking\n  // ----------------------------------\n  // http://gbdev.gg8.se/wiki/articles/Memory_Bank_Controllers#MBC3_.28max_2MByte_ROM_and.2For_32KByte_RAM_and_Timer.29\n  // http://www.codeslinger.co.uk/pages/projects/gameboy/banking.html\n  static currentRomBank: u16 = 0x00;\n  static currentRamBank: u16 = 0x00;\n  static isRamBankingEnabled: boolean = false;\n  static isMBC1RomModeEnabled: boolean = true;\n\n  // Cartridge Types\n  // http://gbdev.gg8.se/wiki/articles/The_Cartridge_Header\n  static isRomOnly: boolean = true;\n  static isMBC1: boolean = false;\n  static isMBC2: boolean = false;\n  static isMBC3: boolean = false;\n  static isMBC5: boolean = false;\n\n  // Save States\n\n  static saveStateSlot: u16 = 4;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    store<u16>(getSaveStateMemoryOffset(0x00, Memory.saveStateSlot), Memory.currentRomBank);\n    store<u16>(getSaveStateMemoryOffset(0x02, Memory.saveStateSlot), Memory.currentRamBank);\n\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x04, Memory.saveStateSlot), Memory.isRamBankingEnabled);\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x05, Memory.saveStateSlot), Memory.isMBC1RomModeEnabled);\n\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x06, Memory.saveStateSlot), Memory.isRomOnly);\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x07, Memory.saveStateSlot), Memory.isMBC1);\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x08, Memory.saveStateSlot), Memory.isMBC2);\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x09, Memory.saveStateSlot), Memory.isMBC3);\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0A, Memory.saveStateSlot), Memory.isMBC5);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    Memory.currentRomBank = load<u16>(getSaveStateMemoryOffset(0x00, Memory.saveStateSlot));\n    Memory.currentRamBank = load<u16>(getSaveStateMemoryOffset(0x02, Memory.saveStateSlot));\n\n    Memory.isRamBankingEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x04, Memory.saveStateSlot));\n    Memory.isMBC1RomModeEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x05, Memory.saveStateSlot));\n\n    Memory.isRomOnly = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x06, Memory.saveStateSlot));\n    Memory.isMBC1 = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x07, Memory.saveStateSlot));\n    Memory.isMBC2 = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x08, Memory.saveStateSlot));\n    Memory.isMBC3 = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x09, Memory.saveStateSlot));\n    Memory.isMBC5 = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0A, Memory.saveStateSlot));\n  }\n}\n\nexport function initializeCartridge(): void {\n  // Get our game MBC type from the cartridge header\n  // http://gbdev.gg8.se/wiki/articles/The_Cartridge_Header\n  let cartridgeType: u8 = eightBitLoadFromGBMemory(0x0147);\n\n  // Reset our Cartridge types\n  Memory.isRomOnly = false;\n  Memory.isMBC1 = false;\n  Memory.isMBC2 = false;\n  Memory.isMBC3 = false;\n  Memory.isMBC5 = false;\n\n  if(cartridgeType === 0x00) {\n    Memory.isRomOnly = true;\n  } else if (cartridgeType >= 0x01 && cartridgeType <= 0x03) {\n    Memory.isMBC1 = true;\n  } else if (cartridgeType >= 0x05 && cartridgeType <= 0x06) {\n    Memory.isMBC2 = true;\n  } else if (cartridgeType >= 0x0F && cartridgeType <= 0x13) {\n    Memory.isMBC3 = true;\n  } else if (cartridgeType >= 0x19 && cartridgeType <= 0x1E) {\n    Memory.isMBC5 = true;\n  }\n}\n\n// Also need to store current frame in memory to be read by JS\nexport function setPixelOnFrame(x: u16, y: u16, color: u8): void {\n  // Currently only supports 160x144\n  // Storing in X, then y\n  // So need an offset\n\n  // Store our x and y to allow them to get really large\n  let largeY: i32 = y;\n  let largeX: i32 = x;\n\n  let offset: i32 = Memory.frameInProgressVideoOutputLocation + (largeY * 160) + largeX;\n\n  // Add one to the color, that way you don't ge the default zero\n  store<u8>(offset, color + 1);\n}\n\n// Need to also get our pixel on the frame for sprite priority\nexport function getPixelOnFrame(x: u16, y: u16): u8 {\n  // Currently only supports 160x144\n  // Storing in X, then y\n  // So need an offset\n\n  // Store our x and y to allow them to get really large\n  let largeY: i32 = y;\n  let largeX: i32 = x;\n\n  let offset: i32 = Memory.frameInProgressVideoOutputLocation + (largeY * 160) + largeX;\n\n  // Added one to the color, that way you don't ge the default zero\n  return load<u8>(offset);\n}\n\n// V-Blank occured, move our frame in progress to our render frame\nexport function storeFrameToBeRendered(): void {\n  for(let y: u32 = 0; y < 144; y++) {\n    for (let x: u32 = 0; x < 160; x++) {\n      store<u8>(Memory.currentFrameVideoOutputLocation + x + (y * 160), getPixelOnFrame(<u16>x, <u16>y))\n    }\n  }\n}\n\n// Function to set our left and right channels at the correct queue index\nexport function setLeftAndRightOutputForAudioQueue(leftVolume: u8, rightVolume: u8, audioQueueIndex: u32): void {\n  // Get our stereo index\n  let audioQueueOffset = Memory.soundOutputLocation + (audioQueueIndex * 2);\n\n  // Store our volumes\n  // +1 that way we don't have empty data to ensure that the value is set\n  store<u8>(audioQueueOffset, leftVolume + 1);\n  store<u8>(audioQueueOffset + 1, rightVolume + 1);\n}\n\n// Function to return an address to store into save state memory\n// this is to regulate our 20 slots\n// https://docs.google.com/spreadsheets/d/17xrEzJk5-sCB9J2mMJcVnzhbE-XH_NvczVSQH9OHvRk/edit?usp=sharing\nexport function getSaveStateMemoryOffset(offset: u16, saveStateSlot: u16): u16 {\n  // 50 byutes per save state memory partiton slot\n  let address: u16 = offset + (50 * saveStateSlot);\n  return address;\n}\n","// Function to handle rom/rambanking\nimport {\nMemory\n} from './memory';\nimport {\n  checkBitOnByte\n} from '../helpers/index';\n\nexport function handleBanking(offset: u16, value: u16): void {\n      // Is rom Only does not bank\n      if(Memory.isRomOnly) {\n        return;\n      }\n\n      // Enable Ram Banking\n      if(offset >= 0x0000 &&\n      offset <= 0x1FFF) {\n\n        if(Memory.isMBC2 && !checkBitOnByte(4, <u8>value)) {\n          // Do Nothing\n          return;\n        } else {\n          let romEnableByte = value & 0x0F;\n          if(romEnableByte === 0x00) {\n            Memory.isRamBankingEnabled = false;\n          } else if (romEnableByte === 0x0A) {\n            Memory.isRamBankingEnabled = true;\n          }\n        }\n      } else if(offset >= 0x2000 &&\n      offset <= 0x3FFF) {\n        if(!Memory.isMBC5 || offset <= 0x2FFF) {\n          // Change Low Bits on the Current Rom Bank\n          if (Memory.isMBC2) {\n\n            Memory.currentRomBank = value & 0x0F;\n          }\n\n          // Set the number of bottom bytes from the MBC type\n          let romBankLowerBits = value;\n          if (Memory.isMBC1) {\n            // Only want the bottom 5\n            romBankLowerBits = romBankLowerBits & 0x1F;\n            Memory.currentRomBank = Memory.currentRomBank & 0xE0;\n          } else if (Memory.isMBC3) {\n            // Only Want the bottom 7\n            romBankLowerBits = romBankLowerBits & 0x7F;\n            Memory.currentRomBank = Memory.currentRomBank & 0x80;\n          } else if (Memory.isMBC5) {\n            // Going to switch the whole thing\n            Memory.currentRomBank = Memory.currentRomBank & 0x00;\n          }\n\n          // Set the lower bytes\n          Memory.currentRomBank = Memory.currentRomBank | romBankLowerBits;\n          return;\n        } else {\n          // TODO: MBC5 High bits Rom bank\n        }\n      } else if(!Memory.isMBC2 &&\n      offset >= 0x4000 &&\n      offset <= 0x5FFF) {\n        // ROM / RAM Banking, MBC2 doesn't do this\n        if (Memory.isMBC1 && Memory.isMBC1RomModeEnabled) {\n          // Do an upper bit rom bank for MBC 1\n          // Remove upper bits of currentRomBank\n          Memory.currentRomBank = Memory.currentRomBank & 0x1F;\n\n          let romBankHigherBits = value & 0xE0;\n\n          Memory.currentRomBank = Memory.currentRomBank | romBankHigherBits;\n          return;\n        }\n\n        if (Memory.isMBC3) {\n          if(value >= 0x08 && value <= 0x0C) {\n            // TODO: MBC3 RTC Register Select\n          }\n        }\n\n        let ramBankBits = value;\n\n        if(!Memory.isMBC5) {\n          // Get the bottom 2 bits\n          ramBankBits = ramBankBits & 0x03;\n        } else {\n          // Get the bottom nibble\n          ramBankBits = ramBankBits & 0x0F;\n        }\n\n        // Set our ram bank\n        Memory.currentRamBank = ramBankBits;\n        return;\n      } else if(!Memory.isMBC2 &&\n      offset >= 0x6000 &&\n      offset <= 0x7FFF) {\n        if(Memory.isMBC1) {\n          if(checkBitOnByte(0, <u8>value)) {\n            Memory.isMBC1RomModeEnabled = true;\n          } else {\n            Memory.isMBC1RomModeEnabled = false;\n          }\n        }\n        // TODO: MBC3 Latch Clock Data\n      }\n}\n\nexport function getRomBankAddress(gameboyOffset: u32): u32 {\n  let currentRomBank: u16 = Memory.currentRomBank;\n  if(!Memory.isMBC5 && currentRomBank === 0) {\n    currentRomBank = 1;\n  }\n\n  // Adjust our gameboy offset relative to zero for the gameboy memory map\n  let romBankOffset: u32 = gameboyOffset - Memory.switchableCartridgeRomLocation;\n\n  let romBankSize: u32 = 0x4000;\n  let currentRomBankAddress: u32 = (0x4000 * currentRomBank) + romBankOffset;\n  return currentRomBankAddress;\n}\n\nexport function getRamBankAddress(gameboyOffset: u32): u32 {\n  // Adjust our gameboy offset relative to zero for the gameboy memory map\n  let ramBankOffset: u32 = gameboyOffset - Memory.cartridgeRamLocation;\n  let currentRamBankAddress: u32 = (0x2000 * Memory.currentRamBank) + ramBankOffset;\n  return currentRamBankAddress;\n}\n","// Main Class and funcitons for rendering the gameboy display\nimport {\n  setLcdStatus,\n  isLcdEnabled\n} from './lcd';\nimport {\n  renderBackground\n} from './background';\nimport {\n  renderWindow\n} from './window';\nimport {\n  renderSprites\n} from './sprites';\n// TODO: Dcode fixed the Assemblyscript bug where the index imports didn't work, can undo all of these now :)\nimport {\n  eightBitLoadFromGBMemory,\n  eightBitStoreIntoGBMemorySkipTraps,\n  storeFrameToBeRendered,\n  getSaveStateMemoryOffset,\n  loadBooleanDirectlyFromWasmMemory,\n  storeBooleanDirectlyToWasmMemory\n} from '../memory/index';\nimport {\n  requestVBlankInterrupt\n} from '../interrupts/index';\nimport {\n  checkBitOnByte,\n  setBitOnByte,\n  resetBitOnByte\n} from '../helpers/index';\n\nexport class Graphics {\n  // Count the number of cycles to keep synced with cpu cycles\n  static scanlineCycleCounter: i16 = 0x00;\n  static MAX_CYCLES_PER_SCANLINE: i16 = 456;\n  static MIN_CYCLES_SPRITES_LCD_MODE: i16 = 376;\n  static MIN_CYCLES_TRANSFER_DATA_LCD_MODE: i16 = 249;\n\n  // LCD\n  // scanlineRegister also known as LY\n  // See: http://bgb.bircd.org/pandocs.txt , and search \" LY \"\n  static memoryLocationScanlineRegister: u16 = 0xFF44;\n  static memoryLocationCoincidenceCompare: u16 = 0xFF45;\n  // Also known at STAT\n  static memoryLocationLcdStatus: u16 = 0xFF41;\n  // Also known as LCDC\n  static memoryLocationLcdControl: u16 = 0xFF40;\n  static currentLcdMode: u8 = 0;\n\n  // Scroll and Window\n  // TODO -7 on windowX, and export to be used\n  static memoryLocationScrollX: u16 = 0xFF43;\n  static memoryLocationScrollY: u16 = 0xFF42;\n  static memoryLocationWindowX: u16 = 0xFF4B;\n  static memoryLocationWindowY: u16 = 0xFF4A;\n\n  // Tile Maps And Data (TODO: Dont seperate Background and window :p)\n  static memoryLocationTileMapSelectZeroStart: u16 = 0x9800;\n  static memoryLocationTileMapSelectOneStart: u16 = 0x9C00;\n  static memoryLocationTileDataSelectZeroStart: u16 = 0x8800;\n  static memoryLocationTileDataSelectOneStart: u16 = 0x8000;\n\n  // Sprites\n  static memoryLocationSpriteAttributesTable: u16 = 0xFE00;\n\n  // Palettes\n  static memoryLocationBackgroundPalette: u16 = 0xFF47;\n  static memoryLocationSpritePaletteOne: u16 = 0xFF48;\n  static memoryLocationSpritePaletteTwo: u16 = 0xFF49;\n\n  // Colors\n  static colorWhite: u8 = 1;\n  static colorLightGrey: u8 = 2;\n  static colorDarkGrey: u8 = 3;\n  static colorBlack: u8 = 4;\n\n  // Screen data needs to be stored in wasm memory\n\n  // Save States\n\n  static saveStateSlot: u16 = 1;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    store<i16>(getSaveStateMemoryOffset(0x00, Graphics.saveStateSlot), Graphics.scanlineCycleCounter);\n    store<u8>(getSaveStateMemoryOffset(0x02, Graphics.saveStateSlot), Graphics.currentLcdMode);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    Graphics.scanlineCycleCounter = load<i16>(getSaveStateMemoryOffset(0x00, Graphics.saveStateSlot));\n    Graphics.currentLcdMode = load<u8>(getSaveStateMemoryOffset(0x02, Graphics.saveStateSlot));\n  }\n}\n\nexport function updateGraphics(numberOfCycles: u8): void {\n\n  setLcdStatus();\n\n  if(isLcdEnabled()) {\n\n    Graphics.scanlineCycleCounter += numberOfCycles;\n\n    if (Graphics.scanlineCycleCounter >= Graphics.MAX_CYCLES_PER_SCANLINE) {\n\n      // Reset the scanlineCycleCounter\n      // Don't set to zero to catch extra cycles\n      Graphics.scanlineCycleCounter -= Graphics.MAX_CYCLES_PER_SCANLINE;\n\n      // Move to next scanline\n      let scanlineRegister: u8 = eightBitLoadFromGBMemory(Graphics.memoryLocationScanlineRegister);\n\n      // Check if we've reached the last scanline\n      if(scanlineRegister === 144) {\n        // Draw the scanline\n        _drawScanline();\n        // Store the frame to be rendered\n        storeFrameToBeRendered();\n        // Request a VBlank interrupt\n        requestVBlankInterrupt();\n      } else if (scanlineRegister < 144) {\n        // Draw the scanline\n        _drawScanline();\n      }\n\n      // Store our scanline\n      if (scanlineRegister > 153) {\n        // Check if we overflowed scanlines\n        // if so, reset our scanline number\n        scanlineRegister = 0;\n      } else {\n        scanlineRegister += 1;\n      }\n      eightBitStoreIntoGBMemorySkipTraps(Graphics.memoryLocationScanlineRegister, scanlineRegister);\n    }\n  }\n}\n\n// TODO: Make this a _drawPixelOnScanline, as values can be updated while drawing a scanline\nfunction _drawScanline(): void {\n  // http://www.codeslinger.co.uk/pages/projects/gameboy/graphics.html\n  // Bit 7 - LCD Display Enable (0=Off, 1=On)\n  // Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)\n  // Bit 5 - Window Display Enable (0=Off, 1=On)\n  // Bit 4 - BG & Window Tile Data Select (0=8800-97FF, 1=8000-8FFF)\n  // Bit 3 - BG Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)\n  // Bit 2 - OBJ (Sprite) Size (0=8x8, 1=8x16)\n  // Bit 1 - OBJ (Sprite) Display Enable (0=Off, 1=On)\n  // Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)\n\n  // Get our lcd control, see above for usage\n  let lcdControl: u8 = eightBitLoadFromGBMemory(Graphics.memoryLocationLcdControl);\n\n  // Get our scanline register\n  let scanlineRegister: u8 = eightBitLoadFromGBMemory(Graphics.memoryLocationScanlineRegister);\n\n  // Get our seleted tile data memory location\n  let tileDataMemoryLocation = Graphics.memoryLocationTileDataSelectZeroStart;\n  if(checkBitOnByte(4, lcdControl)) {\n    tileDataMemoryLocation = Graphics.memoryLocationTileDataSelectOneStart;\n  }\n\n\n  // Check if the background is enabled\n  if (checkBitOnByte(0, lcdControl)) {\n\n    // Get our map memory location\n    let tileMapMemoryLocation = Graphics.memoryLocationTileMapSelectZeroStart;\n    if (checkBitOnByte(3, lcdControl)) {\n      tileMapMemoryLocation = Graphics.memoryLocationTileMapSelectOneStart;\n    }\n\n    // Finally, pass everything to draw the background\n    renderBackground(scanlineRegister, tileDataMemoryLocation, tileMapMemoryLocation);\n  }\n\n  // Check if the window is enabled, and we are currently\n  // Drawing lines on the window\n  if(checkBitOnByte(5, lcdControl)) {\n\n    // Get our map memory location\n    let tileMapMemoryLocation = Graphics.memoryLocationTileMapSelectZeroStart;\n    if (checkBitOnByte(6, lcdControl)) {\n      tileMapMemoryLocation = Graphics.memoryLocationTileMapSelectOneStart;\n    }\n\n    // Finally, pass everything to draw the background\n    renderWindow(scanlineRegister, tileDataMemoryLocation, tileMapMemoryLocation);\n  }\n\n  if (checkBitOnByte(1, lcdControl)) {\n    // Sprites are enabled, render them!\n    renderSprites(scanlineRegister, checkBitOnByte(2, lcdControl));\n  }\n}\n","// WasmBoy memory map:\n// https://docs.google.com/spreadsheets/d/17xrEzJk5-sCB9J2mMJcVnzhbE-XH_NvczVSQH9OHvRk/edit?usp=sharing\n\nimport { Memory } from './memory';\nimport {\n  getRomBankAddress,\n  getRamBankAddress\n} from './banking';\nimport {\n  hexLog\n} from '../helpers/index';\n\n// Private function to translate a offset meant for the gameboy memory map\n// To the wasmboy memory map\n// Following: http://gameboy.mongenel.com/dmg/asmmemmap.html\n// And https://github.com/Dooskington/GameLad/wiki/Part-11---Memory-Bank-Controllers\nexport function getWasmBoyOffsetFromGameBoyOffset(gameboyOffset: u32): u32 {\n\n  // Wasmboy offset\n  let wasmboyOffset: u32 = Memory.gameBoyInternalMemoryLocation;\n\n  // Find the wasmboy offser\n  if(gameboyOffset < Memory.switchableCartridgeRomLocation) {\n    // Cartridge ROM - Bank 0 (fixed)\n    // 0x0000 -> 0x073800\n    wasmboyOffset = gameboyOffset + Memory.gameBytesLocation;\n  } else if(gameboyOffset >= Memory.switchableCartridgeRomLocation && gameboyOffset < Memory.videoRamLocation) {\n    // Cartridge ROM - Switchable Banks 1-xx\n    // 0x4000 -> (0x073800 + 0x4000)\n    wasmboyOffset = getRomBankAddress(gameboyOffset) + Memory.gameBytesLocation;\n  } else if (gameboyOffset >= Memory.videoRamLocation && gameboyOffset < Memory.cartridgeRamLocation) {\n    // Video RAM\n    // 0x8000 -> 0x000400\n    wasmboyOffset = (gameboyOffset - Memory.videoRamLocation) + Memory.gameBoyInternalMemoryLocation;\n  } else if (gameboyOffset >= Memory.cartridgeRamLocation && gameboyOffset < Memory.internalRamBankZeroLocation) {\n    // Cartridge RAM - A.K.A External RAM\n    // 0xA000 -> 0x008400\n    wasmboyOffset = getRamBankAddress(gameboyOffset) + Memory.gameRamBanksLocation;\n  } else if(gameboyOffset >= Memory.internalRamBankZeroLocation) {\n    // NOTE / TODO: Switchable Internal Ram Banks?\n    // 0xC000 -> 0x000400\n    wasmboyOffset = (gameboyOffset - Memory.videoRamLocation) + Memory.gameBoyInternalMemoryLocation;\n  }\n\n  return wasmboyOffset;\n}\n","// https://emu-docs.org/Game%20Boy/gb_sound.txt\n// https://www.youtube.com/watch?v=HyzD8pNlpwI\n// https://gist.github.com/drhelius/3652407\n\nimport {\n    Channel1\n} from './channel1';\nimport {\n    Channel2\n} from './channel2';\nimport {\n    Channel3\n} from './channel3';\nimport {\n    Channel4\n} from './channel4';\nimport {\n  isChannelEnabledOnLeftOutput,\n  isChannelEnabledOnRightOutput\n} from './registers';\nimport {\n  Cpu\n} from '../cpu/index';\nimport {\n  eightBitLoadFromGBMemory,\n  eightBitStoreIntoGBMemory,\n  setLeftAndRightOutputForAudioQueue,\n  getSaveStateMemoryOffset,\n  loadBooleanDirectlyFromWasmMemory,\n  storeBooleanDirectlyToWasmMemory\n} from '../memory/index';\nimport {\n  hexLog\n} from '../helpers/index';\n\nexport class Sound {\n\n  // Channel control / On-OFF / Volume (RW)\n  static memoryLocationNR50: u16 = 0xFF24;\n\n  // 0xFF25 selects which output each channel goes to, Referred to as NR51\n  static memoryLocationNR51: u16 = 0xFF25;\n\n  // Sound on/off\n  static memoryLocationNR52: u16 = 0xFF26;\n\n  // $FF30 -- $FF3F is the load register space for the 4-bit samples for channel 3\n  static memoryLocationChannel3LoadRegisterStart: u16 = 0xFF30;\n\n  // Need to count how often we need to increment our frame sequencer\n  // Which you can read about below\n  static frameSequenceCycleCounter: i16 = 0x0000;\n  static maxFrameSequenceCycles: i16 = 8192;\n\n  // Also need to downsample our audio to average audio qualty\n  // https://www.reddit.com/r/EmuDev/comments/5gkwi5/gb_apu_sound_emulation/\n  // Want to do 48000hz, so CpuRate / Sound Rate, 4194304 / 48000 ~ 87 cycles\n  static downSampleCycleCounter: u8 = 0x00;\n  static maxDownSampleCycles: u8 = 87;\n\n  // Frame sequencer controls what should be updated and and ticked\n  // Everyt time the sound is updated :) It is updated everytime the\n  // Cycle counter reaches the max cycle\n  static frameSequencer: u8 = 0x00;\n\n  // Our current sample number we are passing back to the wasmboy memory map\n  // Going to pass back 4096 samples and then reset\n  static audioQueueIndex: u32 = 0x0000;\n\n  // Save States\n\n  static saveStateSlot: u16 = 6;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    store<i16>(getSaveStateMemoryOffset(0x00, Sound.saveStateSlot), Sound.frameSequenceCycleCounter);\n    store<u8>(getSaveStateMemoryOffset(0x02, Sound.saveStateSlot), Sound.downSampleCycleCounter);\n    store<u8>(getSaveStateMemoryOffset(0x03, Sound.saveStateSlot), Sound.frameSequencer);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    Sound.frameSequenceCycleCounter = load<i16>(getSaveStateMemoryOffset(0x00, Sound.saveStateSlot));\n    Sound.downSampleCycleCounter = load<u8>(getSaveStateMemoryOffset(0x02, Sound.saveStateSlot));\n    Sound.frameSequencer = load<u8>(getSaveStateMemoryOffset(0x03, Sound.saveStateSlot));\n\n    resetAudioQueue();\n  }\n}\n\n// Initialize sound registers\n// From: https://emu-docs.org/Game%20Boy/gb_sound.txt\nexport function initializeSound(): void {\n\n  // intiialize our channels\n  Channel1.initialize();\n  Channel2.initialize();\n  Channel3.initialize();\n  Channel4.initialize();\n\n  // Other Sound Registers\n  eightBitStoreIntoGBMemory(Sound.memoryLocationNR50, 0x77);\n  eightBitStoreIntoGBMemory(Sound.memoryLocationNR51, 0xF3);\n  eightBitStoreIntoGBMemory(Sound.memoryLocationNR52, 0xF1);\n}\n\n// Function for updating sound\nexport function updateSound(numberOfCycles: u8): void {\n  // APU runs at 4194304 / 512\n  // Or Cpu.clockSpeed / 512\n  // Which means, we need to update once every 8192 cycles :)\n  Sound.frameSequenceCycleCounter += <i16>numberOfCycles;\n  if(Sound.frameSequenceCycleCounter >= Sound.maxFrameSequenceCycles) {\n    // Reset the frameSequenceCycleCounter\n    // Not setting to zero as we do not want to drop cycles\n    Sound.frameSequenceCycleCounter -= Sound.maxFrameSequenceCycles;\n\n    // Check our frame sequencer\n    // TODO: uncomment\n    // https://gist.github.com/drhelius/3652407\n    if (Sound.frameSequencer === 0) {\n      // Update Length on Channels\n      Channel1.updateLength();\n      Channel2.updateLength();\n      Channel3.updateLength();\n      Channel4.updateLength();\n    } /* Do Nothing on one */ else if(Sound.frameSequencer === 2) {\n      // Update Sweep and Length on Channels\n      Channel1.updateLength();\n      Channel2.updateLength();\n      Channel3.updateLength();\n      Channel4.updateLength();\n\n      Channel1.updateSweep();\n    } /* Do Nothing on three */ else if(Sound.frameSequencer === 4) {\n      // Update Length on Channels\n      Channel1.updateLength();\n      Channel2.updateLength();\n      Channel3.updateLength();\n      Channel4.updateLength();\n    } /* Do Nothing on three */ else if(Sound.frameSequencer === 6) {\n      // Update Sweep and Length on Channels\n      Channel1.updateLength();\n      Channel2.updateLength();\n      Channel3.updateLength();\n      Channel4.updateLength();\n\n      Channel1.updateSweep();\n    } else if(Sound.frameSequencer === 7) {\n      // Update Envelope on channels\n      Channel1.updateEnvelope();\n      Channel2.updateEnvelope();\n      Channel4.updateEnvelope();\n    }\n\n    // Update our frame sequencer\n    Sound.frameSequencer += 1;\n    if(Sound.frameSequencer >= 8) {\n      Sound.frameSequencer = 0;\n    }\n  }\n\n  // Update all of our channels\n  // All samples will be returned as 0 to 30\n  // 0 being -1.0, and 30 being 1.0\n  let channel1Sample: u32 = Channel1.getSample(numberOfCycles);\n  let channel2Sample: u32 = Channel2.getSample(numberOfCycles);\n  let channel3Sample: u32 = Channel3.getSample(numberOfCycles);\n  let channel4Sample: u32 = Channel4.getSample(numberOfCycles);\n\n  // Do Some downsampling magic\n  Sound.downSampleCycleCounter += numberOfCycles;\n  if(Sound.downSampleCycleCounter >= Sound.maxDownSampleCycles) {\n\n    // Reset the downsample counter\n    // Don't set to zero to catch overflowed cycles\n    Sound.downSampleCycleCounter -= Sound.maxDownSampleCycles;\n\n    // Do Some Cool mixing\n    // NR50 FF24 ALLL BRRR Vin L enable, Left vol, Vin R enable, Right vol\n    // NR51 FF25 NW21 NW21 Left enables, Right enables\n    // NR52 FF26 P--- NW21 Power control/status, Channel length statuses\n    // NW21 = 4 bits on byte\n    // 3 -> Channel 4, 2 -> Channel 3, 1 -> Channel 2, 0 -> Channel 1\n\n    // Matt's Proccess\n    // I push out 1024 samples at a time and use 96000 hz sampling rate, so I guess i'm a bit less than one frame,\n    // but I let the queue fill up with 4 x 1024 samples before I start waiting for the audio\n\n    // TODO: Vin Mixing\n\n    // Simply get the left/right volume, add up the values, and put into memory!\n    let registerNR50 = eightBitLoadFromGBMemory(Sound.memoryLocationNR50);\n    // Want bits 6-4\n    let leftMixerVolume: u8 = (registerNR50 >> 4);\n    leftMixerVolume = leftMixerVolume & 0x07;\n    // Want bits 0-2\n    let rightMixerVolume: u8 = registerNR50;\n    rightMixerVolume = rightMixerVolume & 0x07;\n\n    // Get our channel volume for left/right\n    let leftChannelSample: u32 = 0;\n    let rightChannelSample: u32 = 0;\n\n    // Find the channel for the left volume\n    if (isChannelEnabledOnLeftOutput(Channel1.channelNumber)) {\n      leftChannelSample += channel1Sample;\n    }\n    if (isChannelEnabledOnLeftOutput(Channel2.channelNumber)) {\n      leftChannelSample += channel2Sample;\n    }\n    if (isChannelEnabledOnLeftOutput(Channel3.channelNumber)) {\n      leftChannelSample += channel3Sample;\n    }\n    if (isChannelEnabledOnLeftOutput(Channel4.channelNumber)) {\n      leftChannelSample += channel4Sample;\n    }\n\n\n    // Find the channel for the right volume\n    // TODO: Other Channels\n    if (isChannelEnabledOnRightOutput(Channel1.channelNumber)) {\n      rightChannelSample += channel1Sample;\n    }\n    if (isChannelEnabledOnRightOutput(Channel2.channelNumber)) {\n      rightChannelSample += channel2Sample;\n    }\n    if (isChannelEnabledOnRightOutput(Channel3.channelNumber)) {\n      rightChannelSample += channel3Sample;\n    }\n    if (isChannelEnabledOnRightOutput(Channel4.channelNumber)) {\n      rightChannelSample += channel4Sample;\n    }\n\n    // Finally multiple our volumes by the mixer volume\n    // Mixer volume can be at most 7 + 1\n    // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Mixer\n    // TODO: Came out wrong and sounds weird\n    //leftChannelSample = leftChannelSample * (leftMixerVolume + 1);\n    //rightChannelSample = rightChannelSample * (rightMixerVolume + 1);\n\n    // Convert our samples from unsigned 32 to unsigned byte\n    // Reason being, We want to be able to pass in wasm memory as usigned byte. Javascript will handle the conversion back\n    let leftChannelSampleUnsignedByte: u8 = getSampleAsUnsignedByte(leftChannelSample);\n    let rightChannelSampleUnsignedByte: u8 = getSampleAsUnsignedByte(rightChannelSample);\n\n    // Set our volumes in memory\n    // +1 so it can not be zero\n    setLeftAndRightOutputForAudioQueue(leftChannelSampleUnsignedByte + 1, rightChannelSampleUnsignedByte + 1, Sound.audioQueueIndex);\n    Sound.audioQueueIndex += 1;\n\n    // Don't allow our audioQueueIndex to overflow into other parts of the wasmBoy memory map\n    // https://docs.google.com/spreadsheets/d/17xrEzJk5-sCB9J2mMJcVnzhbE-XH_NvczVSQH9OHvRk/edit#gid=0\n    // Not 0xFFFF because we need half of 64kb since we store left and right channel\n    if(Sound.audioQueueIndex >= (0xFFFF / 2) - 1) {\n      resetAudioQueue();\n    }\n  }\n}\n\n// Funciton to get the current Audio Queue index\nexport function getAudioQueueIndex(): u32 {\n  return Sound.audioQueueIndex;\n}\n\n// Function to reset the audio queue\nexport function resetAudioQueue(): void {\n  Sound.audioQueueIndex = 0;\n}\n\nfunction getSampleAsUnsignedByte(sample: u32): u8 {\n  // With Four Channels (0 to 30) and no global volume. Max is 120, goal is 254. 120 * 2.1167 should give approximate answer\n  let adjustedSample: u32 = sample * 21 / 10;\n  let convertedSample: u8 = <u8>adjustedSample;\n  return convertedSample;\n}\n\nfunction getSampleAsUnsignedByteForSingleChannel(sample: u32): u8 {\n  // With One Channels (0 to 30) and no global volume. Max is 30, goal is 254. 30 * 8.4 should give approximate answer\n  let adjustedSample: u32 = sample * 84 / 10;\n  let convertedSample: u8 = <u8>adjustedSample;\n  return convertedSample;\n}\n","// Functions involved in R/W of sound registers\n// Information of bits on every register can be found at: https://gist.github.com/drhelius/3652407\n// Passing channel number to make things simpler than passing around memory addresses, to avoid bugs in choosing the wrong address\n\nimport {\n  Sound\n} from './sound';\nimport {\n    Channel1\n} from './channel1';\nimport {\n    Channel2\n} from './channel2';\nimport {\n    Channel3\n} from './channel3';\nimport {\n    Channel4\n} from './channel4';\nimport {\n  setChannelLengthCounter\n} from '../sound/length';\nimport {\n  eightBitLoadFromGBMemory,\n  eightBitStoreIntoGBMemory,\n  eightBitStoreIntoGBMemorySkipTraps\n} from '../memory/index';\nimport {\n  checkBitOnByte,\n  hexLog\n} from '../helpers/index';\n\n// TODO: handledReadToSoundRegister\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Registers\n// binji: I have a bool per channel called status that basically keeps track of whether a channel is playing currently. I return that bool in NR52\n\n// Function to check and handle writes to sound registers\nexport function handledWriteToSoundRegister(offset: u16, value: u16): boolean {\n\n  // Get our registerNR52\n  let registerNR52: u8 = eightBitLoadFromGBMemory(Sound.memoryLocationNR52);\n\n  if(offset !== Sound.memoryLocationNR52 && !checkBitOnByte(7, registerNR52)) {\n    // Block all writes to any sound register EXCEPT NR52!\n    // This is under the assumption that the check for\n    // offset >= 0xFF10 && offset <= 0xFF26\n    // is done in writeTraps.ts (which it is)\n    // NOTE: Except on DMG, length can still be written (whatever that means)\n    return true;\n  }\n\n  // Set length counter on channels\n  if(offset === Channel1.memoryLocationNRx1) {\n    eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n    setChannelLengthCounter(Channel1.channelNumber);\n    return true;\n  } else if(offset === Channel2.memoryLocationNRx1) {\n    eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n    setChannelLengthCounter(Channel2.channelNumber);\n    return true;\n  } else if(offset === Channel3.memoryLocationNRx1) {\n    eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n    setChannelLengthCounter(Channel3.channelNumber);\n    return true;\n  } else if(offset === Channel4.memoryLocationNRx1) {\n    eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n    setChannelLengthCounter(Channel4.channelNumber);\n    return true;\n  }\n\n  // Check our NRx4 registers to trap our trigger bits\n  if(offset === Channel1.memoryLocationNRx4 && checkBitOnByte(7, <u8>value)) {\n    // Write the value skipping traps, and then trigger\n    eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n    Channel1.trigger();\n    return true;\n  } else if(offset === Channel2.memoryLocationNRx4 && checkBitOnByte(7, <u8>value)) {\n    eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n    Channel2.trigger();\n    return true;\n  } else if(offset === Channel3.memoryLocationNRx4 && checkBitOnByte(7, <u8>value)) {\n    eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n    Channel3.trigger();\n    return true;\n  } else if(offset === Channel4.memoryLocationNRx4 && checkBitOnByte(7, <u8>value)) {\n    eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n    Channel4.trigger();\n    return true;\n  }\n\n  // Write 0 to the 7th bit of NR52, resets all sound registers, and stops them from receiving writes\n  if(offset === Sound.memoryLocationNR52 && !checkBitOnByte(7, <u8>value)) {\n\n    // Reset all registers except NR52\n    for (let i: u16 = 0xFF10; i < 0xFF26; i++) {\n      eightBitStoreIntoGBMemorySkipTraps(i, 0x00);\n    }\n\n    // Write our final value to NR52\n    eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n\n    return true;\n  }\n\n  // We did not handle the write, return false\n  return false;\n}\n\nexport function getChannelStartingVolume(channelNumber: i8): u8 {\n  // Simply need to get the top 4 bits of register 2\n  let startingVolume: u8 = getRegister2OfChannel(channelNumber);\n  startingVolume = (startingVolume >> 4);\n  return (startingVolume & 0x0F);\n}\n\nexport function isChannelDacEnabled(channelNumber: i8): boolean {\n  // DAC power is controlled by the upper 5 bits of NRx2 (top bit of NR30 for wave channel).\n  // If these bits are not all clear, the DAC is on, otherwise it's off and outputs 0 volts.\n  if(channelNumber !== 3) {\n    let register2 = getRegister2OfChannel(channelNumber);\n    // Clear bottom 3 bits\n    let dacStatus = (register2 & 0xF8);\n    if (dacStatus > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    let register3 = eightBitLoadFromGBMemory(Channel3.memoryLocationNRx0);\n    return checkBitOnByte(7, register3);\n  }\n}\n\nexport function isChannelEnabledOnLeftOutput(channelNumber: i8): boolean {\n  let registerNR51: u8 = eightBitLoadFromGBMemory(Sound.memoryLocationNR51);\n  // Left channel in the higher bits\n  let bitNumberOfChannel: u8 = (<u8>channelNumber - 1) + 4;\n  return checkBitOnByte(bitNumberOfChannel, registerNR51);\n}\n\nexport function isChannelEnabledOnRightOutput(channelNumber: i8): boolean {\n  let registerNR51: u8 = eightBitLoadFromGBMemory(Sound.memoryLocationNR51);\n  // Left channel in the higher bits\n  let bitNumberOfChannel: u8 = (<u8>channelNumber - 1);\n  return checkBitOnByte(bitNumberOfChannel, registerNR51);\n}\n\n// Function to get 1st register of a channel\n// Contains Duty and Length\nexport function getRegister1OfChannel(channelNumber: i8): u8 {\n  if (channelNumber === 1) {\n    return eightBitLoadFromGBMemory(Channel1.memoryLocationNRx1);\n  } else if (channelNumber === 2) {\n    return eightBitLoadFromGBMemory(Channel2.memoryLocationNRx1);\n  } else if (channelNumber === 3) {\n    return eightBitLoadFromGBMemory(Channel3.memoryLocationNRx1);\n  } else {\n    return eightBitLoadFromGBMemory(Channel4.memoryLocationNRx1);\n  }\n}\n\n// Function to get 2nd register of a channel\n// Contains Envelope Information\nexport function getRegister2OfChannel(channelNumber: i8): u8 {\n  if (channelNumber === 1) {\n    return eightBitLoadFromGBMemory(Channel1.memoryLocationNRx2);\n  } else if (channelNumber === 2) {\n    return eightBitLoadFromGBMemory(Channel2.memoryLocationNRx2);\n  } else if (channelNumber === 3) {\n    return eightBitLoadFromGBMemory(Channel3.memoryLocationNRx2);\n  } else {\n    return eightBitLoadFromGBMemory(Channel4.memoryLocationNRx2);\n  }\n}\n\n// Function to get 3rd register of a channel\n// Contains Fequency LSB (lower 8 bits)\nexport function getRegister3OfChannel(channelNumber: i8): u8 {\n  if (channelNumber === 1) {\n    return eightBitLoadFromGBMemory(Channel1.memoryLocationNRx3);\n  } else if (channelNumber === 2) {\n    return eightBitLoadFromGBMemory(Channel2.memoryLocationNRx3);\n  } else if (channelNumber === 3) {\n    return eightBitLoadFromGBMemory(Channel3.memoryLocationNRx3);\n  } else {\n    return eightBitLoadFromGBMemory(Channel4.memoryLocationNRx3);\n  }\n}\n\nexport function setRegister3OfChannel(channelNumber: i8, value: u8): void {\n  if (channelNumber === 1) {\n    eightBitStoreIntoGBMemorySkipTraps(Channel1.memoryLocationNRx3, value);\n  } else if (channelNumber === 2) {\n    eightBitStoreIntoGBMemorySkipTraps(Channel2.memoryLocationNRx3, value);\n  } else if (channelNumber === 3) {\n    eightBitStoreIntoGBMemorySkipTraps(Channel3.memoryLocationNRx3, value);\n  } else {\n    eightBitStoreIntoGBMemorySkipTraps(Channel4.memoryLocationNRx3, value);\n  }\n}\n\n// Function to get 4th register of a channel\n// Contains Fequency MSB (higher 3 bits), and Length Information\nexport function getRegister4OfChannel(channelNumber: i8): u8 {\n  if (channelNumber === 1) {\n    return eightBitLoadFromGBMemory(Channel1.memoryLocationNRx4);\n  } else if (channelNumber === 2) {\n    return eightBitLoadFromGBMemory(Channel2.memoryLocationNRx4);\n  } else if (channelNumber === 3) {\n    return eightBitLoadFromGBMemory(Channel3.memoryLocationNRx4);\n  } else {\n    return eightBitLoadFromGBMemory(Channel4.memoryLocationNRx4);\n  }\n}\n\nexport function setRegister4OfChannel(channelNumber: i8, value: u8): void {\n  if (channelNumber === 1) {\n    eightBitStoreIntoGBMemorySkipTraps(Channel1.memoryLocationNRx4, value);\n  } else if (channelNumber === 2) {\n    eightBitStoreIntoGBMemorySkipTraps(Channel2.memoryLocationNRx4, value);\n  } else if (channelNumber === 3) {\n    eightBitStoreIntoGBMemorySkipTraps(Channel3.memoryLocationNRx4, value);\n  } else {\n    eightBitStoreIntoGBMemorySkipTraps(Channel4.memoryLocationNRx4, value);\n  }\n}\n","// Load/Read functionality for memory\nimport {\n  checkReadTraps\n} from './readTraps';\nimport {\n  getWasmBoyOffsetFromGameBoyOffset\n} from './memoryMap';\nimport {\n  concatenateBytes\n} from '../helpers/index';\n\nexport function eightBitLoadFromGBMemory(offset: u16): u8 {\n  if (checkReadTraps(offset) < 0) {\n    return _eightBitLoadFromWasmBoyMemory(offset);\n  } else {\n    return <u8>checkReadTraps(offset);\n  }\n}\n\nexport function eightBitLoadFromGBMemorySkipTraps(offset: u16): u8 {\n  return _eightBitLoadFromWasmBoyMemory(offset);\n}\n\nexport function sixteenBitLoadFromGBMemory(offset: u16): u16 {\n\n  // Get our low byte\n  let lowByte: u8 = 0;\n  if (checkReadTraps(offset) < 0) {\n    lowByte = _eightBitLoadFromWasmBoyMemory(offset);\n  } else {\n    lowByte = <u8>checkReadTraps(offset);\n  }\n\n  // Get the next offset for the second byte\n  let nextOffset: u16 = offset + 1;\n\n  // Get our high byte\n  let highByte: u8 = 0;\n  if (checkReadTraps(nextOffset) < 0) {\n    highByte = _eightBitLoadFromWasmBoyMemory(nextOffset);\n  } else {\n    highByte = <u8>checkReadTraps(nextOffset);\n  }\n\n  // Concatenate the bytes and return\n  let concatenatedValue: u16 = concatenateBytes(highByte, lowByte);\n  return concatenatedValue;\n}\n\nfunction _eightBitLoadFromWasmBoyMemory(gameboyOffset: u16): u8 {\n  let wasmboyOffset: u32 = getWasmBoyOffsetFromGameBoyOffset(gameboyOffset);\n  return load<u8>(wasmboyOffset);\n}\n\nexport function loadBooleanDirectlyFromWasmMemory(offset: u32): boolean {\n  let booleanAsInt: u8 = load<u8>(offset);\n  if(booleanAsInt > 0) {\n    return true;\n  }\n  return false;\n}\n","import {\n  Memory\n} from './memory';\nimport {\n  Graphics\n} from '../graphics/graphics';\nimport {\n  eightBitStoreIntoGBMemorySkipTraps\n} from './store';\nimport {\n  getJoypadState\n} from '../joypad/index'\n\n// Returns -1 if no trap found, otherwise returns a value that should be fed for the address\nexport function checkReadTraps(offset: u16): i32 {\n\n  // Check the graphics mode to see if we can write to VRAM\n  // http://gbdev.gg8.se/wiki/articles/Video_Display#Accessing_VRAM_and_OAM\n  if(offset >= Memory.videoRamLocation && offset < Memory.cartridgeRamLocation) {\n    // Can only read/write from VRAM During Modes 0 - 2\n    // See graphics/lcd.ts\n    if (Graphics.currentLcdMode > 2) {\n      return 0xFF;\n    }\n  }\n\n  // Also check for individal writes\n  // Can only read/write from OAM During Modes 0 - 1\n  // See graphics/lcd.ts\n  if(offset >= Memory.spriteInformationTableLocation && offset <= Memory.spriteInformationTableLocationEnd) {\n    // Can only read/write from OAM During Mode 2\n    // See graphics/lcd.ts\n    if (Graphics.currentLcdMode !== 2) {\n      return 0xFF;\n    }\n  }\n\n  if(offset === 0xFF00) {\n    return getJoypadState();\n  }\n\n\n\n  return -1;\n}\n","import {\n  Cpu\n} from '../cpu/index';\nimport {\n  eightBitStoreIntoGBMemorySkipTraps\n} from '../memory/store';\nimport {\n  eightBitLoadFromGBMemorySkipTraps\n} from '../memory/load';\nimport {\n  requestJoypadInterrupt\n} from '../interrupts/index';\nimport {\n  checkBitOnByte,\n  setBitOnByte,\n  resetBitOnByte\n} from '../helpers/index';\n\n// http://www.codeslinger.co.uk/pages/projects/gameboy/joypad.html\n// Joypad Register\n// Taken from pandocs\n// Bit 7 - Not used\n// Bit 6 - Not used\n// Bit 5 - P15 Select Button Keys (0=Select)\n// Bit 4 - P14 Select Direction Keys (0=Select)\n// Bit 3 - P13 Input Down or Start (0=Pressed) (Read Only)\n// Bit 2 - P12 Input Up or Select (0=Pressed) (Read Only)\n// Bit 1 - P11 Input Left or Button B (0=Pressed) (Read Only)\n// Bit 0 - P10 Input Right or Button A (0=Pressed) (Read Only)\n\n// Button Ids will be the following:\n// UP - 0\n// RIGHT - 1\n// DOWN - 2\n// LEFT - 3\n// A - 4\n// B - 5\n// SELECT - 6\n// START - 7\n\nexport class Joypad {\n  static up: boolean = false;\n  static down: boolean = false;\n  static left: boolean = false;\n  static right: boolean = false;\n  static a: boolean = false;\n  static b: boolean = false;\n  static select: boolean = false;\n  static start: boolean = false;\n\n  static memoryLocationJoypadRegister: u16 = 0xFF00;\n\n  // Save States\n  // Not doing anything for Joypad for now\n\n  static saveStateSlot: u16 = 3;\n\n  // Function to save the state of the class\n  static saveState(): void {\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n  }\n}\n\nexport function getJoypadState(): u8 {\n\n  // Get the joypad register\n  let joypadRegister: u8 = eightBitLoadFromGBMemorySkipTraps(Joypad.memoryLocationJoypadRegister);\n\n  // Flip all the bits\n  joypadRegister = joypadRegister ^ 0xFF;\n\n  // Check the button type buttons\n  if(!checkBitOnByte(4, joypadRegister)) {\n\n    // Set the top 4 bits to on\n    joypadRegister = joypadRegister | 0xF0;\n\n    // A\n    if (Joypad.a) {\n      joypadRegister = resetBitOnByte(0, joypadRegister);\n    } else {\n      joypadRegister = setBitOnByte(0, joypadRegister);\n    }\n\n    // B\n    if (Joypad.b) {\n      joypadRegister = resetBitOnByte(1, joypadRegister);\n    } else {\n      joypadRegister = setBitOnByte(1, joypadRegister);\n    }\n\n    // Select\n    if (Joypad.select) {\n      joypadRegister = resetBitOnByte(2, joypadRegister);\n    } else {\n      joypadRegister = setBitOnByte(2, joypadRegister);\n    }\n\n    // Start\n    if (Joypad.start) {\n      joypadRegister = resetBitOnByte(3, joypadRegister);\n    } else {\n      joypadRegister = setBitOnByte(3, joypadRegister);\n    }\n  } else if (!checkBitOnByte(5, joypadRegister)) {\n    // D-pad buttons\n\n    // Set the top 4 bits to on\n    joypadRegister = joypadRegister | 0xF0;\n\n    // Up\n    if (Joypad.up) {\n      joypadRegister = resetBitOnByte(2, joypadRegister);\n    } else {\n      joypadRegister = setBitOnByte(2, joypadRegister);\n    }\n\n    // Right\n    if (Joypad.right) {\n      joypadRegister = resetBitOnByte(0, joypadRegister);\n    } else {\n      joypadRegister = setBitOnByte(0, joypadRegister);\n    }\n\n    // Down\n    if (Joypad.down) {\n      joypadRegister = resetBitOnByte(3, joypadRegister);\n    } else {\n      joypadRegister = setBitOnByte(3, joypadRegister);\n    }\n\n    // Left\n    if (Joypad.left) {\n      joypadRegister = resetBitOnByte(1, joypadRegister);\n    } else {\n      joypadRegister = setBitOnByte(1, joypadRegister);\n    }\n  }\n\n  return joypadRegister;\n}\n\nexport function setJoypadState(up: i8, right: i8, down: i8, left: i8, a: i8, b: i8, select: i8, start: i8): void {\n\n  if (up > 0) {\n    _pressJoypadButton(0);\n  } else {\n    _releaseJoypadButton(0);\n  }\n\n  if (right > 0) {\n    _pressJoypadButton(1);\n  } else {\n    _releaseJoypadButton(1);\n  }\n\n  if (down > 0) {\n    _pressJoypadButton(2);\n  } else {\n    _releaseJoypadButton(2);\n  }\n\n  if (left > 0) {\n    _pressJoypadButton(3);\n  } else {\n    _releaseJoypadButton(3);\n  }\n\n  if (a > 0) {\n    _pressJoypadButton(4);\n  } else {\n    _releaseJoypadButton(4);\n  }\n\n  if (b > 0) {\n    _pressJoypadButton(5);\n  } else {\n    _releaseJoypadButton(5);\n  }\n\n  if (select > 0) {\n    _pressJoypadButton(6);\n  } else {\n    _releaseJoypadButton(6);\n  }\n\n  if (start > 0) {\n    _pressJoypadButton(7);\n  } else {\n    _releaseJoypadButton(7);\n  }\n}\n\nfunction _pressJoypadButton(buttonId: u8): void {\n\n  // Un stop the CPU\n  Cpu.isStopped = false;\n\n  // Check if the button state changed from not pressed\n  let isButtonStateChanging: boolean = false;\n  if(!_getJoypadButtonStateFromButtonId(buttonId)) {\n    isButtonStateChanging = true;\n  }\n\n  // Set our joypad state\n  _setJoypadButtonStateFromButtonId(buttonId, true);\n\n  // If the button state is changing, check for an interrupt\n  if (isButtonStateChanging) {\n    // Determine if it is a button or a dpad button\n    let isDpadTypeButton = false;\n    if (buttonId <= 3) {\n      isDpadTypeButton = true;\n    }\n\n    // Determine if we should request an interrupt\n    let joypadRegister: u8 = eightBitLoadFromGBMemorySkipTraps(Joypad.memoryLocationJoypadRegister);\n    let shouldRequestInterrupt = false;\n\n    // Check if the game is looking for a dpad type button press\n    if(checkBitOnByte(4, joypadRegister) && isDpadTypeButton) {\n      shouldRequestInterrupt = true;\n    }\n\n    // Check if the game is looking for a button type button press\n    if(checkBitOnByte(5, joypadRegister) && !isDpadTypeButton) {\n      shouldRequestInterrupt = true;\n    }\n\n    // Finally, request the interrupt, if the button state actually changed\n    if (shouldRequestInterrupt) {\n      requestJoypadInterrupt();\n    }\n  }\n}\n\nfunction _releaseJoypadButton(buttonId: u8): void {\n  // Set our joypad state\n  _setJoypadButtonStateFromButtonId(buttonId, false);\n}\n\nfunction _getBitNumberForButtonId(buttonId: u8): u8 {\n  if (buttonId === 1 || buttonId === 4) {\n    return 0;\n  } else if (buttonId === 3 || buttonId === 5) {\n    return 1;\n  } else if (buttonId === 0 || buttonId === 6) {\n    return 2;\n  } else if (buttonId === 2 || buttonId === 7) {\n    return 3;\n  }\n\n  return 0;\n}\n\nfunction _getJoypadButtonStateFromButtonId(buttonId: u8): boolean {\n  if(buttonId === 0) {\n    return Joypad.up;\n  } else if (buttonId === 1) {\n    return Joypad.right;\n  } else if (buttonId === 2) {\n    return Joypad.down;\n  } else if (buttonId === 3) {\n    return Joypad.left;\n  } else if (buttonId === 4) {\n    return Joypad.a;\n  } else if (buttonId === 5) {\n    return Joypad.b;\n  } else if (buttonId === 6) {\n    return Joypad.select;\n  } else if (buttonId === 7) {\n    return Joypad.start;\n  }\n\n  return false;\n}\n\nfunction _setJoypadButtonStateFromButtonId(buttonId: u8, isPressed: boolean):  void {\n  if(buttonId === 0) {\n    Joypad.up = isPressed;\n  } else if (buttonId === 1) {\n    Joypad.right = isPressed;\n  } else if (buttonId === 2) {\n    Joypad.down = isPressed;\n  } else if (buttonId === 3) {\n    Joypad.left = isPressed;\n  } else if (buttonId === 4) {\n    Joypad.a = isPressed;\n  } else if (buttonId === 5) {\n    Joypad.b = isPressed;\n  } else if (buttonId === 6) {\n    Joypad.select = isPressed;\n  } else if (buttonId === 7) {\n    Joypad.start = isPressed;\n  }\n}\n","// NOTE: Tons of Copy-pasta btween channels, because Classes cannot be instantiated yet in assemblyscript\n\n// Square Channel with Frequency Sweep\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Square_Wave\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Frequency_Sweep\n\nimport {\n  eightBitLoadFromGBMemory,\n  eightBitStoreIntoGBMemory,\n  getSaveStateMemoryOffset,\n  loadBooleanDirectlyFromWasmMemory,\n  storeBooleanDirectlyToWasmMemory\n} from '../memory/index';\nimport {\n  getChannelStartingVolume,\n  isChannelDacEnabled\n} from './registers';\nimport {\n  getChannelFrequency,\n  setChannelFrequency\n} from './frequency';\nimport {\n  isChannelLengthEnabled\n} from './length';\nimport {\n  getChannelEnvelopePeriod,\n  getChannelEnvelopeAddMode\n} from './envelope';\nimport {\n  isDutyCycleClockPositiveOrNegativeForWaveform\n} from './duty';\nimport {\n  checkBitOnByte,\n  hexLog\n} from '../helpers/index';\n\nexport class Channel1 {\n\n  // Squarewave channel with volume envelope and frequency sweep functions.\n  // NR10 -> Sweep Register R/W\n  static memoryLocationNRx0: u16 = 0xFF10;\n  // NR11 -> Sound length/Wave pattern duty (R/W)\n  static memoryLocationNRx1: u16 = 0xFF11;\n  // NR12 -> Volume Envelope (R/W)\n  static memoryLocationNRx2: u16 = 0xFF12;\n  // NR13 -> Frequency lo (W)\n  static memoryLocationNRx3: u16 = 0xFF13;\n  // NR14 -> Frequency hi (R/W)\n  static memoryLocationNRx4: u16 = 0xFF14;\n\n  // Channel Properties\n  static channelNumber: i8 = 1;\n  static isEnabled: boolean = false;\n  static frequencyTimer: i32 = 0x00;\n  static envelopeCounter: i32 = 0x00;\n  static lengthCounter: i32 = 0x00;\n  static volume: i32 = 0x00;\n\n  // Square Wave properties\n  static dutyCycle: u8 = 0x00;\n  static waveFormPositionOnDuty: u8 = 0x00;\n\n  // Channel 1 Sweep\n  static sweepCounter: i32 = 0x00;\n  static sweepShadowFrequency: u16 = 0x00;\n\n  // Save States\n\n  static saveStateSlot: u16 = 7;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x00, Channel1.saveStateSlot), Channel1.isEnabled);\n    store<i32>(getSaveStateMemoryOffset(0x01, Channel1.saveStateSlot), Channel1.frequencyTimer);\n    store<i32>(getSaveStateMemoryOffset(0x05, Channel1.saveStateSlot), Channel1.envelopeCounter);\n    store<i32>(getSaveStateMemoryOffset(0x09, Channel1.saveStateSlot), Channel1.lengthCounter);\n    store<i32>(getSaveStateMemoryOffset(0x0E, Channel1.saveStateSlot), Channel1.volume);\n\n    store<u8>(getSaveStateMemoryOffset(0x13, Channel1.saveStateSlot), Channel1.dutyCycle);\n    store<u8>(getSaveStateMemoryOffset(0x14, Channel1.saveStateSlot), Channel1.waveFormPositionOnDuty);\n\n    store<i32>(getSaveStateMemoryOffset(0x19, Channel1.saveStateSlot), Channel1.sweepCounter);\n    store<u16>(getSaveStateMemoryOffset(0x1E, Channel1.saveStateSlot), Channel1.sweepShadowFrequency);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    Channel1.isEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x00, Channel1.saveStateSlot));\n    Channel1.frequencyTimer = load<i32>(getSaveStateMemoryOffset(0x01, Channel1.saveStateSlot));\n    Channel1.envelopeCounter = load<i32>(getSaveStateMemoryOffset(0x05, Channel1.saveStateSlot));\n    Channel1.lengthCounter = load<i32>(getSaveStateMemoryOffset(0x09, Channel1.saveStateSlot));\n    Channel1.volume = load<i32>(getSaveStateMemoryOffset(0x0E, Channel1.saveStateSlot));\n\n    Channel1.dutyCycle = load<u8>(getSaveStateMemoryOffset(0x13, Channel1.saveStateSlot));\n    Channel1.waveFormPositionOnDuty = load<u8>(getSaveStateMemoryOffset(0x14, Channel1.saveStateSlot));\n\n    Channel1.sweepCounter = load<i32>(getSaveStateMemoryOffset(0x19, Channel1.saveStateSlot));\n    Channel1.sweepShadowFrequency = load<u16>(getSaveStateMemoryOffset(0x1E, Channel1.saveStateSlot));\n  }\n\n\n  static initialize(): void {\n    eightBitStoreIntoGBMemory(Channel1.memoryLocationNRx0, 0x80);\n    eightBitStoreIntoGBMemory(Channel1.memoryLocationNRx1, 0xBF);\n    eightBitStoreIntoGBMemory(Channel1.memoryLocationNRx2, 0xF3);\n    eightBitStoreIntoGBMemory(Channel1.memoryLocationNRx3, 0xFF);\n    eightBitStoreIntoGBMemory(Channel1.memoryLocationNRx4, 0xBF);\n  }\n\n  static getSample(numberOfCycles: u8): u32 {\n\n    // Decrement our channel timer\n    Channel1.frequencyTimer -= <i32>numberOfCycles;\n    if(Channel1.frequencyTimer <= 0) {\n\n      // Get the amount that overflowed so we don't drop cycles\n      let overflowAmount: i32 = abs(Channel1.frequencyTimer);\n\n      // Reset our timer\n      // A square channel's frequency timer period is set to (2048-frequency)*4.\n      // Four duty cycles are available, each waveform taking 8 frequency timer clocks to cycle through:\n      Channel1.frequencyTimer = (2048 - getChannelFrequency(Channel1.channelNumber)) * 4;\n      Channel1.frequencyTimer -= overflowAmount;\n\n      // Also increment our duty cycle\n      // What is duty? https://en.wikipedia.org/wiki/Duty_cycle\n      // Duty cycle for square wave: http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Square_Wave\n      Channel1.waveFormPositionOnDuty += 1;\n      if (Channel1.waveFormPositionOnDuty >= 8) {\n        Channel1.waveFormPositionOnDuty = 0;\n      }\n    }\n\n    // Get our ourput volume, set to zero for silence\n    let outputVolume: i32 = 0;\n\n    // Finally to set our output volume, the channel must be enabled,\n    // Our channel DAC must be enabled, and we must be in an active state\n    // Of our duty cycle\n    if(Channel1.isEnabled &&\n    isChannelDacEnabled(Channel1.channelNumber)) {\n      outputVolume = Channel1.volume;\n    }\n\n    // Get the current sampleValue\n    let sample: i32 = 1;\n    if (!isDutyCycleClockPositiveOrNegativeForWaveform(1, Channel1.waveFormPositionOnDuty)) {\n      sample = sample * -1;\n    }\n\n\n    sample = sample * outputVolume;\n\n    // Square Waves Can range from -15 - 15. Therefore simply add 15\n    sample = sample + 15;\n    return <u32>sample;\n  }\n\n  //http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Trigger_Event\n  static trigger(): void {\n    Channel1.isEnabled = true;\n    if(Channel1.lengthCounter === 0) {\n      Channel1.lengthCounter = 64;\n    }\n\n    // Reset our timer\n    // A square channel's frequency timer period is set to (2048-frequency)*4.\n    // Four duty cycles are available, each waveform taking 8 frequency timer clocks to cycle through:\n    Channel1.frequencyTimer = (2048 - getChannelFrequency(Channel1.channelNumber)) * 4;\n\n    Channel1.envelopeCounter = getChannelEnvelopePeriod(Channel1.channelNumber);\n\n    Channel1.volume = getChannelStartingVolume(Channel1.channelNumber);\n\n    // Handle Channel Sweep\n    // Getting period and things here, as frequency sweep is specific to the channel 1 square wave\n    let sweepRegister: u8 = eightBitLoadFromGBMemory(Channel1.memoryLocationNRx0);\n    // Get bits 4-6\n    let sweepPeriod: u8 = sweepRegister & 0x70;\n    // Get bits 0-2\n    let sweepShift: u8 = sweepRegister & 0x07;\n\n    // Reset back to the sweep period\n    Channel1.sweepCounter = sweepPeriod;\n    Channel1.sweepShadowFrequency = getChannelFrequency(Channel1.channelNumber);\n\n    // If the sweep shift is non-zero, frequency calculation and the overflow check are performed immediately.\n    if(sweepShift > 0) {\n        calculateSweepAndCheckOverflow();\n    }\n\n    // Finally if DAC is off, channel is still disabled\n    if(!isChannelDacEnabled(Channel1.channelNumber)) {\n      Channel1.isEnabled = false;\n    }\n  }\n\n  static updateSweep(): void {\n    // Obscure behavior\n    // TODO: The volume envelope and sweep timers treat a period of 0 as 8.\n    // Decrement the sweep counter\n    Channel1.sweepCounter -= 1;\n\n    if (Channel1.sweepCounter <= 0) {\n\n      // Getting period and things here, as frequency sweep is specific to the channel 1 square wave\n      let sweepRegister: u8 = eightBitLoadFromGBMemory(Channel1.memoryLocationNRx0);\n      // Get bits 4-6\n      let sweepPeriod: u8 = sweepRegister & 0x70;\n\n      // Reset back to the sweep period\n      Channel1.sweepCounter = sweepPeriod;\n\n      // Calculate our sweep\n      calculateSweepAndCheckOverflow();\n    }\n  }\n\n  static updateLength(): void {\n\n    if(Channel1.lengthCounter > 0 && isChannelLengthEnabled(Channel1.channelNumber)) {\n      Channel1.lengthCounter -= 1;\n    }\n\n    if(Channel1.lengthCounter === 0) {\n      Channel1.isEnabled = false;\n    }\n  }\n\n  static updateEnvelope(): void {\n\n    // Obscure behavior\n    // TODO: The volume envelope and sweep timers treat a period of 0 as 8.\n\n    Channel1.envelopeCounter -= 1;\n    if (Channel1.envelopeCounter <= 0) {\n      Channel1.envelopeCounter = getChannelEnvelopePeriod(Channel1.channelNumber);\n\n      // When the timer generates a clock and the envelope period is NOT zero, a new volume is calculated\n      // NOTE: There is some weiirrdd obscure behavior where zero can equal 8, so watch out for that\n      // If notes are sustained for too long, this is probably why\n      if(Channel1.envelopeCounter !== 0) {\n        if(getChannelEnvelopeAddMode(Channel1.channelNumber) && Channel1.volume < 15) {\n          Channel1.volume += 1;\n        } else if (!getChannelEnvelopeAddMode(Channel1.channelNumber) && Channel1.volume > 0) {\n          Channel1.volume -= 1;\n        }\n      }\n    }\n  }\n  // Done!\n}\n\n\n// Sweep Specific functions\n\nfunction calculateSweepAndCheckOverflow(): void {\n  if(isSweepEnabled()) {\n\n    // Getting period and things here, as frequency sweep is specific to the channel 1 square wave\n    let sweepRegister: u8 = eightBitLoadFromGBMemory(Channel1.memoryLocationNRx0);\n    // Get bits 0-2\n    let sweepShift: u8 = sweepRegister & 0x07;\n\n    let newFrequency: u16 = getNewFrequencyFromSweep();\n    // 7FF is the highest value of the frequency: 111 1111 1111\n    if (newFrequency <= 0x7FF && sweepShift > 0) {\n      setChannelFrequency(Channel1.channelNumber, newFrequency);\n      // Re calculate the new frequency\n      newFrequency = getNewFrequencyFromSweep();\n    }\n\n    // Next check if the new Frequency is above 0x7FF\n    // if So, disable our sweep\n    if (newFrequency > 0x7FF) {\n      Channel1.isEnabled = false;\n    }\n  }\n}\n\n// The internal enabled flag is set if either the sweep period or shift\n// are non-zero, cleared otherwise.\nfunction isSweepEnabled(): boolean {\n  let sweepRegister: u8 = eightBitLoadFromGBMemory(Channel1.memoryLocationNRx0);\n  // Get bits 4-6\n  let sweepPeriod: u8 = sweepRegister & 0x70;\n  // Get bits 0-2\n  let sweepShift: u8 = sweepRegister & 0x07;\n\n  if ((sweepPeriod !== 0 || sweepShift !== 0) || getChannelFrequency(1) > 0x7FF) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Function to determing a new sweep in the current context\nfunction getNewFrequencyFromSweep(): u16 {\n\n  // Get our sweep register info\n  let sweepRegister: u8 = eightBitLoadFromGBMemory(Channel1.memoryLocationNRx0);\n  // Get bits 4-6\n  let sweepPeriod: u8 = sweepRegister & 0x70;\n  // Get bits 0-2\n  let sweepShift: u8 = sweepRegister & 0x07;\n\n  // Start our new frequency, by making it equal to the \"shadow frequency\"\n  let newFrequency: u16 = Channel1.sweepShadowFrequency;\n  newFrequency = (newFrequency >> sweepShift);\n\n  // Check for sweep negation\n  if (checkBitOnByte(3, sweepRegister)) {\n    newFrequency = Channel1.sweepShadowFrequency - newFrequency;\n  } else {\n    newFrequency = Channel1.sweepShadowFrequency + newFrequency;\n  }\n\n  return newFrequency;\n}\n","// Functions to update Length Counters on Channels\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Length_Counter\n\nimport {\n    Channel1\n} from './channel1';\nimport {\n    Channel2\n} from './channel2';\nimport {\n    Channel3\n} from './channel3';\nimport {\n    Channel4\n} from './channel4';\nimport {\n  getRegister1OfChannel,\n  getRegister4OfChannel\n} from './registers';\nimport {\n  checkBitOnByte,\n  hexLog\n} from '../helpers/index';\n\nexport function setChannelLengthCounter(channelNumber: i8): void {\n\n  let lengthLoad = getRegister1OfChannel(channelNumber);\n\n  // Clear the top 2 bits\n  lengthLoad = (lengthLoad & 0x3F);\n  // Channel length is determined by 64 (or 256 if channel 3), - the length load\n  // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Registers\n  let length: u8 = 64;\n  let result: u8 = 0;\n  if (channelNumber === 3) {\n    length = 255;\n    // Supposed to be 256, so subtracting 255 and then adding 1 if that makes sense\n    result = length - lengthLoad;\n    result += 1;\n  } else {\n    result = length - lengthLoad;\n  }\n\n  // Set the Channel Length Counter\n  if (channelNumber === Channel1.channelNumber) {\n    Channel1.lengthCounter = result;\n  } else if (channelNumber === Channel2.channelNumber) {\n    Channel2.lengthCounter = result;\n  } else if (channelNumber === Channel3.channelNumber) {\n    Channel3.lengthCounter = result;\n  } else if (channelNumber === Channel4.channelNumber) {\n    Channel4.lengthCounter = result;\n  }\n\n}\n\nexport function isChannelLengthEnabled(channelNumber: i8): boolean {\n  let soundRegister: u8 = getRegister4OfChannel(channelNumber);\n  return checkBitOnByte(6, soundRegister)\n}\n","// NOTE: Tons of Copy-pasta btween channels, because Classes cannot be instantiated yet in assemblyscript\n\n// Simple Square Channel\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Square_Wave\n\nimport {\n  eightBitLoadFromGBMemory,\n  eightBitStoreIntoGBMemory,\n  getSaveStateMemoryOffset,\n  loadBooleanDirectlyFromWasmMemory,\n  storeBooleanDirectlyToWasmMemory\n} from '../memory/index';\nimport {\n  getChannelStartingVolume,\n  isChannelDacEnabled,\n  getRegister2OfChannel\n} from './registers';\nimport {\n  getChannelFrequency,\n  setChannelFrequency\n} from './frequency';\nimport {\n  isChannelLengthEnabled\n} from './length';\nimport {\n  getChannelEnvelopePeriod,\n  getChannelEnvelopeAddMode\n} from './envelope';\nimport {\n  isDutyCycleClockPositiveOrNegativeForWaveform\n} from './duty';\nimport {\n  checkBitOnByte,\n  hexLog\n} from '../helpers/index';\n\nexport class Channel2 {\n\n  // Squarewave channel with volume envelope functions only.\n  // NR21 -> Sound length/Wave pattern duty (R/W)\n  static memoryLocationNRx1: u16 = 0xFF16;\n  // NR22 -> Volume Envelope (R/W)\n  static memoryLocationNRx2: u16 = 0xFF17;\n  // NR23 -> Frequency lo (W)\n  static memoryLocationNRx3: u16 = 0xFF18;\n  // NR24 -> Frequency hi (R/W)\n  static memoryLocationNRx4: u16 = 0xFF19;\n\n  // Channel Properties\n  static channelNumber: i8 = 2;\n  static isEnabled: boolean = false;\n  static frequencyTimer: i32 = 0x00;\n  static envelopeCounter: i32 = 0x00;\n  static lengthCounter: i32 = 0x00;\n  static volume: i32 = 0x00;\n\n  // Square Wave properties\n  static dutyCycle: u8 = 0x00;\n  static waveFormPositionOnDuty: u8 = 0x00;\n\n  // Save States\n\n  static saveStateSlot: u16 = 8;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x00, Channel2.saveStateSlot), Channel2.isEnabled);\n    store<i32>(getSaveStateMemoryOffset(0x01, Channel2.saveStateSlot), Channel2.frequencyTimer);\n    store<i32>(getSaveStateMemoryOffset(0x05, Channel2.saveStateSlot), Channel2.envelopeCounter);\n    store<i32>(getSaveStateMemoryOffset(0x09, Channel2.saveStateSlot), Channel2.lengthCounter);\n    store<i32>(getSaveStateMemoryOffset(0x0E, Channel2.saveStateSlot), Channel2.volume);\n\n    store<u8>(getSaveStateMemoryOffset(0x13, Channel2.saveStateSlot), Channel2.dutyCycle);\n    store<u8>(getSaveStateMemoryOffset(0x14, Channel2.saveStateSlot), Channel2.waveFormPositionOnDuty);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    Channel2.isEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x00, Channel2.saveStateSlot));\n    Channel2.frequencyTimer = load<i32>(getSaveStateMemoryOffset(0x01, Channel2.saveStateSlot));\n    Channel2.envelopeCounter = load<i32>(getSaveStateMemoryOffset(0x05, Channel2.saveStateSlot));\n    Channel2.lengthCounter = load<i32>(getSaveStateMemoryOffset(0x09, Channel2.saveStateSlot));\n    Channel2.volume = load<i32>(getSaveStateMemoryOffset(0x0E, Channel2.saveStateSlot));\n\n    Channel2.dutyCycle = load<u8>(getSaveStateMemoryOffset(0x13, Channel2.saveStateSlot));\n    Channel2.waveFormPositionOnDuty = load<u8>(getSaveStateMemoryOffset(0x14, Channel2.saveStateSlot));\n  }\n\n  static initialize(): void {\n    eightBitStoreIntoGBMemory(Channel2.memoryLocationNRx1 - 1, 0xFF);\n    eightBitStoreIntoGBMemory(Channel2.memoryLocationNRx1, 0x3F);\n    eightBitStoreIntoGBMemory(Channel2.memoryLocationNRx2, 0x00);\n    eightBitStoreIntoGBMemory(Channel2.memoryLocationNRx3, 0xF3);\n    eightBitStoreIntoGBMemory(Channel2.memoryLocationNRx4, 0xBF);\n  }\n\n  static getSample(numberOfCycles: u8): u32 {\n\n    // Decrement our channel timer\n    Channel2.frequencyTimer -= <i32>numberOfCycles;\n    if(Channel2.frequencyTimer <= 0) {\n\n      // Get the amount that overflowed so we don't drop cycles\n      let overflowAmount: i32 = abs(Channel2.frequencyTimer);\n\n      // Reset our timer\n      // A square channel's frequency timer period is set to (2048-frequency)*4.\n      // Four duty cycles are available, each waveform taking 8 frequency timer clocks to cycle through:\n      Channel2.frequencyTimer = (2048 - getChannelFrequency(Channel2.channelNumber)) * 4;\n      Channel2.frequencyTimer -= overflowAmount;\n\n      // Also increment our duty cycle\n      // What is duty? https://en.wikipedia.org/wiki/Duty_cycle\n      // Duty cycle for square wave: http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Square_Wave\n      Channel2.waveFormPositionOnDuty += 1;\n      if (Channel2.waveFormPositionOnDuty >= 8) {\n        Channel2.waveFormPositionOnDuty = 0;\n      }\n    }\n\n    // Get our ourput volume, set to zero for silence\n    let outputVolume: i32 = 0;\n\n    // Finally to set our output volume, the channel must be enabled,\n    // Our channel DAC must be enabled, and we must be in an active state\n    // Of our duty cycle\n    if(Channel2.isEnabled &&\n    isChannelDacEnabled(Channel2.channelNumber)) {\n      outputVolume = Channel2.volume;\n    }\n\n    // Get the current sampleValue\n    let sample: i32 = 1;\n    if (!isDutyCycleClockPositiveOrNegativeForWaveform(1, Channel2.waveFormPositionOnDuty)) {\n      sample = sample * -1;\n    }\n\n    sample = sample * outputVolume;\n\n    // Square Waves Can range from -15 - 15. Therefore simply add 15\n    sample = sample + 15;\n    return <u32>sample;\n  }\n\n  //http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Trigger_Event\n  static trigger(): void {\n    Channel2.isEnabled = true;\n    if(Channel2.lengthCounter === 0) {\n      Channel2.lengthCounter = 64;\n    }\n\n    // Reset our timer\n    // A square channel's frequency timer period is set to (2048-frequency)*4.\n    // Four duty cycles are available, each waveform taking 8 frequency timer clocks to cycle through:\n    Channel2.frequencyTimer = (2048 - getChannelFrequency(Channel2.channelNumber)) * 4;\n\n    Channel2.envelopeCounter = getChannelEnvelopePeriod(Channel2.channelNumber);\n\n    Channel2.volume = getChannelStartingVolume(Channel2.channelNumber);\n\n    // Finally if DAC is off, channel is still disabled\n    if(!isChannelDacEnabled(Channel2.channelNumber)) {\n      Channel2.isEnabled = false;\n    }\n  }\n\n  static updateLength(): void {\n    if(Channel2.lengthCounter > 0 && isChannelLengthEnabled(Channel2.channelNumber)) {\n      Channel2.lengthCounter -= 1;\n    }\n\n    if(Channel2.lengthCounter === 0) {\n      Channel2.isEnabled = false;\n    }\n  }\n\n  static updateEnvelope(): void {\n\n    // Obscure behavior\n    // TODO: The volume envelope and sweep timers treat a period of 0 as 8.\n\n    Channel2.envelopeCounter -= 1;\n    if (Channel2.envelopeCounter <= 0) {\n      Channel2.envelopeCounter = getChannelEnvelopePeriod(Channel2.channelNumber);\n\n      // When the timer generates a clock and the envelope period is NOT zero, a new volume is calculated\n      // NOTE: There is some weiirrdd obscure behavior where zero can equal 8, so watch out for that\n      if(Channel2.envelopeCounter !== 0) {\n        if(getChannelEnvelopeAddMode(Channel2.channelNumber) && Channel2.volume < 15) {\n          Channel2.volume += 1;\n        } else if (!getChannelEnvelopeAddMode(Channel2.channelNumber) && Channel2.volume > 0) {\n          Channel2.volume -= 1;\n        }\n      }\n    }\n  }\n  // Done!\n}\n","// NOTE: Tons of Copy-pasta btween channels, because Classes cannot be instantiated yet in assemblyscript\n\n// Wave Channel\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Wave_Channel\n\nimport {\n  eightBitLoadFromGBMemory,\n  eightBitStoreIntoGBMemory,\n  getSaveStateMemoryOffset,\n  loadBooleanDirectlyFromWasmMemory,\n  storeBooleanDirectlyToWasmMemory\n} from '../memory/index';\nimport {\n  getChannelStartingVolume,\n  isChannelDacEnabled,\n  getRegister2OfChannel\n} from './registers';\nimport {\n  getChannelFrequency,\n  setChannelFrequency\n} from './frequency';\nimport {\n  isChannelLengthEnabled\n} from './length';\nimport {\n  getChannelEnvelopePeriod,\n  getChannelEnvelopeAddMode\n} from './envelope';\nimport {\n  isDutyCycleClockPositiveOrNegativeForWaveform\n} from './duty';\nimport {\n  checkBitOnByte,\n  hexLog\n} from '../helpers/index';\n\nexport class Channel3 {\n\n  // Voluntary Wave channel with 32 4-bit programmable samples, played in sequence.\n  // NR30 -> Sound on/off (R/W)\n  static memoryLocationNRx0: u16 = 0xFF1A;\n  // NR31 -> Sound length (R/W)\n  static memoryLocationNRx1: u16 = 0xFF1B;\n  // NR32 -> Select ouput level (R/W)\n  static memoryLocationNRx2: u16 = 0xFF1C;\n  // NR33 -> Frequency lower data (W)\n  static memoryLocationNRx3: u16 = 0xFF1D;\n  // NR34 -> Frequency higher data (R/W)\n  static memoryLocationNRx4: u16 = 0xFF1E;\n\n  // Our wave table location\n  static memoryLocationWaveTable: u16 = 0xFF30;\n\n  // Channel Properties\n  static channelNumber: i8 = 3;\n  static isEnabled: boolean = false;\n  static frequencyTimer: i32 = 0x00;\n  static lengthCounter: i32 = 0x00;\n  static waveTablePosition: u16 = 0x00;\n\n  // Save States\n\n  static saveStateSlot: u16 = 9;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x00, Channel3.saveStateSlot), Channel3.isEnabled);\n    store<i32>(getSaveStateMemoryOffset(0x01, Channel3.saveStateSlot), Channel3.frequencyTimer);\n    store<i32>(getSaveStateMemoryOffset(0x05, Channel3.saveStateSlot), Channel3.lengthCounter);\n    store<u16>(getSaveStateMemoryOffset(0x09, Channel3.saveStateSlot), Channel3.waveTablePosition);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    Channel3.isEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x00, Channel3.saveStateSlot));\n    Channel3.frequencyTimer = load<i32>(getSaveStateMemoryOffset(0x01, Channel3.saveStateSlot));\n    Channel3.lengthCounter = load<i32>(getSaveStateMemoryOffset(0x05, Channel3.saveStateSlot));\n    Channel3.waveTablePosition = load<u16>(getSaveStateMemoryOffset(0x09, Channel3.saveStateSlot));\n  }\n\n  static initialize(): void {\n    eightBitStoreIntoGBMemory(Channel3.memoryLocationNRx0, 0x7F);\n    eightBitStoreIntoGBMemory(Channel3.memoryLocationNRx1, 0xFF);\n    eightBitStoreIntoGBMemory(Channel3.memoryLocationNRx2, 0x9F);\n    eightBitStoreIntoGBMemory(Channel3.memoryLocationNRx3, 0xBF);\n    eightBitStoreIntoGBMemory(Channel3.memoryLocationNRx4, 0xFF);\n  }\n\n  static getSample(numberOfCycles: u8): u32 {\n\n    // Decrement our channel timer\n    Channel3.frequencyTimer -= <i32>numberOfCycles;\n    if(Channel3.frequencyTimer <= 0) {\n\n      // Get the amount that overflowed so we don't drop cycles\n      let overflowAmount: i32 = abs(Channel3.frequencyTimer);\n\n      // Reset our timer\n      // A wave channel's frequency timer period is set to (2048-frequency) * 2.\n      // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Wave_Channel\n      Channel3.frequencyTimer = (2048 - getChannelFrequency(Channel3.channelNumber)) * 2;\n      Channel3.frequencyTimer -= overflowAmount;\n\n\n      // Advance the wave table position, and loop back if needed\n      Channel3.waveTablePosition += 1;\n      if(Channel3.waveTablePosition >= 32) {\n        Channel3.waveTablePosition = 0;\n      }\n    }\n\n    // Get the current sample\n    let sample: i16 = 0;\n\n    // Will Find the position, and knock off any remainder\n    let positionIndexToAdd: u16 = Channel3.waveTablePosition / 2;\n    let memoryLocationWaveSample: u16 = Channel3.memoryLocationWaveTable + positionIndexToAdd;\n\n    sample = <i16>eightBitLoadFromGBMemory(memoryLocationWaveSample);\n\n    // Need to grab the top or lower half for the correct sample\n    if (Channel3.waveTablePosition % 2 === 0) {\n      // First sample\n      sample = (sample >> 4);\n      sample = (sample & 0x0F);\n    } else {\n      // Second Samples\n      sample = (sample & 0x0F);\n    }\n\n    // Get our ourput volume, set to zero for silence\n    let outputVolume: i16 = 0;\n\n    // Finally to set our output volume, the channel must be enabled,\n    // Our channel DAC must be enabled, and we must be in an active state\n    // Of our duty cycle\n    if(Channel3.isEnabled &&\n    isChannelDacEnabled(Channel3.channelNumber)) {\n      // Get our volume code\n      let volumeCode = eightBitLoadFromGBMemory(Channel3.memoryLocationNRx2);\n      volumeCode = (volumeCode >> 5);\n      volumeCode = (volumeCode & 0x0F);\n\n      // Shift our sample and set our volume depending on the volume code\n      // Since we can't multiply by float, simply divide by 4, 2, 1\n      // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Wave_Channel\n      if(volumeCode <= 0) {\n        sample = (sample >> 4);\n      } else if (volumeCode === 1) {\n        // Dont Shift sample\n        outputVolume = 1;\n      } else if (volumeCode === 2) {\n        sample = (sample >> 1)\n        outputVolume = 2;\n      } else {\n        sample = (sample >> 2)\n        outputVolume = 4;\n      }\n    }\n\n    // Spply out output volume\n    if(outputVolume > 0) {\n      sample = sample / outputVolume;\n    } else {\n      sample = 0;\n    }\n\n    // Square Waves Can range from -15 - 15. Therefore simply add 15\n    sample = sample + 15;\n    return <u32>sample;\n  }\n\n  //http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Trigger_Event\n  static trigger(): void {\n    Channel3.isEnabled = true;\n    if(Channel3.lengthCounter === 0) {\n      Channel3.lengthCounter = 256;\n    }\n\n    // Reset our timer\n    // A wave channel's frequency timer period is set to (2048-frequency)*2.\n    Channel3.frequencyTimer = (2048 - getChannelFrequency(Channel3.channelNumber)) * 2;\n\n    // Reset our wave table position\n    Channel3.waveTablePosition = 0;\n\n    // Finally if DAC is off, channel is still disabled\n    if(!isChannelDacEnabled(Channel3.channelNumber)) {\n      Channel3.isEnabled = false;\n    }\n  }\n\n  static updateLength(): void {\n    if(Channel3.lengthCounter > 0 && isChannelLengthEnabled(Channel3.channelNumber)) {\n      Channel3.lengthCounter -= 1;\n    }\n\n    if(Channel3.lengthCounter === 0) {\n      Channel3.isEnabled = false;\n    }\n  }\n}\n","// NOTE: Tons of Copy-pasta btween channels, because Classes cannot be instantiated yet in assemblyscript\n\n// Noise Channel\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Noise_Channel\n\nimport {\n  eightBitLoadFromGBMemory,\n  eightBitStoreIntoGBMemory,\n  getSaveStateMemoryOffset,\n  loadBooleanDirectlyFromWasmMemory,\n  storeBooleanDirectlyToWasmMemory\n} from '../memory/index';\nimport {\n  getChannelStartingVolume,\n  isChannelDacEnabled,\n  getRegister2OfChannel\n} from './registers';\nimport {\n  getChannelFrequency,\n  setChannelFrequency\n} from './frequency';\nimport {\n  isChannelLengthEnabled\n} from './length';\nimport {\n  getChannelEnvelopePeriod,\n  getChannelEnvelopeAddMode\n} from './envelope';\nimport {\n  isDutyCycleClockPositiveOrNegativeForWaveform\n} from './duty';\nimport {\n  checkBitOnByte,\n  hexLog\n} from '../helpers/index';\n\nexport class Channel4 {\n\n  // Channel 4\n  // 'white noise' channel with volume envelope functions.\n  // NR41 -> Sound length (R/W)\n  static memoryLocationNRx1: u16 = 0xFF20;\n  // NR42 -> Volume Envelope (R/W)\n  static memoryLocationNRx2: u16 = 0xFF21;\n  // NR43 -> Polynomial Counter (R/W)\n  static memoryLocationNRx3: u16 = 0xFF22;\n  // NR43 -> Counter/consecutive; initial (R/W)\n  static memoryLocationNRx4: u16 = 0xFF23;\n\n  // Channel Properties\n  static channelNumber: i8 = 4;\n  static isEnabled: boolean = false;\n  static frequencyTimer: i32 = 0x00;\n  static envelopeCounter: i32 = 0x00;\n  static lengthCounter: i32 = 0x00;\n  static volume: i32 = 0x00;\n\n  // Noise properties\n  // NOTE: Is only 15 bits\n  static linearFeedbackShiftRegister: u16 = 0x00;\n\n  // Save States\n\n  static saveStateSlot: u16 = 10;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x00, Channel4.saveStateSlot), Channel4.isEnabled);\n    store<i32>(getSaveStateMemoryOffset(0x01, Channel4.saveStateSlot), Channel4.frequencyTimer);\n    store<i32>(getSaveStateMemoryOffset(0x05, Channel4.saveStateSlot), Channel4.envelopeCounter);\n    store<i32>(getSaveStateMemoryOffset(0x09, Channel4.saveStateSlot), Channel4.lengthCounter);\n    store<i32>(getSaveStateMemoryOffset(0x0E, Channel4.saveStateSlot), Channel4.volume);\n    store<u16>(getSaveStateMemoryOffset(0x13, Channel4.saveStateSlot), Channel4.linearFeedbackShiftRegister);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    Channel4.isEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x00, Channel4.saveStateSlot));\n    Channel4.frequencyTimer = load<i32>(getSaveStateMemoryOffset(0x01, Channel4.saveStateSlot));\n    Channel4.envelopeCounter = load<i32>(getSaveStateMemoryOffset(0x05, Channel4.saveStateSlot));\n    Channel4.lengthCounter = load<i32>(getSaveStateMemoryOffset(0x09, Channel4.saveStateSlot));\n    Channel4.volume = load<i32>(getSaveStateMemoryOffset(0x0E, Channel4.saveStateSlot));\n    Channel4.linearFeedbackShiftRegister = load<u16>(getSaveStateMemoryOffset(0x13, Channel4.saveStateSlot));\n  }\n\n  static initialize(): void {\n    eightBitStoreIntoGBMemory(Channel4.memoryLocationNRx1 - 1, 0xFF);\n    eightBitStoreIntoGBMemory(Channel4.memoryLocationNRx1, 0xFF);\n    eightBitStoreIntoGBMemory(Channel4.memoryLocationNRx2, 0x00);\n    eightBitStoreIntoGBMemory(Channel4.memoryLocationNRx3, 0x00);\n    eightBitStoreIntoGBMemory(Channel4.memoryLocationNRx4, 0xBF);\n  }\n\n  static getSample(numberOfCycles: u8): u32 {\n\n    // Decrement our channel timer\n    Channel4.frequencyTimer -= <i32>numberOfCycles;\n    if(Channel4.frequencyTimer <= 0) {\n\n      // Get the amount that overflowed so we don't drop cycles\n      let overflowAmount: i32 = abs(Channel4.frequencyTimer);\n\n      // Reset our timer\n      Channel4.frequencyTimer = Channel4.getNoiseChannelFrequencyPeriod();\n      Channel4.frequencyTimer -= overflowAmount;\n\n      // Declare our sample\n      let sample: i32 = 0;\n\n      // Do some cool stuff with lfsr\n      // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Noise_Channel\n\n      // First XOR bit zero and one\n      let lfsrBitZero: u16 = (Channel4.linearFeedbackShiftRegister & 0x01);\n      let lfsrBitOne: u16 = (Channel4.linearFeedbackShiftRegister >> 1);\n      lfsrBitOne = (lfsrBitOne & 0x01);\n      let xorLfsrBitZeroOne = lfsrBitZero ^ lfsrBitOne;\n\n      // Shift all lsfr bits by one\n      Channel4.linearFeedbackShiftRegister = Channel4.linearFeedbackShiftRegister >> 1;\n\n      // Place the XOR result on bit 15\n      Channel4.linearFeedbackShiftRegister = Channel4.linearFeedbackShiftRegister | (xorLfsrBitZeroOne << 14);\n\n      // If the width mode is set, set xor on bit 6, and make lfsr 7 bit\n      if(Channel4.isNoiseChannelWidthModeSet()) {\n        // Make 7 bit, by knocking off lower bits. Want to keeps bits 8 - 16, and then or on 7\n        Channel4.linearFeedbackShiftRegister = Channel4.linearFeedbackShiftRegister & (~0x40);\n        Channel4.linearFeedbackShiftRegister = Channel4.linearFeedbackShiftRegister | (xorLfsrBitZeroOne << 6);\n      }\n\n      // Wave form output is bit zero of lfsr, INVERTED\n      if (!checkBitOnByte(0, <u8>Channel4.linearFeedbackShiftRegister)) {\n        sample = 1;\n      } else {\n        sample = -1;\n      }\n\n      // Get our ourput volume, set to zero for silence\n      let outputVolume: i32 = 0;\n\n      // Finally to set our output volume, the channel must be enabled,\n      // Our channel DAC must be enabled, and we must be in an active state\n      // Of our duty cycle\n      if(Channel4.isEnabled &&\n      isChannelDacEnabled(Channel4.channelNumber)) {\n        outputVolume = Channel4.volume;\n      }\n\n      sample = sample * outputVolume;\n\n      // Noise Can range from -15 - 15. Therefore simply add 15\n      sample = sample + 15;\n      return <u32>sample;\n    } else {\n      // Return 15 and not zero because 15 is no sound :) see above\n      return 15;\n    }\n  }\n\n  //http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Trigger_Event\n  static trigger(): void {\n    Channel4.isEnabled = true;\n    if(Channel4.lengthCounter === 0) {\n      Channel4.lengthCounter = 64;\n    }\n\n    // Reset our timers\n    Channel4.frequencyTimer = Channel4.getNoiseChannelFrequencyPeriod();\n\n    Channel4.envelopeCounter = getChannelEnvelopePeriod(Channel4.channelNumber);\n\n    Channel4.volume = getChannelStartingVolume(Channel4.channelNumber);\n\n    // Noise channel's LFSR bits are all set to 1.\n    Channel4.linearFeedbackShiftRegister = 0x7FFF;\n\n    // Finally if DAC is off, channel is still disabled\n    if(!isChannelDacEnabled(Channel4.channelNumber)) {\n      Channel4.isEnabled = false;\n    }\n  }\n\n  static getNoiseChannelFrequencyPeriod(): u16 {\n    // Get our divisor from the divisor code\n    let divisor: u16 = Channel4.getNoiseChannelDivisorFromDivisorCode()\n    let clockShift: u8 = Channel4.getNoiseChannelClockShift();\n    return (divisor << clockShift);\n  }\n\n  static getNoiseChannelClockShift(): u8 {\n    let registerNRx3: u8 = eightBitLoadFromGBMemory(Channel4.memoryLocationNRx3);\n    // It is within the top 4 bits\n    let clockShift = (registerNRx3 >> 4);\n    return clockShift;\n  }\n\n  static isNoiseChannelWidthModeSet(): boolean {\n    let registerNRx3: u8 = eightBitLoadFromGBMemory(Channel4.memoryLocationNRx3);\n    return checkBitOnByte(3, registerNRx3);\n  }\n\n  static getNoiseChannelDivisorFromDivisorCode(): u8 {\n    // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Noise_Channel\n    // Get our divisor code\n    let registerNRx3: u8 = eightBitLoadFromGBMemory(Channel4.memoryLocationNRx3);\n    // Get the bottom 3 bits\n    let divisorCode: u8 = registerNRx3 & 0x07;\n    let divisor: u8 = 0;\n    if(divisorCode === 0) {\n      divisor = 8;\n    } else if (divisorCode === 1) {\n      divisor = 16;\n    } else if (divisorCode === 2) {\n      divisor = 32;\n    } else if (divisorCode === 3) {\n      divisor = 48;\n    } else if (divisorCode === 4) {\n      divisor = 64;\n    } else if (divisorCode === 5) {\n      divisor = 80;\n    } else if (divisorCode === 6) {\n      divisor = 96;\n    } else if (divisorCode === 7) {\n      divisor = 112;\n    }\n    return divisor;\n  }\n\n  static updateLength(): void {\n    if(Channel4.lengthCounter > 0 && isChannelLengthEnabled(Channel4.channelNumber)) {\n      Channel4.lengthCounter -= 1;\n    }\n\n    if(Channel4.lengthCounter === 0) {\n      Channel4.isEnabled = false;\n    }\n  }\n\n  static updateEnvelope(): void {\n\n    // Obscure behavior\n    // TODO: The volume envelope and sweep timers treat a period of 0 as 8.\n\n    Channel4.envelopeCounter -= 1;\n    if (Channel4.envelopeCounter <= 0) {\n      Channel4.envelopeCounter = getChannelEnvelopePeriod(Channel4.channelNumber);\n\n      // When the timer generates a clock and the envelope period is NOT zero, a new volume is calculated\n      // NOTE: There is some weiirrdd obscure behavior where zero can equal 8, so watch out for that\n      if(Channel4.envelopeCounter !== 0) {\n        if(getChannelEnvelopeAddMode(Channel4.channelNumber) && Channel4.volume < 15) {\n          Channel4.volume += 1;\n        } else if (!getChannelEnvelopeAddMode(Channel4.channelNumber) && Channel4.volume > 0) {\n          Channel4.volume -= 1;\n        }\n      }\n    }\n  }\n  // Done!\n}\n","// Functions to update frequency on channels\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Square_Wave\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Noise_Channel\n\nimport {\n  getRegister3OfChannel,\n  getRegister4OfChannel,\n  setRegister3OfChannel,\n  setRegister4OfChannel\n} from './registers';\nimport {\n  checkBitOnByte\n} from '../helpers/index';\n\nexport function getChannelFrequency(channelNumber: i8): u16 {\n  // Need to get the 3rd and 4th register.\n  // 3rd register is the bottom 8 bits.\n  // 4th register contains bits 9-11.\n  let frequencyHighBits: u16 = getRegister4OfChannel(channelNumber) & 0x07;\n  frequencyHighBits = (frequencyHighBits << 8);\n  let frequencyLowBits: u16 = getRegister3OfChannel(channelNumber);\n  let frequency = frequencyHighBits | frequencyLowBits;\n  return frequency;\n}\n\nexport function setChannelFrequency(channelNumber: i8, frequency: u16): void {\n  // Get the high and low bits\n  let passedFrequencyHighBits: u8 = <u8>(frequency >> 8);\n  let passedFrequencyLowBits: u8 = <u8>(frequency & 0xFF);\n\n  // Get the new register 4\n  let register4: u8 = getRegister4OfChannel(channelNumber);\n  // Knock off lower 3 bits, and Or on our high bits\n  let newRegister4: u8 = (register4 & 0xF8);\n  newRegister4 = newRegister4 | passedFrequencyHighBits;\n\n  // Finally set the registers\n  setRegister3OfChannel(channelNumber, passedFrequencyLowBits);\n  setRegister4OfChannel(channelNumber, newRegister4);\n}\n","// Functions to update envelopes on Channels\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Volume_Envelope\n\nimport {\n  getRegister2OfChannel\n} from './registers';\nimport {\n  checkBitOnByte\n} from '../helpers/index';\n\nexport function getChannelEnvelopePeriod(channelNumber: i8): u8 {\n  let soundRegister: u8 = getRegister2OfChannel(channelNumber);\n  // Get the bottom 3 bits for the period\n  let channelPeriod: u8 = soundRegister & 0x07;\n  return channelPeriod;\n}\n\nexport function getChannelEnvelopeAddMode(channelNumber: i8): boolean {\n  let soundRegister: u8 = getRegister2OfChannel(channelNumber);\n  return checkBitOnByte(3, soundRegister)\n}\n","// Imports\nimport {\n  Cpu,\n  relativeJump\n} from './index';\nimport {\n  handleCbOpcode\n} from './cbOpcodes';\nimport {\n  setZeroFlag,\n  getZeroFlag,\n  setSubtractFlag,\n  getSubtractFlag,\n  setHalfCarryFlag,\n  getHalfCarryFlag,\n  setCarryFlag,\n  getCarryFlag,\n  checkAndSetEightBitCarryFlag,\n  checkAndSetEightBitHalfCarryFlag,\n  checkAndSetSixteenBitFlagsAddOverflow\n} from './flags'\nimport {\n  addARegister,\n  addAThroughCarryRegister,\n  subARegister,\n  subAThroughCarryRegister,\n  andARegister,\n  xorARegister,\n  orARegister,\n  cpARegister\n} from './instructions';\nimport {\n  log,\n  hexLog,\n  rotateByteLeft,\n  rotateByteLeftThroughCarry,\n  rotateByteRight,\n  rotateByteRightThroughCarry,\n  concatenateBytes,\n  splitHighByte,\n  splitLowByte\n} from '../helpers/index';\nimport {\n  eightBitStoreIntoGBMemory,\n  sixteenBitStoreIntoGBMemory,\n  eightBitLoadFromGBMemory,\n  sixteenBitLoadFromGBMemory\n} from '../memory/index';\nimport {\n  updateTimers\n} from '../timers/index';\nimport {\n  setInterrupts,\n  checkInterrupts,\n  areInterruptsEnabled,\n  areInterruptsPending\n} from '../interrupts/index';\nimport {\n  updateGraphics\n} from '../graphics/index';\nimport {\n  updateSound\n} from '../sound/index'\n\n// Public funciton to run opcodes until a frame should be rendered.\nexport function update(): i8 {\n\n  let error: boolean = false;\n  let numberOfCycles: i8 = -1;\n  while(!error && Cpu.currentCycles < Cpu.MAX_CYCLES_PER_FRAME) {\n    numberOfCycles = emulationStep();\n    if (numberOfCycles >= 0) {\n      Cpu.currentCycles += numberOfCycles;\n    } else {\n      error = true;\n    }\n  }\n\n  // Reset our currentCycles\n  Cpu.currentCycles = 0;\n\n  if (error === true) {\n    Cpu.programCounter -= 1;\n    return -1;\n  } else {\n    // Reset our currentCycles\n    Cpu.currentCycles = 0;\n    return 1;\n  }\n}\n\n// Function to execute an opcode, and update other gameboy hardware.\n// http://www.codeslinger.co.uk/pages/projects/gameboy/beginning.html\nexport function emulationStep(): i8 {\n  // Get the opcode, and additional bytes to be handled\n  // Number of cycles defaults to 4, because while we're halted, we run 4 cycles (according to matt :))\n  let numberOfCycles: i8 = 4;\n  let opcode: u8 = 0;\n\n  // Cpu Halting best explained: https://www.reddit.com/r/EmuDev/comments/5ie3k7/infinite_loop_trying_to_pass_blarggs_interrupt/db7xnbe/\n  if(!Cpu.isHalted && !Cpu.isStopped) {\n    opcode = eightBitLoadFromGBMemory(Cpu.programCounter);\n    let dataByteOne: u8 = eightBitLoadFromGBMemory(Cpu.programCounter + 1);\n    let dataByteTwo: u8 = eightBitLoadFromGBMemory(Cpu.programCounter + 2);\n    numberOfCycles = executeOpcode(opcode, dataByteOne, dataByteTwo);\n    Cpu.previousOpcode = opcode;\n  } else {\n    // if we were halted, and interrupts were disabled but interrupts are pending, stop waiting\n    if(Cpu.isHalted && !areInterruptsEnabled() && areInterruptsPending()) {\n      Cpu.isHalted = false;\n      Cpu.isStopped = false;\n\n      // Need to run the next opcode twice, it's a bug menitoned in\n      // The reddit comment mentioned above, HOWEVER, TODO: This does not happen in GBC mode, see cpu manual\n      // CTRL+F \"low-power\" on gameboy cpu manual\n      // http://marc.rawer.de/Gameboy/Docs/GBCPUman.pdf\n      // E.g\n      // 0x76 - halt\n      // FA 34 12 - ld a,(1234)\n      // Becomes\n      // FA FA 34 ld a,(34FA)\n      // 12 ld (de),a\n      opcode = eightBitLoadFromGBMemory(Cpu.programCounter);\n      let dataByteOne: u8 = eightBitLoadFromGBMemory(Cpu.programCounter);\n      let dataByteTwo: u8 = eightBitLoadFromGBMemory(Cpu.programCounter + 1);\n      numberOfCycles = executeOpcode(opcode, dataByteOne, dataByteTwo);\n      Cpu.programCounter -= 1;\n    }\n  }\n\n  // blarggFixes, don't allow register F to have the bottom nibble\n  Cpu.registerF = Cpu.registerF & 0xF0;\n\n  // Check other Gameboy components\n  updateTimers(<u8>numberOfCycles);\n  if(!Cpu.isStopped) {\n    updateGraphics(<u8>numberOfCycles);\n  }\n  // Interrupt Handling requires 20 cycles\n  // https://github.com/Gekkio/mooneye-gb/blob/master/docs/accuracy.markdown#what-is-the-exact-timing-of-cpu-servicing-an-interrupt\n  numberOfCycles += checkInterrupts();\n  // Update Sound\n  updateSound(<u8>numberOfCycles);\n\n  if(numberOfCycles <= 0) {\n    log(\"Opcode at crash: $0\", 1, opcode);\n  }\n\n  return numberOfCycles;\n}\n\n// Private funciton to check if an opcode is a value\n// this is to get out of switch statements, and not have the dangling break; per javascript syntax\n// And allow repeated variable names, for when we are concatenating registers\nfunction isOpcode(opcode: u8, value: u8): boolean {\n  if(opcode === value) {\n    return true;\n  }\n  return false;\n}\n\n// Take in any opcode, and decode it, and return the number of cycles\n// Program counter can be gotten from getProgramCounter();\n// Setting return value to i32 instead of u16, as we want to return a negative number on error\n// https://rednex.github.io/rgbds/gbz80.7.html\n// http://pastraiser.com/cpu/gameboy/gameboyopcodes.html\nfunction executeOpcode(opcode: u8, dataByteOne: u8, dataByteTwo: u8): i8 {\n\n  // Initialize our number of cycles\n  // Return -1 if no opcode was found, representing an error\n  let numberOfCycles: i8 = -1;\n\n  // Always implement the program counter by one\n  // Any other value can just subtract or add however much offset before reaching this line\n  Cpu.programCounter += 1;\n\n  // Get our concatenated databyte one and dataByteTwo\n  // Doing this here, because for some odd reason, these are swapped ONLY\n  // When concatenated :p\n  // Find and replace with : concatenatedDataByte\n  let concatenatedDataByte: u16 = concatenateBytes(dataByteTwo, dataByteOne);\n\n  if(isOpcode(opcode, 0x00)) {\n\n    // NOP\n    // 1  4\n    // No Operation\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x01)) {\n\n    // LD BC,d16\n    // 3  12\n\n    Cpu.registerB = splitHighByte(concatenatedDataByte);\n    Cpu.registerC = splitLowByte(concatenatedDataByte);\n    Cpu.programCounter += 2;\n    numberOfCycles = 12;\n  } else if(isOpcode(opcode, 0x02)) {\n\n    // LD (BC),A\n    // 1  8\n    // () means load into address pointed by BC\n    let registerBC: u16 = concatenateBytes(Cpu.registerB, Cpu.registerC)\n    eightBitStoreIntoGBMemory(registerBC, Cpu.registerA);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x03)) {\n\n    // INC BC\n    // 1  8\n    let registerBC: u16 = concatenateBytes(Cpu.registerB, Cpu.registerC);\n    registerBC++;\n    Cpu.registerB = splitHighByte((<u16>registerBC));\n    Cpu.registerC = splitLowByte((<u16>registerBC));\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x04)) {\n\n    // INC B\n    // 1  4\n    // Z 0 H -\n    checkAndSetEightBitHalfCarryFlag(Cpu.registerB, 1);\n    Cpu.registerB += 1;\n    if (Cpu.registerB === 0) {\n      setZeroFlag(1);\n    } else {\n      setZeroFlag(0);\n    }\n    setSubtractFlag(0);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x05)) {\n\n    // DEC B\n    // 1  4\n    // Z 1 H -\n    checkAndSetEightBitHalfCarryFlag(Cpu.registerB, -1);\n    Cpu.registerB -= 1;\n    if (Cpu.registerB === 0) {\n      setZeroFlag(1);\n    } else {\n      setZeroFlag(0);\n    }\n    setSubtractFlag(1);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x06)) {\n\n    // LD B,d8\n    // 2  8\n    Cpu.registerB = dataByteOne;\n    Cpu.programCounter += 1;\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x07)) {\n\n    // RLCA\n    // 1  4\n    // 0 0 0 C\n    // Check for the carry\n    if((Cpu.registerA & 0x80) === 0x80) {\n      setCarryFlag(1);\n    } else {\n      setCarryFlag(0);\n    }\n    Cpu.registerA = rotateByteLeft(Cpu.registerA);\n    // Set all other flags to zero\n    setZeroFlag(0);\n    setSubtractFlag(0);\n    setHalfCarryFlag(0);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x08)) {\n\n    // LD (a16),SP\n    // 3  20\n    // Load the stack pointer into the 16 bit address represented by the two data bytes\n    sixteenBitStoreIntoGBMemory(concatenatedDataByte, Cpu.stackPointer);\n    Cpu.programCounter += 2;\n    numberOfCycles = 20;\n  } else if(isOpcode(opcode, 0x09)) {\n\n    // ADD HL,BC\n    // 1 8\n    // - 0 H C\n    let registerHL: u16 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n    let registerBC: u16 = concatenateBytes(Cpu.registerB, Cpu.registerC);\n    checkAndSetSixteenBitFlagsAddOverflow(<u16>registerHL, <u16>registerBC, false);\n    let result: u16 = <u16>(registerHL + registerBC);\n    Cpu.registerH = splitHighByte(<u16>result);\n    Cpu.registerL = splitLowByte(<u16>result);\n    setSubtractFlag(0);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x0A)) {\n\n    // LD A,(BC)\n    // 1 8\n    let registerBC: u16 = concatenateBytes(Cpu.registerB, Cpu.registerC)\n    Cpu.registerA = eightBitLoadFromGBMemory(registerBC);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x0B)) {\n\n    // DEC BC\n    // 1  8\n    let registerBC = concatenateBytes(Cpu.registerB, Cpu.registerC);\n    registerBC -= 1;\n    Cpu.registerB = splitHighByte(registerBC);\n    Cpu.registerC = splitLowByte(registerBC);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x0C)) {\n\n    // INC C\n    // 1  4\n    // Z 0 H -\n    checkAndSetEightBitHalfCarryFlag(Cpu.registerC, 1);\n    Cpu.registerC += 1;\n    if (Cpu.registerC === 0) {\n      setZeroFlag(1);\n    } else {\n      setZeroFlag(0);\n    }\n    setSubtractFlag(0);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x0D)) {\n\n    // DEC C\n    // 1  4\n    // Z 1 H -\n    checkAndSetEightBitHalfCarryFlag(Cpu.registerC, -1);\n    Cpu.registerC -= 1;\n    if (Cpu.registerC === 0) {\n      setZeroFlag(1);\n    } else {\n      setZeroFlag(0);\n    }\n    setSubtractFlag(1);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x0E)) {\n\n    // LD C,d8\n    // 2 8\n    Cpu.registerC = dataByteOne;\n    Cpu.programCounter += 1;\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x0F)) {\n\n    // RRCA\n    // 1 4\n    // 0 0 0 C\n    // Check for the last bit, to see if it will be carried\n    if ((Cpu.registerA & 0x01) > 0) {\n      setCarryFlag(1);\n    } else {\n      setCarryFlag(0);\n    }\n    Cpu.registerA = rotateByteRight(Cpu.registerA);\n    // Set all other flags to zero\n    setZeroFlag(0);\n    setSubtractFlag(0);\n    setHalfCarryFlag(0);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x10)) {\n\n    // STOP 0\n    // 2 4\n    // Enter CPU very low power mode. Also used to switch between double and normal speed CPU modes in GBC.\n    // Meaning Don't Decode anymore opcodes , or updated the LCD until joypad interrupt (or when button is pressed if I am wrong)\n    // See HALT\n    // TODO: This breaks Blarggs CPU tests, find out what should end a STOP\n    //Cpu.isStopped = true;\n    Cpu.programCounter += 1;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x11)) {\n\n    // LD DE,d16\n    // 3  12\n    Cpu.registerD = splitHighByte(concatenatedDataByte);\n    Cpu.registerE = splitLowByte(concatenatedDataByte);\n    Cpu.programCounter += 2;\n    numberOfCycles = 12;\n  } else if(isOpcode(opcode, 0x12)) {\n\n    // LD (DE),A\n    // 1 8\n    let registerDE: u16 = concatenateBytes(Cpu.registerD, Cpu.registerE);\n    eightBitStoreIntoGBMemory(registerDE, Cpu.registerA);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x13)) {\n\n    // INC DE\n    // 1 8\n    let registerDE = concatenateBytes(Cpu.registerD, Cpu.registerE);\n    registerDE += 1;\n    Cpu.registerD = splitHighByte(registerDE);\n    Cpu.registerE = splitLowByte(registerDE);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x14)) {\n\n    // INC D\n    // 1  4\n    // Z 0 H -\n    checkAndSetEightBitHalfCarryFlag(Cpu.registerD, 1);\n    Cpu.registerD += 1;\n    if (Cpu.registerD === 0) {\n      setZeroFlag(1);\n    } else {\n      setZeroFlag(0);\n    }\n    setSubtractFlag(0);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x15)) {\n\n    // DEC D\n    // 1  4\n    // Z 1 H -\n    checkAndSetEightBitHalfCarryFlag(Cpu.registerD, -1);\n    Cpu.registerD -= 1;\n    if (Cpu.registerD === 0) {\n      setZeroFlag(1);\n    } else {\n      setZeroFlag(0);\n    }\n    setSubtractFlag(1);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x16)) {\n    // LD D,d8\n    // 2 8\n    Cpu.registerD = dataByteOne;\n    Cpu.programCounter += 1;\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x17)) {\n    // RLA\n    // 1 4\n    // 0 0 0 C\n    // Check for the carry\n    // setting has first bit since we need to use carry\n    let hasHighbit = false;\n    if((Cpu.registerA & 0x80) === 0x80) {\n      hasHighbit = true;\n    }\n    Cpu.registerA = rotateByteLeftThroughCarry(Cpu.registerA);\n    // OR the carry flag to the end\n    if(hasHighbit) {\n      setCarryFlag(1);\n    } else {\n      setCarryFlag(0);\n    }\n    // Set all other flags to zero\n    setZeroFlag(0);\n    setSubtractFlag(0);\n    setHalfCarryFlag(0);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x18)) {\n\n    // JR r8\n    // 2  12\n    // NOTE: Discoved dataByte is signed\n    // However the relative Jump Function handles this\n\n    relativeJump(dataByteOne);\n    numberOfCycles = 12;\n    // Relative Jump Function Handles programcounter\n  } else if(isOpcode(opcode, 0x19)) {\n\n    // ADD HL,DE\n    // 1  8\n    // - 0 H C\n    let registerHL: u16 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n    let registerDE: u16 = concatenateBytes(Cpu.registerD, Cpu.registerE);\n    checkAndSetSixteenBitFlagsAddOverflow(<u16>registerHL, <u16>registerDE, false);\n    let result: u16 = <u16>(registerHL + registerDE);\n    Cpu.registerH = splitHighByte(<u16>result);\n    Cpu.registerL = splitLowByte(<u16>result);\n    setSubtractFlag(0);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x1A)) {\n\n    // LD A,(DE)\n    // 1 8\n    let registerDE: u16 = concatenateBytes(Cpu.registerD, Cpu.registerE);\n    Cpu.registerA = eightBitLoadFromGBMemory(registerDE);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x1B)) {\n\n    // DEC DE\n    // 1 8\n    let registerDE = concatenateBytes(Cpu.registerD, Cpu.registerE);\n    registerDE -= 1;\n    Cpu.registerD = splitHighByte(registerDE);\n    Cpu.registerE = splitLowByte(registerDE);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x1C)) {\n\n    // INC E\n    // 1  4\n    // Z 0 H -\n    checkAndSetEightBitHalfCarryFlag(Cpu.registerE, 1);\n    Cpu.registerE += 1;\n    if (Cpu.registerE === 0) {\n      setZeroFlag(1);\n    } else {\n      setZeroFlag(0);\n    }\n    setSubtractFlag(0);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x1D)) {\n\n    // DEC E\n    // 1  4\n    // Z 1 H -\n    checkAndSetEightBitHalfCarryFlag(Cpu.registerE, -1);\n    Cpu.registerE -= 1;\n    if (Cpu.registerE === 0) {\n      setZeroFlag(1);\n    } else {\n      setZeroFlag(0);\n    }\n    setSubtractFlag(1);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x1E)) {\n\n    // LD E,d8\n    // 2 8\n    Cpu.registerE = dataByteOne;\n    Cpu.programCounter += 1;\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x1F)) {\n\n    // RRA\n    // 1 4\n    // 0 0 0 C\n    // Check for the carry\n    // setting has low bit since we need to use carry\n    let hasLowBit = false;\n    if((Cpu.registerA & 0x01) === 0x01) {\n      hasLowBit = true;\n    }\n    Cpu.registerA = rotateByteRightThroughCarry(Cpu.registerA);\n\n    if(hasLowBit) {\n      setCarryFlag(1);\n    } else {\n      setCarryFlag(0);\n    }\n    // Set all other flags to zero\n    setZeroFlag(0);\n    setSubtractFlag(0);\n    setHalfCarryFlag(0);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x20)) {\n\n    // JR NZ,r8\n    // 2  12/8\n    // NOTE: NZ stands for not [flag], so in this case, not zero flag\n    // Also, / means, if condition. so if met, 12 cycles, otherwise 8 cycles\n    if (getZeroFlag() === 0) {\n      relativeJump(dataByteOne);\n      numberOfCycles = 12;\n      // Relative Jump Funciton handles program counter\n    } else {\n      numberOfCycles = 8;\n      Cpu.programCounter += 1;\n    }\n  } else if(isOpcode(opcode, 0x21)) {\n\n    // LD HL,d16\n    // 3  12\n    let sixeteenBitDataByte = concatenatedDataByte;\n    Cpu.registerH = splitHighByte(sixeteenBitDataByte);\n    Cpu.registerL = splitLowByte(sixeteenBitDataByte);\n    numberOfCycles = 12;\n    Cpu.programCounter += 2;\n  } else if(isOpcode(opcode, 0x22)) {\n\n    // LD (HL+),A\n    // 1 8\n    let registerHL = concatenateBytes(Cpu.registerH, Cpu.registerL);\n    eightBitStoreIntoGBMemory(registerHL, Cpu.registerA);\n    registerHL += 1;\n    Cpu.registerH = splitHighByte(registerHL);\n    Cpu.registerL = splitLowByte(registerHL);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x23)) {\n\n    // INC HL\n    // 1  8\n    let registerHL = concatenateBytes(Cpu.registerH, Cpu.registerL);\n    registerHL += 1;\n    Cpu.registerH = splitHighByte(registerHL);\n    Cpu.registerL = splitLowByte(registerHL);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x24)) {\n\n    // INC H\n    // 1  4\n    // Z 0 H -\n    checkAndSetEightBitHalfCarryFlag(Cpu.registerH, 1);\n    Cpu.registerH += 1;\n    if (Cpu.registerH === 0) {\n      setZeroFlag(1);\n    } else {\n      setZeroFlag(0);\n    }\n    setSubtractFlag(0);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x25)) {\n\n    // DEC H\n    // 1  4\n    // Z 1 H -\n    checkAndSetEightBitHalfCarryFlag(Cpu.registerH, -1);\n    Cpu.registerH -= 1;\n    if (Cpu.registerH === 0) {\n      setZeroFlag(1);\n    } else {\n      setZeroFlag(0);\n    }\n    setSubtractFlag(1);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x26)) {\n\n    // LD H,d8\n    // 2 8\n    Cpu.registerH = dataByteOne;\n    Cpu.programCounter += 1;\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x27)) {\n\n    // DAA\n    // 1 4\n    // Z - 0 C\n    let adjustedRegister: u8 = 0;\n    let adjustment: u8 = 0;\n\n    if(getHalfCarryFlag() > 0) {\n      adjustment = adjustment | 0x06;\n    }\n    if(getCarryFlag() > 0) {\n      adjustment = adjustment | 0x60;\n    }\n\n    if(getSubtractFlag() > 0) {\n      adjustedRegister = Cpu.registerA - <u8>adjustment;\n    } else {\n      if ((Cpu.registerA & 0x0F) > 0x09) {\n        adjustment = adjustment | 0x06;\n      }\n      if(Cpu.registerA > 0x99) {\n        adjustment = adjustment | 0x60;\n      }\n      adjustedRegister = Cpu.registerA + <u8>adjustment;\n    }\n\n    // Now set our flags to the correct values\n    if(adjustedRegister === 0) {\n      setZeroFlag(1);\n    } else {\n      setZeroFlag(0);\n    }\n    if( (adjustment & 0x60) !== 0) {\n      setCarryFlag(1);\n    } else {\n      setCarryFlag(0);\n    }\n    setHalfCarryFlag(0);\n\n    Cpu.registerA = <u8>adjustedRegister;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x28)) {\n\n    // JR Z,r8\n    // 2  12/8\n    if(getZeroFlag() > 0) {\n      relativeJump(dataByteOne);\n      numberOfCycles = 12;\n      // Relative Jump funciton handles pogram counter\n    } else {\n      numberOfCycles = 8;\n      Cpu.programCounter += 1;\n    }\n  } else if(isOpcode(opcode, 0x29)) {\n\n    // ADD HL,HL\n    // 1  8\n    // - 0 H C\n    let registerHL = concatenateBytes(Cpu.registerH, Cpu.registerL);\n    checkAndSetSixteenBitFlagsAddOverflow(registerHL, registerHL, false);\n    registerHL = registerHL * 2;\n    Cpu.registerH = splitHighByte(registerHL);\n    Cpu.registerL = splitLowByte(registerHL);\n    setSubtractFlag(0);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x2A)) {\n\n    // LD A,(HL+)\n    // 1  8\n    let registerHL = concatenateBytes(Cpu.registerH, Cpu.registerL);\n    Cpu.registerA = eightBitLoadFromGBMemory(registerHL);\n    registerHL += 1;\n    Cpu.registerH = splitHighByte(registerHL);\n    Cpu.registerL = splitLowByte(registerHL);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x2B)) {\n\n    // DEC HL\n    // 1 8\n    let registerHL = concatenateBytes(Cpu.registerH, Cpu.registerL);\n    registerHL -= 1;\n    Cpu.registerH = splitHighByte(registerHL);\n    Cpu.registerL = splitLowByte(registerHL);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x2C)) {\n\n    // INC L\n    // 1  4\n    // Z 0 H -\n    checkAndSetEightBitHalfCarryFlag(Cpu.registerL, 1);\n    Cpu.registerL += 1;\n    if (Cpu.registerL === 0) {\n      setZeroFlag(1);\n    } else {\n      setZeroFlag(0);\n    }\n    setSubtractFlag(0);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x2D)) {\n\n    // DEC L\n    // 1  4\n    // Z 1 H -\n    checkAndSetEightBitHalfCarryFlag(Cpu.registerL, -1);\n    Cpu.registerL -= 1;\n    if (Cpu.registerL === 0) {\n      setZeroFlag(1);\n    } else {\n      setZeroFlag(0);\n    }\n    setSubtractFlag(1);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x2E)) {\n    // LD L,d8\n    // 2  8\n    Cpu.registerL = dataByteOne;\n    numberOfCycles = 8;\n    Cpu.programCounter += 1;\n  } else if(isOpcode(opcode, 0x2F)) {\n\n    // CPL\n    // 1 4\n    // - 1 1 -\n    Cpu.registerA = ~Cpu.registerA;\n    setSubtractFlag(1);\n    setHalfCarryFlag(1);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x30)) {\n\n    // JR NC,r8\n    // 2 12 / 8\n    if (getCarryFlag() === 0) {\n      relativeJump(dataByteOne);\n      numberOfCycles = 12;\n      // Relative Jump function handles program counter\n    } else {\n      numberOfCycles = 8;\n      Cpu.programCounter += 1;\n    }\n  } else if(isOpcode(opcode, 0x31)) {\n    // LD SP,d16\n    // 3 12\n    Cpu.stackPointer = concatenatedDataByte;\n    Cpu.programCounter += 2;\n    numberOfCycles = 12;\n  } else if(isOpcode(opcode, 0x32)) {\n    // LD (HL-),A\n    // 1 8\n    let registerHL = concatenateBytes(Cpu.registerH, Cpu.registerL);\n    eightBitStoreIntoGBMemory(registerHL, Cpu.registerA);\n    registerHL -= 1;\n    Cpu.registerH = splitHighByte(registerHL);\n    Cpu.registerL = splitLowByte(registerHL);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x33)) {\n    // INC SP\n    // 1 8\n    Cpu.stackPointer += 1;\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x34)) {\n\n    // INC (HL)\n    // 1  12\n    // Z 0 H -\n    let registerHL: u16 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n    let valueAtHL: u8 = <u8>eightBitLoadFromGBMemory(registerHL);\n    // Creating a varible for this to fix assemblyscript overflow bug\n    // Requires explicit casting\n    // https://github.com/AssemblyScript/assemblyscript/issues/26\n    let incrementer: u8 = 1;\n    checkAndSetEightBitHalfCarryFlag(<u8>valueAtHL, <i16>incrementer);\n    valueAtHL = <u8>valueAtHL + <u8>incrementer;\n\n    if (valueAtHL === 0) {\n      setZeroFlag(1);\n    } else {\n      setZeroFlag(0);\n    }\n    setSubtractFlag(0);\n    eightBitStoreIntoGBMemory(registerHL, <u8>valueAtHL);\n    numberOfCycles = 12;\n  } else if(isOpcode(opcode, 0x35)) {\n\n    // DEC (HL)\n    // 1  12\n    // Z 1 H -\n    let registerHL: u16 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n    let valueAtHL: u8 = eightBitLoadFromGBMemory(registerHL);\n    // NOTE: This opcode may not overflow correctly,\n    // Please see previous opcode\n    checkAndSetEightBitHalfCarryFlag(<u8>valueAtHL, -1);\n    valueAtHL -= <u8>1;\n    if (valueAtHL === 0) {\n      setZeroFlag(1);\n    } else {\n      setZeroFlag(0);\n    }\n    setSubtractFlag(1);\n    eightBitStoreIntoGBMemory(registerHL, <u8>valueAtHL);\n    numberOfCycles = 12;\n  } else if(isOpcode(opcode, 0x36)) {\n    // LD (HL),d8\n    // 2  12\n    eightBitStoreIntoGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL), dataByteOne);\n    Cpu.programCounter += 1;\n    numberOfCycles = 12;\n  } else if(isOpcode(opcode, 0x37)) {\n    // SCF\n    // 1  4\n    // - 0 0 1\n    // Simply set the carry flag\n    setSubtractFlag(0);\n    setHalfCarryFlag(0);\n    setCarryFlag(1);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x38)) {\n\n    // JR C,r8\n    // 2 12/8\n    if (getCarryFlag() === 1) {\n      relativeJump(dataByteOne);\n      numberOfCycles = 12;\n      // Relative Jump Funciton handles program counter\n    } else {\n      numberOfCycles = 8;\n      Cpu.programCounter += 1;\n    }\n  } else if(isOpcode(opcode, 0x39)) {\n\n    // ADD HL,SP\n    // 1 8\n    // - 0 H C\n    let registerHL: u16 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n    checkAndSetSixteenBitFlagsAddOverflow(<u16>registerHL, Cpu.stackPointer, false);\n    let result: u16 = <u16>(registerHL + Cpu.stackPointer);\n    Cpu.registerH = splitHighByte(<u16>result);\n    Cpu.registerL = splitLowByte(<u16>result);\n    setSubtractFlag(0);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x3A)) {\n\n    // LD A,(HL-)\n    // 1 8\n    let registerHL: u16 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n    Cpu.registerA = eightBitLoadFromGBMemory(registerHL);\n    registerHL -= 1;\n    Cpu.registerH = splitHighByte(registerHL);\n    Cpu.registerL = splitLowByte(registerHL);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x3B)) {\n    // DEC SP\n    // 1 8\n    Cpu.stackPointer -= 1;\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x3C)) {\n\n    // INC A\n    // 1  4\n    // Z 0 H -\n    checkAndSetEightBitHalfCarryFlag(Cpu.registerA, 1);\n    Cpu.registerA += 1;\n    if (Cpu.registerA === 0) {\n      setZeroFlag(1);\n    } else {\n      setZeroFlag(0);\n    }\n    setSubtractFlag(0);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x3D)) {\n\n    // DEC A\n    // 1  4\n    // Z 1 H -\n    checkAndSetEightBitHalfCarryFlag(Cpu.registerA, -1);\n    Cpu.registerA -= 1;\n    if (Cpu.registerA === 0) {\n      setZeroFlag(1);\n    } else {\n      setZeroFlag(0);\n    }\n    setSubtractFlag(1);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x3E)) {\n\n    // LD A,d8\n    // 2 8\n    Cpu.registerA = dataByteOne;\n    Cpu.programCounter += 1;\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x3F)) {\n\n    // CCF\n    // 1 4\n    // - 0 0 C\n    setSubtractFlag(0);\n    setHalfCarryFlag(0);\n    if(getCarryFlag() > 0) {\n      setCarryFlag(0);\n    } else {\n      setCarryFlag(1);\n    }\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x40)) {\n    // LD B,B\n    // 1 4\n    // Load B into B, Do nothing\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x41)) {\n\n    // LD B,C\n    // 1 4\n    Cpu.registerB = Cpu.registerC;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x42)) {\n\n    // LD B,D\n    // 1 4\n    Cpu.registerB = Cpu.registerD;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x43)) {\n\n    // LD B,E\n    // 1 4\n    Cpu.registerB = Cpu.registerE;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x44)) {\n\n    // LD B,H\n    // 1 4\n    Cpu.registerB = Cpu.registerH;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x45)) {\n\n    // LD B,L\n    // 1 4\n    Cpu.registerB = Cpu.registerL;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x46)) {\n\n    // LD B,(HL)\n    // 1 8\n    Cpu.registerB = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x47)) {\n\n    // LD B,A\n    // 1 4\n    Cpu.registerB = Cpu.registerA;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x48)) {\n\n    // LD C,B\n    // 1 4\n    Cpu.registerC = Cpu.registerB;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x49)) {\n\n    // LD C,C\n    // 1 4\n    // Do nothing\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x4A)) {\n\n    // LD C,D\n    // 1 4\n    Cpu.registerC = Cpu.registerD;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x4B)) {\n\n    // LD C,E\n    // 1 4\n    Cpu.registerC = Cpu.registerE;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x4C)) {\n\n    // LD C,H\n    // 1 4\n    Cpu.registerC = Cpu.registerH;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x4D)) {\n\n    // LD C,L\n    // 1 4\n    Cpu.registerC = Cpu.registerL;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x4E)) {\n\n    // LD C,(HL)\n    // 1 8\n    Cpu.registerC = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x4F)) {\n\n    // LD C,A\n    // 1 4\n    Cpu.registerC = Cpu.registerA;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x50)) {\n\n    // LD D,B\n    // 1 4\n    Cpu.registerD = Cpu.registerB;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x51)) {\n\n    // LD D,C\n    // 1 4\n    Cpu.registerD = Cpu.registerC;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x52)) {\n\n    // LD D,D\n    // 1 4\n    // Do Nothing\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x53)) {\n\n    // LD D,E\n    // 1 4\n    Cpu.registerD = Cpu.registerE;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x54)) {\n\n    // LD D,H\n    // 1 4\n    Cpu.registerD = Cpu.registerH;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x55)) {\n\n    // LD D,L\n    // 1 4\n    Cpu.registerD = Cpu.registerL;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x56)) {\n\n    // LD D,(HL)\n    // 1 8\n    Cpu.registerD = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x57)) {\n\n    // LD D,A\n    // 1 4\n    Cpu.registerD = Cpu.registerA;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x58)) {\n\n    // LD E,B\n    // 1 4\n    Cpu.registerE = Cpu.registerB;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x59)) {\n\n    // LD E,C\n    // 1 4\n    Cpu.registerE = Cpu.registerC;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x5A)) {\n\n    // LD E,D\n    // 1 4\n    Cpu.registerE = Cpu.registerD;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x5B)) {\n\n    // LD E,E\n    // 1 4\n    // Do Nothing\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x5C)) {\n\n    // LD E,H\n    // 1 4\n    Cpu.registerE = Cpu.registerH;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x5D)) {\n\n    // LD E,L\n    // 1 4\n    Cpu.registerE = Cpu.registerL;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x5E)) {\n\n    // LD E,(HL)\n    // 1 4\n    Cpu.registerE = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x5F)) {\n\n    // LD E,A\n    // 1 4\n    Cpu.registerE = Cpu.registerA;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x60)) {\n\n    // LD H,B\n    // 1 4\n    Cpu.registerH = Cpu.registerB;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x61)) {\n\n    // LD H,C\n    // 1 4\n    Cpu.registerH = Cpu.registerC;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x62)) {\n\n    // LD H,D\n    // 1 4\n    Cpu.registerH = Cpu.registerD;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x63)) {\n\n    // LD H,E\n    // 1 4\n    Cpu.registerH = Cpu.registerE;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x64)) {\n\n    // LD H,H\n    // 1 4\n    Cpu.registerH = Cpu.registerH;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x65)) {\n\n    // LD H,L\n    // 1 4\n    Cpu.registerH = Cpu.registerL;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x66)) {\n\n    // LD H,(HL)\n    // 1 8\n    Cpu.registerH = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x67)) {\n\n    // LD H,A\n    // 1 4\n    Cpu.registerH = Cpu.registerA;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x68)) {\n\n    // LD L,B\n    // 1 4\n    Cpu.registerL = Cpu.registerB;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x69)) {\n\n    // LD L,C\n    // 1 4\n    Cpu.registerL = Cpu.registerC;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x6A)) {\n\n    // LD L,D\n    // 1 4\n    Cpu.registerL = Cpu.registerD;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x6B)) {\n\n    // LD L,E\n    // 1 4\n    Cpu.registerL = Cpu.registerE;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x6C)) {\n\n    // LD L,H\n    // 1 4\n    Cpu.registerL = Cpu.registerH;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x6D)) {\n\n    // LD L,L\n    // 1 4\n    Cpu.registerL = Cpu.registerL;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x6E)) {\n\n    // LD L,(HL)\n    // 1 8\n    Cpu.registerL = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x6F)) {\n\n    // LD L,A\n    // 1 4\n    Cpu.registerL = Cpu.registerA;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x70)) {\n\n    // LD (HL),B\n    // 1 8\n    eightBitStoreIntoGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerB);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x71)) {\n\n    // LD (HL),C\n    // 1 8\n    eightBitStoreIntoGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerC);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x72)) {\n\n    // LD (HL),D\n    // 1 8\n    eightBitStoreIntoGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerD);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x73)) {\n\n    // LD (HL),E\n    // 1 8\n    eightBitStoreIntoGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerE);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x74)) {\n\n    // LD (HL),H\n    // 1 8\n    eightBitStoreIntoGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerH);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x75)) {\n\n    // LD (HL),L\n    // 1 8\n    eightBitStoreIntoGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerL);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x76)) {\n\n    // HALT\n    // 1 4\n    // Enter CPU very low power mode\n    // Meaning Don't Decode anymore opcodes until an interrupt occurs\n    // Still need to do timers and things\n    Cpu.isHalted = true;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x77)) {\n\n    // LD (HL),A\n    // 1 8\n    eightBitStoreIntoGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerA);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x78)) {\n\n    // LD A,B\n    // 1 4\n    Cpu.registerA = Cpu.registerB;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x79)) {\n\n    // LD A,C\n    // 1 4\n    Cpu.registerA = Cpu.registerC;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x7A)) {\n\n    // LD A,D\n    // 1 4\n    Cpu.registerA = Cpu.registerD;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x7B)) {\n\n    // LD A,E\n    // 1 4\n    Cpu.registerA = Cpu.registerE;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x7C)) {\n\n    // LD A,H\n    // 1 4\n    Cpu.registerA = Cpu.registerH;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x7D)) {\n\n    // LD A,L\n    // 1 4\n    Cpu.registerA = Cpu.registerL;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x7E)) {\n\n    // LD A,(HL)\n    // 1 4\n    Cpu.registerA = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x7F)) {\n\n    // LD A,A\n    // 1 4\n    // Do Nothing\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x80)) {\n    // ADD A,B\n    // 1 4\n    // Z 0 H C\n    addARegister(Cpu.registerB);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x81)) {\n    // ADD A,C\n    // 1 4\n    // Z 0 H C\n    addARegister(Cpu.registerC);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x82)) {\n    // ADD A,D\n    // 1 4\n    // Z 0 H C\n    addARegister(Cpu.registerD);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x83)) {\n    // ADD A,E\n    // 1 4\n    // Z 0 H C\n    addARegister(Cpu.registerE);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x84)) {\n    // ADD A,H\n    // 1 4\n    // Z 0 H C\n    addARegister(Cpu.registerH);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x85)) {\n    // ADD A,L\n    // 1 4\n    // Z 0 H C\n    addARegister(Cpu.registerL);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x86)) {\n    // ADD A,(HL)\n    // 1 8\n    // Z 0 H C\n    let valueAtHL: u8 = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n    addARegister(<u8>valueAtHL);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x87)) {\n    // ADD A,A\n    // 1 4\n    // Z 0 H C\n    addARegister(Cpu.registerA);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x88)) {\n    // ADC A,B\n    // 1 4\n    // Z 0 H C\n    addAThroughCarryRegister(Cpu.registerB);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x89)) {\n    // ADC A,C\n    // 1 4\n    // Z 0 H C\n    addAThroughCarryRegister(Cpu.registerC);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x8A)) {\n    // ADC A,D\n    // 1 4\n    // Z 0 H C\n    addAThroughCarryRegister(Cpu.registerD);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x8B)) {\n    // ADC A,E\n    // 1 4\n    // Z 0 H C\n    addAThroughCarryRegister(Cpu.registerE);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x8C)) {\n    // ADC A,H\n    // 1 4\n    // Z 0 H C\n    addAThroughCarryRegister(Cpu.registerH);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x8D)) {\n    // ADC A,L\n    // 1 4\n    // Z 0 H C\n    addAThroughCarryRegister(Cpu.registerL);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x8E)) {\n    // ADC A,(HL)\n    // 1 8\n    // Z 0 H C\n    let valueAtHL: u8 = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n    addAThroughCarryRegister(<u8>valueAtHL);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x8F)) {\n    // ADC A,A\n    // 1 4\n    // Z 0 H C\n    addAThroughCarryRegister(Cpu.registerA);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x90)) {\n\n    // SUB B\n    // 1  4\n    // Z 1 H C\n    subARegister(Cpu.registerB);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x91)) {\n\n    // SUB C\n    // 1  4\n    // Z 1 H C\n    subARegister(Cpu.registerC);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x92)) {\n\n    // SUB D\n    // 1  4\n    // Z 1 H C\n    subARegister(Cpu.registerD);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x93)) {\n\n    // SUB E\n    // 1  4\n    // Z 1 H C\n    subARegister(Cpu.registerE);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x94)) {\n\n    // SUB H\n    // 1  4\n    // Z 1 H C\n    subARegister(Cpu.registerH);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x95)) {\n\n    // SUB L\n    // 1  4\n    // Z 1 H C\n    subARegister(Cpu.registerL);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x96)) {\n\n    // SUB (HL)\n    // 1  8\n    // Z 1 H C\n    let valueAtHL: u8 = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n    subARegister(<u8>valueAtHL);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x97)) {\n\n    // SUB A\n    // 1  4\n    // Z 1 H C\n    subARegister(Cpu.registerA);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x98)) {\n\n    // SBC A,B\n    // 1  4\n    // Z 1 H C\n    subAThroughCarryRegister(Cpu.registerB);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x99)) {\n\n    // SBC A,C\n    // 1  4\n    // Z 1 H C\n    subAThroughCarryRegister(Cpu.registerC);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x9A)) {\n\n    // SBC A,D\n    // 1  4\n    // Z 1 H C\n    subAThroughCarryRegister(Cpu.registerD);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x9B)) {\n\n    // SBC A,E\n    // 1  4\n    // Z 1 H C\n    subAThroughCarryRegister(Cpu.registerE);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x9C)) {\n\n    // SBC A,H\n    // 1  4\n    // Z 1 H C\n    subAThroughCarryRegister(Cpu.registerH);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x9D)) {\n\n    // SBC A,L\n    // 1  4\n    // Z 1 H C\n    subAThroughCarryRegister(Cpu.registerL);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0x9E)) {\n\n    // SBC A,(HL)\n    // 1  8\n    // Z 1 H C\n    let valueAtHL: u8 = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n    subAThroughCarryRegister(<u8>valueAtHL);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0x9F)) {\n\n    // SBC A,A\n    // 1  4\n    // Z 1 H C\n    subAThroughCarryRegister(Cpu.registerA);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xA0)) {\n\n    // AND B\n    // 1  4\n    // Z 0 1 0\n    andARegister(Cpu.registerB);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xA1)) {\n\n    // AND C\n    // 1  4\n    // Z 0 1 0\n    andARegister(Cpu.registerC);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xA2)) {\n\n    // AND D\n    // 1  4\n    // Z 0 1 0\n    andARegister(Cpu.registerD);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xA3)) {\n\n    // AND E\n    // 1  4\n    // Z 0 1 0\n    andARegister(Cpu.registerE);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xA4)) {\n\n    // AND H\n    // 1  4\n    // Z 0 1 0\n    andARegister(Cpu.registerH);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xA5)) {\n\n    // AND L\n    // 1  4\n    // Z 0 1 0\n    andARegister(Cpu.registerL);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xA6)) {\n\n    // AND (HL)\n    // 1  8\n    // Z 0 1 0\n    let valueAtHL: u8 = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n    andARegister(<u8>valueAtHL);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0xA7)) {\n\n    // AND A\n    // 1  4\n    // Z 0 1 0\n    // NOTE: & Yourself, does nothing\n    andARegister(Cpu.registerA);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xA8)) {\n\n    // XOR B\n    // 1  4\n    // Z 0 0 0\n    xorARegister(Cpu.registerB);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xA9)) {\n\n    // XOR C\n    // 1  4\n    // Z 0 0 0\n    xorARegister(Cpu.registerC);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xAA)) {\n\n    // XOR D\n    // 1  4\n    // Z 0 0 0\n    xorARegister(Cpu.registerD);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xAB)) {\n\n    // XOR E\n    // 1  4\n    // Z 0 0 0\n    xorARegister(Cpu.registerE);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xAC)) {\n\n    // XOR H\n    // 1  4\n    // Z 0 0 0\n    xorARegister(Cpu.registerH);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xAD)) {\n\n    // XOR L\n    // 1  4\n    // Z 0 0 0\n    xorARegister(Cpu.registerL);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xAE)) {\n\n    // XOR (HL)\n    // 1  8\n    // Z 0 0 0\n    let valueAtHL: u8 = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n    xorARegister(<u8>valueAtHL);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0xAF)) {\n\n    // XOR A\n    // 1  4\n    // Z 0 0 0\n    xorARegister(Cpu.registerA);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xB0)) {\n\n    // OR B\n    // 1  4\n    // Z 0 0 0\n    orARegister(Cpu.registerB);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xB1)) {\n\n    // OR C\n    // 1  4\n    // Z 0 0 0\n    orARegister(Cpu.registerC);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xB2)) {\n\n    // OR D\n    // 1  4\n    // Z 0 0 0\n    orARegister(Cpu.registerD);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xB3)) {\n\n    // OR E\n    // 1  4\n    // Z 0 0 0\n    orARegister(Cpu.registerE);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xB4)) {\n\n    // OR H\n    // 1  4\n    // Z 0 0 0\n    orARegister(Cpu.registerH);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xB5)) {\n\n    // OR L\n    // 1  4\n    // Z 0 0 0\n    orARegister(Cpu.registerL);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xB6)) {\n\n    // OR (HL)\n    // 1  8\n    // Z 0 0 0\n    let valueAtHL: u8 = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n    orARegister(<u8>valueAtHL);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0xB7)) {\n\n    // OR A\n    // 1  4\n    // Z 0 0 0\n    orARegister(Cpu.registerA);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xB8)) {\n\n    // CP B\n    // 1  4\n    // Z 1 H C\n    cpARegister(Cpu.registerB);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xB9)) {\n\n    // CP C\n    // 1  4\n    // Z 1 H C\n    cpARegister(Cpu.registerC);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xBA)) {\n\n    // CP D\n    // 1  4\n    // Z 1 H C\n    cpARegister(Cpu.registerD);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xBB)) {\n\n    // CP E\n    // 1  4\n    // Z 1 H C\n    cpARegister(Cpu.registerE);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xBC)) {\n\n    // CP H\n    // 1  4\n    // Z 1 H C\n    cpARegister(Cpu.registerH);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xBD)) {\n\n    // CP L\n    // 1  4\n    // Z 1 H C\n    cpARegister(Cpu.registerL);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xBE)) {\n\n    // CP (HL)\n    // 1  8\n    // Z 1 H C\n    let valueAtHL: u8 = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n    cpARegister(<u8>valueAtHL);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0xBF)) {\n\n    // CP A\n    // 1  4\n    // Z 1 H C\n    cpARegister(Cpu.registerA);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xC0)) {\n\n    // RET NZ\n    // 1  20/8\n    if (getZeroFlag() === 0) {\n      Cpu.programCounter = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n      Cpu.stackPointer += 2;\n      numberOfCycles = 20;\n    } else {\n      numberOfCycles = 8;\n    }\n  } else if(isOpcode(opcode, 0xC1)) {\n\n    // POP BC\n    // 1  12\n    let registerBC = concatenateBytes(Cpu.registerB, Cpu.registerC);\n    registerBC = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n    Cpu.stackPointer += 2;\n    Cpu.registerB = splitHighByte(registerBC);\n    Cpu.registerC = splitLowByte(registerBC);\n    numberOfCycles = 12;\n  } else if(isOpcode(opcode, 0xC2)) {\n\n    // JP NZ,a16\n    // 3  16/12\n    if (getZeroFlag() === 0) {\n      Cpu.programCounter = concatenatedDataByte;\n      numberOfCycles = 16;\n    } else {\n      Cpu.programCounter += 2;\n      numberOfCycles = 12;\n    }\n  } else if(isOpcode(opcode, 0xC3)) {\n\n    // JP a16\n    // 3  16\n    Cpu.programCounter = concatenatedDataByte;\n    numberOfCycles = 16;\n  } else if(isOpcode(opcode, 0xC4)) {\n\n    // CALL NZ,a16\n    // 3  24/12\n    if (getZeroFlag() === 0) {\n      Cpu.stackPointer -= 2;\n      sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter + 2);\n      Cpu.programCounter = sixteenBitLoadFromGBMemory(Cpu.programCounter);\n      numberOfCycles = 24;\n    } else {\n      numberOfCycles = 12;\n      Cpu.programCounter += 2;\n    }\n  } else if(isOpcode(opcode, 0xC5)) {\n\n    // PUSH BC\n    // 1  16\n    let registerBC = concatenateBytes(Cpu.registerB, Cpu.registerC);\n    Cpu.stackPointer -= 2;\n    sixteenBitStoreIntoGBMemory(Cpu.stackPointer, registerBC);\n    numberOfCycles = 16;\n  } else if(isOpcode(opcode, 0xC6)) {\n\n    // ADD A,d8\n    // 2 8\n    // Z 0 H C\n    addARegister(dataByteOne);\n    Cpu.programCounter += 1;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xC7)) {\n\n    // RST 00H\n    // 1 16\n    Cpu.stackPointer -= 2;\n    sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter);\n    Cpu.programCounter = 0x00;\n    numberOfCycles = 16;\n  } else if(isOpcode(opcode, 0xC8)) {\n\n    // RET Z\n    // 1  20/8\n    if (getZeroFlag() === 1) {\n      Cpu.programCounter = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n      Cpu.stackPointer += 2;\n      numberOfCycles = 20;\n    } else {\n      numberOfCycles = 8;\n    }\n  } else if(isOpcode(opcode, 0xC9)) {\n\n    // RET\n    // 1 16\n    Cpu.programCounter = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n    Cpu.stackPointer += 2;\n    numberOfCycles = 16;\n  } else if(isOpcode(opcode, 0xCA)) {\n\n    // JP Z,a16\n    // 3 16/12\n    if (getZeroFlag() === 1) {\n      Cpu.programCounter = concatenatedDataByte;\n      numberOfCycles = 16;\n    } else {\n      Cpu.programCounter += 2;\n      numberOfCycles = 12;\n    }\n  } else if(isOpcode(opcode, 0xCB)) {\n    // PREFIX CB\n    // 1  4\n    numberOfCycles = handleCbOpcode(dataByteOne);\n    if(numberOfCycles > 0) {\n      numberOfCycles += 4;\n    }\n  } else if(isOpcode(opcode, 0xCC)) {\n\n    // CALL Z,a16\n    // 3  24/12\n    if (getZeroFlag() === 1) {\n      Cpu.stackPointer -= 2;\n      sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter + 2);\n      Cpu.programCounter = sixteenBitLoadFromGBMemory(Cpu.programCounter);\n      numberOfCycles = 24;\n    } else {\n      Cpu.programCounter += 2;\n      numberOfCycles = 12;\n    }\n  } else if(isOpcode(opcode, 0xCD)) {\n\n    // CALL a16\n    // 3  24\n    Cpu.stackPointer -= 2;\n    sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter + 2);\n    Cpu.programCounter = sixteenBitLoadFromGBMemory(Cpu.programCounter);\n    numberOfCycles = 24;\n  } else if(isOpcode(opcode, 0xCE)) {\n\n    // ADC A,d8\n    // 2  8\n    // Z 0 H C\n    addAThroughCarryRegister(dataByteOne);\n    Cpu.programCounter += 1;\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xCF)) {\n\n    // RST 08H\n    // 1 16\n    Cpu.stackPointer -= 2;\n    sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter);\n    Cpu.programCounter = 0x08;\n    numberOfCycles = 16;\n  } else if(isOpcode(opcode, 0xD0)) {\n\n    // RET NC\n    // 1  20/8\n    if (getCarryFlag() === 0) {\n      Cpu.programCounter = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n      Cpu.stackPointer += 2;\n      numberOfCycles = 20;\n    } else {\n      numberOfCycles = 8;\n    }\n  } else if(isOpcode(opcode, 0xD1)) {\n\n    // POP DE\n    // 1  12\n    let registerDE = concatenateBytes(Cpu.registerD, Cpu.registerE);\n    registerDE = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n    Cpu.stackPointer += 2;\n    Cpu.registerD = splitHighByte(registerDE);\n    Cpu.registerE = splitLowByte(registerDE);\n    numberOfCycles = 12;\n  } else if(isOpcode(opcode, 0xD2)) {\n\n    // JP NC,a16\n    // 3  16/12\n    if (getCarryFlag() === 0) {\n      Cpu.programCounter = concatenatedDataByte;\n      numberOfCycles = 16;\n    } else {\n      Cpu.programCounter += 2;\n      numberOfCycles = 12;\n    }\n  } /* No Opcode for: 0xD3 */ else if(isOpcode(opcode, 0xD4)) {\n\n    // CALL NC,a16\n    // 3  24/12\n    if (getCarryFlag() === 0) {\n      Cpu.stackPointer -= 2;\n      sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter + 2);\n      Cpu.programCounter = sixteenBitLoadFromGBMemory(Cpu.programCounter);\n      numberOfCycles = 24;\n    } else {\n      Cpu.programCounter += 2;\n      numberOfCycles = 12;\n    }\n  } else if(isOpcode(opcode, 0xD5)) {\n\n    // PUSH DE\n    // 1 16\n    let registerDE = concatenateBytes(Cpu.registerD, Cpu.registerE);\n    Cpu.stackPointer -= 2;\n    sixteenBitStoreIntoGBMemory(Cpu.stackPointer, registerDE);\n    numberOfCycles = 16;\n  } else if(isOpcode(opcode, 0xD6)) {\n\n    // SUB d8\n    // 2  8\n    // Z 1 H C\n    subARegister(dataByteOne);\n    Cpu.programCounter += 1;\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0xD7)) {\n\n    // RST 10H\n    // 1 16\n    Cpu.stackPointer -= 2;\n    sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter);\n    Cpu.programCounter = 0x10;\n    numberOfCycles = 16;\n  } else if(isOpcode(opcode, 0xD8)) {\n\n    // RET C\n    // 1  20/8\n    if (getCarryFlag() === 1) {\n      Cpu.programCounter = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n      Cpu.stackPointer += 2;\n      numberOfCycles = 20;\n    } else {\n      numberOfCycles = 8;\n    }\n  } else if(isOpcode(opcode, 0xD9)) {\n\n    // RETI\n    // 1  16\n    Cpu.programCounter = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n    // Enable interrupts\n    setInterrupts(true);\n    Cpu.stackPointer += 2;\n    numberOfCycles = 16;\n  } else if(isOpcode(opcode, 0xDA)) {\n\n    // JP C,a16\n    // 3 16/12\n    if (getCarryFlag() === 1) {\n      Cpu.programCounter = concatenatedDataByte;\n      numberOfCycles = 16;\n    } else {\n      Cpu.programCounter += 2;\n      numberOfCycles = 12;\n    }\n  } /* No Opcode for: 0xDB */else if(isOpcode(opcode, 0xDC)) {\n\n    // CALL C,a16\n    // 3  24/12\n    if (getCarryFlag() === 1) {\n      Cpu.stackPointer -= 2;\n      sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter + 2);\n      Cpu.programCounter = sixteenBitLoadFromGBMemory(Cpu.programCounter);\n      numberOfCycles = 24;\n    } else {\n      Cpu.programCounter += 2;\n      numberOfCycles = 12;\n    }\n  } /* No Opcode for: 0xDD */else if(isOpcode(opcode, 0xDE)) {\n\n    // SBC A,d8\n    // 2 8\n    // Z 1 H C\n    subAThroughCarryRegister(dataByteOne);\n    Cpu.programCounter += 1;\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0xDF)) {\n    // RST 18H\n    // 1 16\n    Cpu.stackPointer -= 2;\n    sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter);\n    Cpu.programCounter = 0x18;\n    numberOfCycles = 16;\n  } else if(isOpcode(opcode, 0xE0)) {\n\n    // LDH (a8),A\n    // 2  12\n\n    // Store value in high RAM ($FF00 + a8)\n    let largeDataByteOne: u16 = dataByteOne;\n    eightBitStoreIntoGBMemory(0xFF00 + largeDataByteOne, Cpu.registerA);\n    Cpu.programCounter += 1;\n    numberOfCycles = 12;\n  } else if(isOpcode(opcode, 0xE1)) {\n\n    // POP HL\n    // 1  12\n    let registerHL = concatenateBytes(Cpu.registerH, Cpu.registerL);\n    registerHL = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n    Cpu.stackPointer += 2;\n    Cpu.registerH = splitHighByte(registerHL);\n    Cpu.registerL = splitLowByte(registerHL);\n    numberOfCycles = 12;\n  } else if(isOpcode(opcode, 0xE2)) {\n\n    // LD (C),A\n    // 2  8\n    // NOTE: Table says 2 Program counter,\n    // But stepping through the boot rom, should be one\n\n    // Store value in high RAM ($FF00 + register c)\n    eightBitStoreIntoGBMemory(0xFF00 + Cpu.registerC, Cpu.registerA);\n    numberOfCycles = 8;\n  } /* No Opcode for: 0xE3, 0xE4 */ else if(isOpcode(opcode, 0xE5)) {\n\n    // PUSH HL\n    // 1 16\n    let registerHL = concatenateBytes(Cpu.registerH, Cpu.registerL);\n    Cpu.stackPointer -= 2;\n    sixteenBitStoreIntoGBMemory(Cpu.stackPointer, registerHL);\n    numberOfCycles = 16;\n  } else if(isOpcode(opcode, 0xE6)) {\n\n    // AND d8\n    // 2  8\n    // Z 0 1 0\n    andARegister(dataByteOne);\n    Cpu.programCounter += 1;\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0xE7)) {\n\n    // RST 20H\n    // 1 16\n    Cpu.stackPointer -= 2;\n    sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter);\n    Cpu.programCounter = 0x20;\n    numberOfCycles = 16;\n  } else if(isOpcode(opcode, 0xE8)) {\n\n    // ADD SP, r8\n    // 2 16\n    // 0 0 H C\n    // NOTE: Discoved dataByte is signed\n    let signedDataByteOne: i8 = <i8>dataByteOne;\n\n    checkAndSetSixteenBitFlagsAddOverflow(Cpu.stackPointer, signedDataByteOne, true);\n    Cpu.stackPointer += signedDataByteOne;\n    setZeroFlag(0);\n    setSubtractFlag(0);\n    Cpu.programCounter += 1;\n    numberOfCycles = 16;\n  } else if(isOpcode(opcode, 0xE9)) {\n\n    // JP (HL)\n    // 1 4\n    Cpu.programCounter = concatenateBytes(Cpu.registerH, Cpu.registerL);\n    numberOfCycles = 4;\n  } else if(isOpcode(opcode, 0xEA)) {\n\n    // LD (a16),A\n    // 3 16\n    eightBitStoreIntoGBMemory(concatenatedDataByte, Cpu.registerA);\n    Cpu.programCounter += 2;\n    numberOfCycles = 16;\n  } /* No Opcode for: 0xEB, 0xEC, 0xED */ else if(isOpcode(opcode, 0xEE)) {\n\n    // XOR d8\n    // 2 8\n    // Z 0 0 0\n    xorARegister(dataByteOne);\n    Cpu.programCounter += 1;\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0xEF)) {\n\n    // RST 28H\n    // 1 16\n    Cpu.stackPointer -= 2;\n    sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter);\n    Cpu.programCounter = 0x28;\n    numberOfCycles = 16;\n  } else if(isOpcode(opcode, 0xF0)) {\n\n    // LDH A,(a8)\n    // 2 12\n    let largeDataByteOne: u16 = dataByteOne;\n    Cpu.registerA = eightBitLoadFromGBMemory(0xFF00 + largeDataByteOne);\n    Cpu.programCounter += 1;\n    numberOfCycles = 12;\n  } else if(isOpcode(opcode, 0xF1)) {\n\n    // POP AF\n    // 1 12\n    // Z N H C (But No work require, flags are already set)\n    let registerAF = concatenateBytes(Cpu.registerA, Cpu.registerF);\n    registerAF = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n    Cpu.stackPointer += 2;\n    Cpu.registerA = splitHighByte(registerAF);\n    Cpu.registerF = splitLowByte(registerAF);\n    numberOfCycles = 12;\n  } else if(isOpcode(opcode, 0xF2)) {\n\n    // LD A,(C)\n    // 2 8\n    Cpu.registerA = eightBitLoadFromGBMemory(0xFF00 + Cpu.registerC);\n    Cpu.programCounter += 1;\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0xF3)) {\n\n    // DI\n    // 1 4\n    setInterrupts(false);\n    numberOfCycles = 4;\n  } /* No Opcode for: 0xF4 */ else if(isOpcode(opcode, 0xF5)) {\n\n    // PUSH AF\n    // 1 16\n    let registerAF = concatenateBytes(Cpu.registerA, Cpu.registerF);\n    Cpu.stackPointer -= 2;\n    sixteenBitStoreIntoGBMemory(Cpu.stackPointer, registerAF);\n    numberOfCycles = 16;\n  } else if(isOpcode(opcode, 0xF6)) {\n\n    // OR d8\n    // 2 8\n    // Z 0 0 0\n    orARegister(dataByteOne);\n    Cpu.programCounter += 1;\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0xF7)) {\n\n    // RST 30H\n    // 1 16\n    Cpu.stackPointer -= 2;\n    sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter);\n    Cpu.programCounter = 0x30;\n    numberOfCycles = 16;\n  } else if(isOpcode(opcode, 0xF8)) {\n\n    // LD HL,SP+r8\n    // 2 12\n    // 0 0 H C\n    // NOTE: Discoved dataByte is signed\n    let signedDataByteOne: i8 = <i8>dataByteOne;\n\n    // First, let's handle flags\n    setZeroFlag(0);\n    setSubtractFlag(0);\n    checkAndSetSixteenBitFlagsAddOverflow(Cpu.stackPointer, signedDataByteOne, true);\n    let registerHL = Cpu.stackPointer + signedDataByteOne;\n    Cpu.registerH = splitHighByte(registerHL);\n    Cpu.registerL = splitLowByte(registerHL);\n    Cpu.programCounter += 1;\n    numberOfCycles = 12;\n  } else if(isOpcode(opcode, 0xF9)) {\n\n    // LD SP,HL\n    // 1 8\n    Cpu.stackPointer = concatenateBytes(Cpu.registerH, Cpu.registerL);\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0xFA)) {\n\n    // LD A,(a16)\n    // 3 16\n    Cpu.registerA = eightBitLoadFromGBMemory(concatenatedDataByte);\n    Cpu.programCounter += 2;\n    numberOfCycles = 16;\n  } else if(isOpcode(opcode, 0xFB)) {\n\n    // EI\n    // 1 4\n    setInterrupts(true);\n    numberOfCycles = 4;\n  } /* No Opcode for: 0xFC, 0xFD */ else if(isOpcode(opcode, 0xFE)) {\n\n    // CP d8\n    // 2 8\n    // Z 1 H C\n    cpARegister(dataByteOne);\n    Cpu.programCounter += 1;\n    numberOfCycles = 8;\n  } else if(isOpcode(opcode, 0xFF)) {\n\n    // RST 38H\n    // 1 16\n    Cpu.stackPointer -= 2;\n    sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter);\n    Cpu.programCounter = 0x38;\n    numberOfCycles = 16;\n  }\n\n  // NOTE: Moved Program Counter to top, because program counter state should be considered Before doing calls\n\n\n  // Return the number of cycles\n  return numberOfCycles;\n}\n","import {\n  Cpu\n} from './index';\n\n\n// Set flag bit on on register F. For instance set zero flag to zero -> (7, 0)\nfunction setFlagBit(flagBit: u8, flagValue: u8): u8 {\n\n  let bitwiseOperand: u8 = 0x01 << flagBit;\n  if(flagValue > 0) {\n    Cpu.registerF = Cpu.registerF | bitwiseOperand;\n  } else {\n    // XOR out the two ones\n    bitwiseOperand = 0xFF ^ bitwiseOperand;\n    Cpu.registerF = Cpu.registerF & bitwiseOperand;\n  }\n\n  return Cpu.registerF;\n}\n\n// Overload the set flag bit for ease of use\nexport function setZeroFlag(value: u8): void {\n  setFlagBit(7, value);\n}\n\nexport function setSubtractFlag(value: u8): void {\n  setFlagBit(6, value)\n}\n\nexport function setHalfCarryFlag(value: u8): void {\n  setFlagBit(5, value);\n}\n\nexport function setCarryFlag(value: u8): void {\n  setFlagBit(4, value)\n}\n\n// Getters for flags\nexport function getZeroFlag(): u8 {\n  return (Cpu.registerF >> 7) & 0x01;\n}\n\nexport function getSubtractFlag(): u8 {\n  return (Cpu.registerF >> 6) & 0x01;\n}\n\nexport function getHalfCarryFlag(): u8 {\n  return (Cpu.registerF >> 5) & 0x01;\n}\n\nexport function getCarryFlag(): u8 {\n  return (Cpu.registerF >> 4) & 0x01;\n}\n\n// Must be run before the register actually performs the add\n// amountToAdd i16, since max number can be an u8\nexport function checkAndSetEightBitHalfCarryFlag(value: u8, amountToAdd: i16): void {\n  if(amountToAdd >= 0) {\n    // https://robdor.com/2016/08/10/gameboy-emulator-half-carry-flag/\n    let result: u8 = (((<u8>value & 0x0F) + (<u8>amountToAdd & 0x0F)) & 0x10)\n    if(result !== 0x00) {\n      setHalfCarryFlag(1);\n    } else {\n      setHalfCarryFlag(0);\n    }\n  } else {\n    // From: https://github.com/djhworld/gomeboycolor/blob/master/src/cpu/cpu.go\n    // CTRL+F \"subBytes(a, b byte)\"\n    if(<u8>(abs(amountToAdd) & 0x0F) > (value & 0x0F)) {\n      setHalfCarryFlag(1);\n    } else {\n      setHalfCarryFlag(0);\n    }\n  }\n}\n\nexport function checkAndSetEightBitCarryFlag(value: u8, amountToAdd: i16): void {\n  if (amountToAdd >= 0) {\n    let result: u8 = value + <u8>amountToAdd;\n    if (value > result) {\n      setCarryFlag(1);\n    } else {\n      setCarryFlag(0);\n    }\n  } else {\n    if(abs(amountToAdd) > value) {\n      setCarryFlag(1);\n    } else {\n      setCarryFlag(0);\n    }\n  }\n}\n\n// Function to handle 16 bit addition overflow, and set the carry flags accordingly\n// i32 on valueTwo to support passing signed immedaite values\nexport function checkAndSetSixteenBitFlagsAddOverflow(valueOne: u16, valueTwo: i32, useStackPointerBits: boolean): void {\n  // need to differentiate between HL and SP\n  // HL carries are at 11 and 15, SP carries are at 3 and 7 :p\n  if(useStackPointerBits) {\n    // Logic from : https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n    // CTRL+F add_sp_n\n    // using the stack pointer bits means we can safely assume the value is signed\n    let signedValueOne: i32 = <i32>valueOne;\n    let result: i32 = signedValueOne + <i32>valueTwo;\n\n    let flagXor: i32 = signedValueOne ^ valueTwo ^ result;\n\n    if((flagXor & 0x10) !== 0) {\n      setHalfCarryFlag(1);\n    } else {\n      setHalfCarryFlag(0);\n    }\n\n    if((flagXor & 0x100) !== 0) {\n      setCarryFlag(1);\n    } else {\n      setCarryFlag(0);\n    }\n  } else {\n    // Logic from: https://github.com/djhworld/gomeboycolor/blob/master/src/cpu/cpu.go\n    // CTRL+F addWords\n    // Value two is not signed\n    let result: u16 = valueOne + <u16>valueTwo;\n\n    // Check the carry flag by allowing the overflow\n    if(result < valueOne) {\n      setCarryFlag(1);\n    } else {\n      setCarryFlag(0);\n    }\n\n    // To check for half carry flag (bit 15), by XOR'ing valyes, and and'ing the bit in question\n    if ( ((valueOne ^ <u16>valueTwo ^ <u16>result) & 0x1000) !== 0x00 ) {\n      setHalfCarryFlag(1);\n    } else {\n      setHalfCarryFlag(0);\n    }\n  }\n}\n","// Imports\nimport {\n  Cpu\n} from './index';\nimport {\n  setZeroFlag,\n  getZeroFlag,\n  setSubtractFlag,\n  getSubtractFlag,\n  setHalfCarryFlag,\n  getHalfCarryFlag,\n  setCarryFlag,\n  getCarryFlag,\n  checkAndSetEightBitCarryFlag,\n  checkAndSetEightBitHalfCarryFlag,\n  checkAndSetSixteenBitFlagsAddOverflow\n} from './flags';\nimport {\n  rotateByteLeft,\n  rotateByteLeftThroughCarry,\n  rotateByteRight,\n  rotateByteRightThroughCarry,\n  concatenateBytes\n} from '../helpers/index';\n\n// General Logic Instructions\n// Such as the ones found on the CB table and 0x40 - 0xBF\n// NOTE: Only CB table uses these for now, was mostly me realizing that I messed up, trying to be all cute and verbose :p\n// NOTE: TODO: Refactor honestly shouldn't take that long, and may happen once assembly script is improved\nexport function addARegister(register: u8): void {\n  checkAndSetEightBitHalfCarryFlag(Cpu.registerA, register);\n  checkAndSetEightBitCarryFlag(Cpu.registerA, register);\n  Cpu.registerA += register;\n  if (Cpu.registerA === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n  setSubtractFlag(0);\n}\n\nexport function addAThroughCarryRegister(register: u8): void {\n  // Handling flags manually as they require some special overflow\n  // From: https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n  // CTRL+F adc\n  let result: u8 = Cpu.registerA + register + getCarryFlag();\n  if (((Cpu.registerA ^ register ^ result) & 0x10) != 0) {\n    setHalfCarryFlag(1);\n  } else {\n    setHalfCarryFlag(0);\n  }\n\n  let overflowedResult: u16 = <u16>Cpu.registerA + <u16>register + <u16>getCarryFlag();\n  if((overflowedResult & 0x100) > 0) {\n    setCarryFlag(1);\n  } else {\n    setCarryFlag(0);\n  }\n\n  Cpu.registerA = result;\n  if (Cpu.registerA === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n  setSubtractFlag(0);\n}\n\nexport function subARegister(register: u8): void {\n  // Need to convert the register on one line, and flip the sign on another\n  let negativeRegister: i16 = <i16>register;\n  negativeRegister = negativeRegister * -1;\n\n  checkAndSetEightBitHalfCarryFlag(Cpu.registerA, <i16>negativeRegister);\n  checkAndSetEightBitCarryFlag(Cpu.registerA, <i16>negativeRegister);\n  Cpu.registerA -= register;\n  if (Cpu.registerA === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n  setSubtractFlag(1);\n}\n\nexport function subAThroughCarryRegister(register: u8): void {\n\n  // Handling flags manually as they require some special overflow\n  // From: https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n  // CTRL+F adc\n  let result: u8 = Cpu.registerA - register - getCarryFlag();\n\n  if (((Cpu.registerA ^ register ^ result) & 0x10) != 0) {\n    setHalfCarryFlag(1);\n  } else {\n    setHalfCarryFlag(0);\n  }\n\n  let overflowedResult: u16 = <u16>Cpu.registerA - <u16>register - <u16>getCarryFlag();\n  if((overflowedResult & 0x100) > 0) {\n    setCarryFlag(1);\n  } else {\n    setCarryFlag(0);\n  }\n\n  Cpu.registerA = result;\n  if (Cpu.registerA === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n  setSubtractFlag(1);\n}\n\nexport function andARegister(register: u8): void {\n  Cpu.registerA = (Cpu.registerA & register);\n  if (Cpu.registerA === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n  setSubtractFlag(0);\n  setHalfCarryFlag(1);\n  setCarryFlag(0);\n}\n\nexport function xorARegister(register: u8): void {\n  Cpu.registerA = Cpu.registerA ^ register;\n  if (Cpu.registerA === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n  setCarryFlag(0);\n}\n\nexport function orARegister(register: u8): void {\n  Cpu.registerA = Cpu.registerA | register;\n  if (Cpu.registerA === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n  setCarryFlag(0);\n}\n\nexport function cpARegister(register: u8): void {\n  // 0xB8 - 0xBF\n  // CP B\n  // 1  4\n  // Z 1 H C\n  let negativeRegister: i16 = <i16>register;\n  negativeRegister = negativeRegister * -1;\n  checkAndSetEightBitHalfCarryFlag(Cpu.registerA, <i16>negativeRegister);\n  checkAndSetEightBitCarryFlag(Cpu.registerA, <i16>negativeRegister);\n  let tempResult: i16 = <i16>Cpu.registerA + <i16>negativeRegister;\n  if (tempResult === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n  setSubtractFlag(1);\n}\n\nexport function rotateRegisterLeft(register: u8): u8 {\n\n  // RLC register 8-bit\n  // Z 0 0 C\n  if((register & 0x80) === 0x80) {\n    setCarryFlag(1);\n  } else {\n    setCarryFlag(0);\n  }\n  register = rotateByteLeft(register);\n  if(register === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n\n  // Set all other flags to zero\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n\n  // Return the register\n  return register;\n}\n\nexport function rotateRegisterRight(register: u8): u8 {\n\n  // RLC register 8-bit\n  // Z 0 0 C\n  // Check for the last bit, to see if it will be carried\n  if ((register & 0x01) > 0) {\n    setCarryFlag(1);\n  } else {\n    setCarryFlag(0);\n  }\n  register = rotateByteRight(register);\n\n  if (register === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n\n  // Return the register\n  return register;\n}\n\nexport function rotateRegisterLeftThroughCarry(register: u8): u8 {\n\n  // RL register 8-bit\n  // Z 0 0 C\n  // setting has first bit since we need to use carry\n  let hasHighbit = false;\n  if((register & 0x80) === 0x80) {\n    hasHighbit = true;\n  }\n  register = rotateByteLeftThroughCarry(register);\n\n  if(hasHighbit) {\n    setCarryFlag(1);\n  } else {\n    setCarryFlag(0);\n  }\n\n  if (register === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n\n  return register;\n}\n\nexport function rotateRegisterRightThroughCarry(register: u8): u8 {\n\n  // RR register 8-bit\n  // Z 0 0 C\n  let hasLowBit = false;\n  if((register & 0x01) === 0x01) {\n    hasLowBit = true;\n  }\n  register = rotateByteRightThroughCarry(register);\n\n  if(hasLowBit) {\n    setCarryFlag(1);\n  } else {\n    setCarryFlag(0);\n  }\n\n  if (register === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n\n  return register;\n}\n\nexport function shiftLeftRegister(register: u8): u8 {\n\n  // SLA register 8-bit\n  // Z 0 0 C\n  let hasHighbit = false;\n  if((register & 0x80) === 0x80) {\n    hasHighbit = true;\n  }\n\n  register = register << 1;\n\n  if(hasHighbit) {\n    setCarryFlag(1);\n  } else {\n    setCarryFlag(0);\n  }\n\n  if (register === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n\n  return register;\n}\n\nexport function shiftRightArithmeticRegister(register: u8): u8 {\n\n  // SRA register 8-bit\n  // Z 0 0 C\n  // NOTE: This C flag may need to be set to 0;\n  // This preserves the MSB (Most significant bit)\n  let hasHighbit = false;\n  if((register & 0x80) === 0x80) {\n    hasHighbit = true;\n  }\n\n  let hasLowbit = false;\n  if((register & 0x01) === 0x01) {\n    hasLowbit = true;\n  }\n\n  register = register >> 1;\n\n  if(hasHighbit) {\n    register = (register | 0x80);\n  }\n\n  if (register === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n\n  if(hasLowbit) {\n    setCarryFlag(1);\n  } else {\n    setCarryFlag(0);\n  }\n\n  return register;\n}\n\nexport function swapNibblesOnRegister(register: u8): u8 {\n  // SWAP register 8-bit\n  // Z 0 0 0\n  let highNibble = register & 0xF0;\n  let lowNibble = register & 0x0F;\n  register = (lowNibble << 4) | (highNibble >> 4)\n\n  if (register === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n  setCarryFlag(0);\n\n  return register;\n}\n\nexport function shiftRightLogicalRegister(register: u8): u8 {\n\n  // SRA register 8-bit\n  // Z 0 0 C\n  // NOTE: This C flag may need to be set to 0;\n  // This does NOT preserve MSB (most significant bit)\n\n  let hasLowbit = false;\n  if((register & 0x01) === 0x01) {\n    hasLowbit = true;\n  }\n\n  register = register >> 1;\n\n  if (register === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n\n  if(hasLowbit) {\n    setCarryFlag(1);\n  } else {\n    setCarryFlag(0);\n  }\n\n  return register;\n}\n\nexport function testBitOnRegister(bitPosition: u8, register: u8): u8 {\n  // BIT bitPosition ,register 8-bit\n  // Z 0 1 -\n\n  let testByte: u8 = (0x01 << bitPosition);\n  let result = (register & testByte);\n  if(result === 0x00) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n\n  setSubtractFlag(0);\n  setHalfCarryFlag(1);\n\n  return register;\n}\n\nexport function setBitOnRegister(bitPosition: u8, bitValue: u8, register: u8): u8 {\n\n  // RES 0,B or SET 0,B depending on bit value\n\n  if(bitValue > 0) {\n   let setByte: u8 = (0x01 << bitPosition);\n   register = register | setByte;\n  } else {\n   // NOT (byte we want)\n   // 0000 0100 becomes 1111 1011\n   let setByte: u8 = ~(0x01 << bitPosition);\n   register = register & setByte;\n  }\n\n  return register;\n}\n","// Imports\nimport {\n  Cpu\n} from './index';\nimport {\n  rotateRegisterLeft,\n  rotateRegisterRight,\n  rotateRegisterLeftThroughCarry,\n  rotateRegisterRightThroughCarry,\n  shiftLeftRegister,\n  shiftRightArithmeticRegister,\n  swapNibblesOnRegister,\n  shiftRightLogicalRegister,\n  testBitOnRegister,\n  setBitOnRegister\n} from './instructions';\nimport {\n  concatenateBytes\n} from '../helpers/index';\nimport {\n  eightBitStoreIntoGBMemory,\n  sixteenBitStoreIntoGBMemory,\n  eightBitLoadFromGBMemory,\n  sixteenBitLoadFromGBMemory\n} from '../memory/index';\n\n\n\n\n// Handle CB Opcodes\n// NOTE: Program stpes and cycles are standardized depending on the register type\n// NOTE: Doing some funny stuff to get around not having arrays or objects\nexport function handleCbOpcode(cbOpcode: u8): i8 {\n\n  let numberOfCycles: i8 = -1;\n  let handledOpcode = false;\n\n  // The result of our cb logic instruction\n  let instructionRegisterValue: u8 = 0;\n  let instructionRegisterResult: u8 = 0;\n\n  // Get our register number by modulo 0x08 (number of registers)\n  // cbOpcode % 0x08\n  let registerNumber = cbOpcode % 0x08;\n\n  // NOTE: registerNumber = register on CB table. Cpu.registerB = 0, Cpu.registerC = 1....Cpu.registerA = 7\n  if(registerNumber === 0) {\n    instructionRegisterValue = Cpu.registerB;\n  } else if (registerNumber === 1) {\n    instructionRegisterValue = Cpu.registerC;\n  } else if (registerNumber === 2) {\n    instructionRegisterValue = Cpu.registerD;\n  } else if (registerNumber === 3) {\n    instructionRegisterValue = Cpu.registerE;\n  } else if (registerNumber === 4) {\n    instructionRegisterValue = Cpu.registerH;\n  } else if (registerNumber === 5) {\n    instructionRegisterValue = Cpu.registerL;\n  } else if (registerNumber === 6) {\n    // Value at register HL\n    instructionRegisterValue = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n  } else if (registerNumber === 7) {\n    instructionRegisterValue = Cpu.registerA;\n  }\n\n  // Send to the correct function\n  if (cbOpcode <= 0x07) {\n    // RLC register 8-bit\n    // Z 0 0 C\n    instructionRegisterResult = rotateRegisterLeft(instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x0F) {\n    // RRC register 8-bit\n    // Z 0 0 C\n    instructionRegisterResult = rotateRegisterRight(instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x17) {\n    // RL register 8-bit\n    // Z 0 0 C\n    instructionRegisterResult = rotateRegisterLeftThroughCarry(instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x1F) {\n    // RR register 8-bit\n    // Z 0 0 C\n    instructionRegisterResult = rotateRegisterRightThroughCarry(instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x27) {\n    // SLA register 8-bit\n    // Z 0 0 C\n    instructionRegisterResult = shiftLeftRegister(instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x2F) {\n    // SRA register 8-bit\n    // Z 0 0 0\n    instructionRegisterResult = shiftRightArithmeticRegister(instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x37) {\n    // SWAP register 8-bit\n    // Z 0 0 0\n    instructionRegisterResult = swapNibblesOnRegister(instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x3F) {\n    // SRL B\n    // Z 0 0 C\n    instructionRegisterResult = shiftRightLogicalRegister(instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x47) {\n    // BIT 0,register 8-bit\n    // Z 0 1 -\n    //TODO: Optimize this not to do logic of setting register back\n    instructionRegisterResult = testBitOnRegister(0, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x4F) {\n    // BIT 1,register 8-bit\n    // Z 0 1 -\n    instructionRegisterResult = testBitOnRegister(1, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x57) {\n    // BIT 2,register 8-bit\n    // Z 0 1 -\n    instructionRegisterResult = testBitOnRegister(2, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x5F) {\n    // BIT 3,register 8-bit\n    // Z 0 1 -\n    instructionRegisterResult = testBitOnRegister(3, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x67) {\n    // BIT 4,register 8-bit\n    // Z 0 1 -\n    instructionRegisterResult = testBitOnRegister(4, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x6F) {\n    // BIT 5,register 8-bit\n    // Z 0 1 -\n    instructionRegisterResult = testBitOnRegister(5, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x77) {\n    // BIT 6,register 8-bit\n    // Z 0 1 -\n    instructionRegisterResult = testBitOnRegister(6, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x7F) {\n    // BIT 7,register 8-bit\n    // Z 0 1 -\n    instructionRegisterResult = testBitOnRegister(7, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x87) {\n    // Res 0,register 8-bit\n    // - - - -\n    instructionRegisterResult = setBitOnRegister(0, 0, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x8F) {\n    // Res 1,register 8-bit\n    // - - - -\n    instructionRegisterResult = setBitOnRegister(1, 0, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x97) {\n    // Res 2,register 8-bit\n    // - - - -\n    instructionRegisterResult = setBitOnRegister(2, 0, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0x9F) {\n    // Res 3,register 8-bit\n    // - - - -\n    instructionRegisterResult = setBitOnRegister(3, 0, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0xA7) {\n    // Res 4,register 8-bit\n    // - - - -\n    instructionRegisterResult = setBitOnRegister(4, 0, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0xAF) {\n    // Res 5,register 8-bit\n    // - - - -\n    instructionRegisterResult = setBitOnRegister(5, 0, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0xB7) {\n    // Res 6,register 8-bit\n    // - - - -\n    instructionRegisterResult = setBitOnRegister(6, 0, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0xBF) {\n    // Res 7,register 8-bit\n    // - - - -\n    instructionRegisterResult = setBitOnRegister(7, 0, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0xC7) {\n    // SET 0,register 8-bit\n    // - - - -\n    instructionRegisterResult = setBitOnRegister(0, 1, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0xCF) {\n    // SET 1,register 8-bit\n    // - - - -\n    instructionRegisterResult = setBitOnRegister(1, 1, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0xD7) {\n    // SET 2,register 8-bit\n    // - - - -\n    instructionRegisterResult = setBitOnRegister(2, 1, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0xDF) {\n    // SET 3,register 8-bit\n    // - - - -\n    instructionRegisterResult = setBitOnRegister(3, 1, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0xE7) {\n    // SET 4,register 8-bit\n    // - - - -\n    instructionRegisterResult = setBitOnRegister(4, 1, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0xEF) {\n    // SET 5,register 8-bit\n    // - - - -\n    instructionRegisterResult = setBitOnRegister(5, 1, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0xF7) {\n    // SET 6,register 8-bit\n    // - - - -\n    instructionRegisterResult = setBitOnRegister(6, 1, instructionRegisterValue);\n    handledOpcode = true;\n  } else if (cbOpcode <= 0xFF) {\n    // SET 7,register 8-bit\n    // - - - -\n    instructionRegisterResult = setBitOnRegister(7, 1, instructionRegisterValue);\n    handledOpcode = true;\n  }\n\n  // Finally Pass back into the correct register\n  if(registerNumber === 0) {\n    Cpu.registerB = instructionRegisterResult;\n  } else if (registerNumber === 1) {\n    Cpu.registerC = instructionRegisterResult;\n  } else if (registerNumber === 2) {\n    Cpu.registerD = instructionRegisterResult;\n  } else if (registerNumber === 3) {\n    Cpu.registerE = instructionRegisterResult;\n  } else if (registerNumber === 4) {\n    Cpu.registerH = instructionRegisterResult;\n  } else if (registerNumber === 5) {\n    Cpu.registerL = instructionRegisterResult;\n  } else if (registerNumber === 6) {\n    // Value at register HL\n    eightBitStoreIntoGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL), instructionRegisterResult);\n  } else if (registerNumber === 7) {\n    Cpu.registerA = instructionRegisterResult;\n  }\n\n  // Increase program counter, as all CB codes take two bytes\n  // Program counter will really increase by two since opcodes handles the other\n  Cpu.programCounter += 1;\n\n  // Finally our number of cycles\n  // Set if we handled the opcode\n  if (handledOpcode) {\n    // Next if register number was 6 (HL), number of cycles is 16\n    if(registerNumber === 6) {\n      numberOfCycles = 16\n    } else {\n      numberOfCycles = 8;\n    }\n  }\n\n  // Return our number of cycles\n  return numberOfCycles;\n}\n","import {\n  Cpu\n} from '../cpu/index';\nimport {\n  eightBitLoadFromGBMemory,\n  eightBitStoreIntoGBMemorySkipTraps,\n  sixteenBitStoreIntoGBMemorySkipTraps,\n  getSaveStateMemoryOffset,\n  loadBooleanDirectlyFromWasmMemory,\n  storeBooleanDirectlyToWasmMemory\n} from '../memory/index';\nimport {\n  setBitOnByte,\n  resetBitOnByte,\n  checkBitOnByte,\n  hexLog\n} from '../helpers/index';\n\nexport class Interrupts {\n  static memoryLocationInterruptEnabled: u16 = 0xFFFF;\n  static memoryLocationInterruptRequest: u16 = 0xFF0F; // A.K.A interrupt Flag (IF)\n\n  static masterInterruptSwitch: boolean = false;\n  // According to mooneye, interrupts are not handled until AFTER\n  // Next instruction\n  // https://github.com/Gekkio/mooneye-gb/blob/master/docs/accuracy.markdown\n  static masterInterruptSwitchDelay: boolean = false;\n\n  static bitPositionVBlankInterrupt: u8 = 0;\n  static bitPositionLcdInterrupt: u8 = 1;\n  static bitPositionTimerInterrupt: u8 = 2;\n  static bitPositionJoypadInterrupt: u8 = 4;\n\n  // Save States\n\n  static saveStateSlot: u16 = 2;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x00, Interrupts.saveStateSlot), Interrupts.masterInterruptSwitch);\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x01, Interrupts.saveStateSlot), Interrupts.masterInterruptSwitchDelay);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    Interrupts.masterInterruptSwitch = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x00, Interrupts.saveStateSlot));\n    Interrupts.masterInterruptSwitchDelay = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x01, Interrupts.saveStateSlot));\n  }\n}\n\nfunction _handleInterrupt(bitPosition: u8): void {\n\n  // Disable the master switch\n  setInterrupts(false);\n\n  // Disable the bit on the interruptRequest\n  let interruptRequest = eightBitLoadFromGBMemory(Interrupts.memoryLocationInterruptRequest);\n  interruptRequest = resetBitOnByte(bitPosition, interruptRequest);\n  eightBitStoreIntoGBMemorySkipTraps(Interrupts.memoryLocationInterruptRequest, interruptRequest);\n\n  // Push the programCounter onto the stacks\n  Cpu.stackPointer = Cpu.stackPointer - 2;\n  sixteenBitStoreIntoGBMemorySkipTraps(Cpu.stackPointer, Cpu.programCounter);\n\n  // Jump to the correct interrupt location\n  // http://www.codeslinger.co.uk/pages/projects/gameboy/interupts.html\n  if (bitPosition === Interrupts.bitPositionVBlankInterrupt) {\n    Cpu.programCounter = 0x40;\n  } else if(bitPosition === Interrupts.bitPositionLcdInterrupt) {\n    //hexLog(2, 1, 6);\n    Cpu.programCounter = 0x48;\n  } else if(bitPosition === Interrupts.bitPositionTimerInterrupt) {\n    Cpu.programCounter = 0x50;\n  } else if(bitPosition === Interrupts.bitPositionJoypadInterrupt) {\n    // JoyPad\n    Cpu.programCounter = 0x60;\n  }\n\n  // If the CPU was halted, now is the time to un-halt\n  // Should be done here when the jump occurs according to:\n  // https://www.reddit.com/r/EmuDev/comments/6fmjch/gb_glitches_in_links_awakening_and_pok%C3%A9mon_gold/\n  Cpu.isHalted = false;\n}\n\nfunction _requestInterrupt(bitPosition: u8): void {\n\n  let interruptRequest = eightBitLoadFromGBMemory(Interrupts.memoryLocationInterruptRequest);\n\n  // Pass to set the correct interrupt bit on interruptRequest\n  interruptRequest = setBitOnByte(bitPosition, interruptRequest);\n\n  eightBitStoreIntoGBMemorySkipTraps(Interrupts.memoryLocationInterruptRequest, interruptRequest);\n}\n\nexport function setInterrupts(value: boolean): void {\n  Interrupts.masterInterruptSwitch = value;\n}\n\n// Helper function to check if interrupts are enabled\nexport function areInterruptsEnabled(): boolean {\n  return Interrupts.masterInterruptSwitch;\n}\n\n// Useful fo determining the HALT bug\nexport function areInterruptsPending(): boolean {\n  let interruptRequest = eightBitLoadFromGBMemory(Interrupts.memoryLocationInterruptRequest);\n  let interruptEnabled = eightBitLoadFromGBMemory(Interrupts.memoryLocationInterruptEnabled);\n\n  if((interruptRequest & interruptEnabled) !== 0) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Helper function to get if interrupts are pending but the switch is not set\n\nexport function checkInterrupts(): i8 {\n\n  // Boolean to track if interrupts were handled\n  // Interrupt handling requires 20 cycles\n  // https://github.com/Gekkio/mooneye-gb/blob/master/docs/accuracy.markdown#what-is-the-exact-timing-of-cpu-servicing-an-interrupt\n  let wasInterruptHandled: boolean = false;\n\n  if(Interrupts.masterInterruptSwitch) {\n\n    let interruptRequest = eightBitLoadFromGBMemory(Interrupts.memoryLocationInterruptRequest);\n    let interruptEnabled = eightBitLoadFromGBMemory(Interrupts.memoryLocationInterruptEnabled);\n\n    if(interruptRequest > 0) {\n\n      // Check our interrupts\n      if (checkBitOnByte(Interrupts.bitPositionVBlankInterrupt, interruptRequest) &&\n        checkBitOnByte(Interrupts.bitPositionVBlankInterrupt, interruptEnabled)) {\n\n        _handleInterrupt(Interrupts.bitPositionVBlankInterrupt);\n        wasInterruptHandled = true;\n      } else if (checkBitOnByte(Interrupts.bitPositionLcdInterrupt, interruptRequest) &&\n        checkBitOnByte(Interrupts.bitPositionLcdInterrupt, interruptEnabled)) {\n\n          _handleInterrupt(Interrupts.bitPositionLcdInterrupt);\n          wasInterruptHandled = true;\n      } else if (checkBitOnByte(Interrupts.bitPositionTimerInterrupt, interruptRequest) &&\n        checkBitOnByte(Interrupts.bitPositionTimerInterrupt, interruptEnabled)) {\n\n          _handleInterrupt(Interrupts.bitPositionTimerInterrupt);\n          wasInterruptHandled = true;\n      } else if (checkBitOnByte(Interrupts.bitPositionJoypadInterrupt, interruptRequest) &&\n        checkBitOnByte(Interrupts.bitPositionJoypadInterrupt, interruptEnabled)) {\n\n          _handleInterrupt(Interrupts.bitPositionJoypadInterrupt);\n          wasInterruptHandled = true;\n      }\n    }\n  }\n\n  // Interrupt handling requires 20 cycles\n  if(wasInterruptHandled) {\n    return 20;\n  } else {\n    return 0;\n  }\n}\n\nexport function requestVBlankInterrupt(): void {\n  _requestInterrupt(Interrupts.bitPositionVBlankInterrupt);\n}\n\nexport function requestLcdInterrupt(): void {\n  _requestInterrupt(Interrupts.bitPositionLcdInterrupt);\n}\n\nexport function requestTimerInterrupt(): void {\n  _requestInterrupt(Interrupts.bitPositionTimerInterrupt);\n}\n\nexport function requestJoypadInterrupt(): void {\n  _requestInterrupt(Interrupts.bitPositionJoypadInterrupt);\n}\n","import {\n  Cpu\n} from '../cpu/index';\nimport {\n  eightBitLoadFromGBMemory,\n  eightBitStoreIntoGBMemorySkipTraps,\n  getSaveStateMemoryOffset,\n  loadBooleanDirectlyFromWasmMemory,\n  storeBooleanDirectlyToWasmMemory\n} from '../memory/index';\nimport {\n  requestTimerInterrupt\n} from '../interrupts/index';\n\nexport class Timers {\n  static memoryLocationTIMA: u16 = 0xFF05; // Timer Modulator\n  static memoryLocationTMA: u16 = 0xFF06; // Timer Counter (Actual Time Value)\n  static memoryLocationTIMC: u16 = 0xFF07; // Timer Controller (A.K.A TAC)\n  static memoryLocationDividerRegister: u16 = 0xFF04; // DividerRegister likes to count\n\n  // Cycle counter. This is used to determine if we should increment the REAL timer\n  // I know this is weird, but it's all to make sure the emulation is in sync :p\n  static cycleCounter: i16 = 0x00;\n  static currentMaxCycleCount: i16 = 1024;\n\n  // Another timer, that doesn't fire intterupts, but jsut counts to 255, and back to zero :p\n  static dividerRegisterCycleCounter: i16 = 0x00;\n\n  // Save States\n\n  static saveStateSlot: u16 = 5;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    store<i16>(getSaveStateMemoryOffset(0x00, Timers.saveStateSlot), Timers.cycleCounter);\n    store<i16>(getSaveStateMemoryOffset(0x02, Timers.saveStateSlot), Timers.currentMaxCycleCount);\n    store<i16>(getSaveStateMemoryOffset(0x04, Timers.saveStateSlot), Timers.dividerRegisterCycleCounter);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    Timers.cycleCounter = load<i16>(getSaveStateMemoryOffset(0x00, Timers.saveStateSlot));\n    Timers.currentMaxCycleCount = load<i16>(getSaveStateMemoryOffset(0x02, Timers.saveStateSlot));\n    Timers.dividerRegisterCycleCounter = load<i16>(getSaveStateMemoryOffset(0x04, Timers.saveStateSlot));\n  }\n}\n\nexport function updateTimers(numberOfCycles: u8): void {\n\n  _checkDividerRegister(numberOfCycles);\n\n  if(_isTimerEnabled()) {\n\n    // Add our cycles our cycle counter\n    Timers.cycleCounter += numberOfCycles;\n\n    if(Timers.cycleCounter > _getCurrentCycleCounterFrequency()) {\n\n      // Reset our cycle counters\n      // Not setting to zero as we do not want to drop cycles\n      Timers.cycleCounter -= _getCurrentCycleCounterFrequency();\n\n      // Update the actual timer counter\n      let tima = eightBitLoadFromGBMemory(Timers.memoryLocationTIMA);\n      if(tima == 255) {\n        // Store Timer Modulator inside of TIMA\n        eightBitStoreIntoGBMemorySkipTraps(Timers.memoryLocationTIMA, eightBitLoadFromGBMemory(Timers.memoryLocationTMA));\n        // Fire off timer interrupt\n        requestTimerInterrupt();\n      } else {\n        eightBitStoreIntoGBMemorySkipTraps(Timers.memoryLocationTIMA, tima + 1);\n      }\n    }\n  }\n}\n\n// Function to update our divider register\nfunction _checkDividerRegister(numberOfCycles: u8): void {\n  // CLOCK_SPEED / 16382\n\n  // Every 256 clock cycles need to increment\n  Timers.dividerRegisterCycleCounter += numberOfCycles;\n\n  if(Timers.dividerRegisterCycleCounter >= 255) {\n\n    // Reset the cycle counter\n    // - 255 to catch any overflow with the cycles\n    Timers.dividerRegisterCycleCounter -= 255;\n\n    let dividerRegister = eightBitLoadFromGBMemory(Timers.memoryLocationDividerRegister);\n    if(dividerRegister === 255) {\n      dividerRegister = 0;\n    } else {\n      dividerRegister += 1;\n    }\n    eightBitStoreIntoGBMemorySkipTraps(Timers.memoryLocationDividerRegister, dividerRegister);\n  }\n}\n\nfunction _isTimerEnabled(): boolean {\n  // second bit, e.g 000 0100, will be set if the timer is enabled\n  let timc = eightBitLoadFromGBMemory(Timers.memoryLocationTIMC);\n  if((timc & 0x04) > 0) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// NOTE: This can be sped up by intercepting writes to memory\n// And handling this there\nfunction _getCurrentCycleCounterFrequency(): i16 {\n\n  // Get TIMC\n  let timc = eightBitLoadFromGBMemory(Timers.memoryLocationTIMC);\n\n  // Clear the top byte\n  timc = timc & 0x03;\n\n  // Returns value equivalent to\n  // Cpu.CLOCK_SPEED / timc frequency\n  let cycleCount = 0;\n  if(timc === 0x00) {\n    // TIMC -> 4096\n    cycleCount = 1024;\n  } else if (timc === 0x01) {\n    // TIMC -> 262144\n    cycleCount = 16;\n  } else if (timc === 0x02) {\n    // TIMC -> 65536\n    cycleCount = 64;\n  } else {\n    // TIMC -> 16382\n    cycleCount = 256\n  }\n\n  // If we notice the current max cycle count changes, reset the cyclecounter\n  if(cycleCount != Timers.currentMaxCycleCount) {\n    Timers.cycleCounter = 0;\n    Timers.currentMaxCycleCount = <i16>cycleCount;\n  }\n\n  return <i16>cycleCount;\n}\n","// Funcitons for setting and checking the LCD\nimport {\n  Graphics\n} from './graphics';\n// Assembly script really not feeling the reexport\nimport {\n  eightBitLoadFromGBMemory\n} from '../memory/load';\nimport {\n  eightBitStoreIntoGBMemorySkipTraps\n} from '../memory/store';\nimport {\n  requestLcdInterrupt\n} from '../interrupts/index';\nimport {\n  checkBitOnByte,\n  setBitOnByte,\n  resetBitOnByte,\n  hexLog\n} from '../helpers/index';\n\n\n\nexport function isLcdEnabled(): boolean {\n  return checkBitOnByte(7, eightBitLoadFromGBMemory(Graphics.memoryLocationLcdControl));\n}\n\nexport function setLcdStatus(): void {\n  // LCD Status (0xFF41) bits Explanation\n  // 0                0                    000                    0             00\n  //       |Coicedence Interrupt|     |Mode Interrupts|  |coincidence flag|    | Mode |\n  // Modes:\n  // 0 or 00: H-Blank\n  // 1 or 01: V-Blank\n  // 2 or 10: Searching Sprites Atts\n  // 3 or 11: Transfering Data to LCD Driver\n\n  let lcdStatus: u8 = eightBitLoadFromGBMemory(Graphics.memoryLocationLcdStatus);\n  if(!isLcdEnabled()) {\n    // Reset scanline cycle counter\n    Graphics.scanlineCycleCounter = 0;\n    eightBitStoreIntoGBMemorySkipTraps(Graphics.memoryLocationScanlineRegister, 0);\n\n    // Set to mode 0\n    // https://www.reddit.com/r/EmuDev/comments/4w6479/gb_dr_mario_level_generation_issues/\n    lcdStatus = resetBitOnByte(1, lcdStatus);\n    lcdStatus = resetBitOnByte(0, lcdStatus);\n    Graphics.currentLcdMode = 0;\n\n    // Store the status in memory\n    eightBitStoreIntoGBMemorySkipTraps(Graphics.memoryLocationLcdStatus, lcdStatus);\n    return;\n  }\n\n  // Get our current scanline, and lcd mode\n  let scanlineRegister: u8 = eightBitLoadFromGBMemory(Graphics.memoryLocationScanlineRegister);\n  let lcdMode: u8 = lcdStatus & 0x03;\n\n  let newLcdMode: u8 = 0;\n  let shouldRequestInterrupt: boolean = false;\n\n  // Find our newLcd mode\n  if(scanlineRegister >= 144) {\n    // VBlank mode\n    newLcdMode = 1;\n    lcdStatus = resetBitOnByte(1, lcdStatus);\n    lcdStatus = setBitOnByte(0, lcdStatus);\n    shouldRequestInterrupt = checkBitOnByte(4, lcdStatus);\n  } else {\n    if (Graphics.scanlineCycleCounter >= Graphics.MIN_CYCLES_SPRITES_LCD_MODE) {\n      // Searching Sprites Atts\n      newLcdMode = 2;\n      lcdStatus = resetBitOnByte(0, lcdStatus);\n      lcdStatus = setBitOnByte(1, lcdStatus);\n      shouldRequestInterrupt = checkBitOnByte(5, lcdStatus);\n    } else if (Graphics.scanlineCycleCounter >= Graphics.MIN_CYCLES_TRANSFER_DATA_LCD_MODE) {\n      // Transferring data to lcd\n      newLcdMode = 3;\n      lcdStatus = setBitOnByte(0, lcdStatus);\n      lcdStatus = setBitOnByte(1, lcdStatus);\n    } else {\n      // H-Blank\n      newLcdMode = 0;\n      lcdStatus = resetBitOnByte(0, lcdStatus);\n      lcdStatus = resetBitOnByte(1, lcdStatus);\n      shouldRequestInterrupt = checkBitOnByte(3, lcdStatus);\n    }\n  }\n\n  // Check if we want to request an interrupt, and we JUST changed modes\n  if(shouldRequestInterrupt && (lcdMode !== newLcdMode)) {\n    requestLcdInterrupt();\n  }\n\n  // Check for the coincidence flag\n  if(lcdMode !== newLcdMode && newLcdMode === 0 && eightBitLoadFromGBMemory(Graphics.memoryLocationScanlineRegister) === eightBitLoadFromGBMemory(Graphics.memoryLocationCoincidenceCompare)) {\n    lcdStatus = setBitOnByte(2, lcdStatus);\n    if(checkBitOnByte(6, lcdStatus)) {\n      requestLcdInterrupt();\n    }\n  } else {\n    lcdStatus = resetBitOnByte(2, lcdStatus);\n  }\n\n  // Save our lcd mode\n  Graphics.currentLcdMode = newLcdMode;\n\n  // Finally, save our status\n  eightBitStoreIntoGBMemorySkipTraps(Graphics.memoryLocationLcdStatus, lcdStatus);\n}\n","// Functions for rendering the background\nimport {\n  Graphics\n} from './graphics';\nimport {\n  getTileDataAddress,\n  getColorFromPalette\n} from './renderUtils'\n// Assembly script really not feeling the reexport\n// using Skip Traps, because LCD has unrestricted access\n// http://gbdev.gg8.se/wiki/articles/Video_Display#LCD_OAM_DMA_Transfers\nimport {\n  eightBitLoadFromGBMemorySkipTraps\n} from '../memory/load';\nimport {\n  setPixelOnFrame\n} from '../memory/memory';\nimport {\n  hexLog,\n  checkBitOnByte,\n  setBitOnByte,\n  resetBitOnByte\n} from '../helpers/index';\n\nexport function renderBackground(scanlineRegister: u8, tileDataMemoryLocation: u16, tileMapMemoryLocation: u16): void {\n\n  // NOTE: Camera is reffering to what you can see inside the 160x144 viewport of the entire rendered 256x256 map.\n\n  // Get our scrollX and scrollY (u16 to play nice with assemblyscript)\n  let scrollX: u16 = <u16>eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationScrollX);\n  let scrollY: u16 = <u16>eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationScrollY);\n\n  // Get our current pixel y positon on the 160x144 camera (Row that the scanline draws across)\n  // this is done by getting the current scroll Y position,\n  // and adding it do what Y Value the scanline is drawing on the camera.\n  let pixelYPositionInMap: u16 = <u16>scanlineRegister + scrollY;\n\n  // Gameboy camera will \"wrap\" around the background map,\n  // meaning that if the pixelValue is 350, then we need to subtract 256 (decimal) to get it's actual value\n  // pixel values (scrollX and scrollY) range from 0x00 - 0xFF\n  if(pixelYPositionInMap >= 0x100) {\n    pixelYPositionInMap -= 0x100;\n  }\n\n  // Loop through x to draw the line like a CRT\n  for (let i: u16 = 0; i < 160; i++) {\n\n    // Get our Current X position of our pixel on the on the 160x144 camera\n    // this is done by getting the current scroll X position,\n    // and adding it do what X Value the scanline is drawing on the camera.\n    let pixelXPositionInMap: u16 = i + scrollX;\n\n    // This is to compensate wrapping, same as above\n    if(pixelXPositionInMap >= 0x100) {\n      pixelXPositionInMap -= 0x100;\n    }\n\n    // Divide our pixel position by 8 to get our tile.\n    // Since, there are 256x256 pixels, and 32x32 tiles.\n    // 256 / 8 = 32.\n    // Also, bitshifting by 3, do do a division by 8\n    // Need to use u16s, as they will be used to compute an address, which will cause weird errors and overflows\n    let tileXPositionInMap: u16 = pixelXPositionInMap >> 3;\n    let tileYPositionInMap: u16 = pixelYPositionInMap >> 3;\n\n\n    // Get our tile address on the tileMap\n    // NOTE: (tileMap represents where each tile is displayed on the screen)\n    // NOTE: (tile map represents the entire map, now just what is within the \"camera\")\n    // For instance, if we have y pixel 144. 144 / 8 = 18. 18 * 32 = line address in map memory.\n    // And we have x pixel 160. 160 / 8 = 20.\n    // * 32, because remember, this is NOT only for the camera, the actual map is 32x32. Therefore, the next tile line of the map, is 32 byte offset.\n    // Think like indexing a 2d array, as a 1d array and it make sense :)\n    let tileMapAddress: u16 = tileMapMemoryLocation + (tileYPositionInMap * 32) + tileXPositionInMap;\n\n    // Get the tile Id on the Tile Map\n    let tileIdFromTileMap: u8 = eightBitLoadFromGBMemorySkipTraps(tileMapAddress);\n\n    // Now get our tileDataAddress for the corresponding tileID we found in the map\n    // Read the comments in _getTileDataAddress() to see what's going on.\n    // tl;dr if we had the tile map of \"a b c d\", and wanted tileId 2.\n    // This funcitons returns the start of memory locaiton for the tile 'c'.\n    let tileDataAddress: u16 = getTileDataAddress(tileDataMemoryLocation, tileIdFromTileMap);\n\n    // Now we can process the the individual bytes that represent the pixel on a tile\n\n    // Get the y pixel of the 8 by 8 tile.\n    // Simply modulo the scanline.\n    // For instance, let's say we are printing the first line of pixels on our camera,\n    // And the first line of pixels on our tile.\n    // yPixel = 1. 1 % 8 = 1.\n    // And for the last line\n    // yPixel = 144. 144 % 8 = 0.\n    // 0 Represents last line of pixels in a tile, 1 represents first. 1 2 3 4 5 6 7 0.\n    // Because remember, we are counting lines on the display NOT including zero\n    let pixelYInTile: u16 = pixelYPositionInMap % 8;\n    // Remember to represent a single line of 8 pixels on a tile, we need two bytes.\n    // Therefore, we need to times our modulo by 2, to get the correct line of pixels on the tile.\n    // Again, think like you had to map a 2d array as a 1d.\n    let byteOneForLineOfTilePixels: u8 = eightBitLoadFromGBMemorySkipTraps(tileDataAddress + (pixelYInTile * 2))\n    let byteTwoForLineOfTilePixels: u8 = eightBitLoadFromGBMemorySkipTraps(tileDataAddress + (pixelYInTile * 2) + 1);\n\n    // Same logic as pixelYInTile.\n    // However, We need to reverse our byte,\n    // As pixel 0 is on byte 7, and pixel 1 is on byte 6, etc...\n    // Therefore, is pixelX was 2, then really is need to be 5\n    // So 2 - 7 = -5, * 1 = 5\n    let reversedPixelXInTile: i16 = <i16>pixelXPositionInMap % 8;\n    let pixelXInTile: u8 = <u8>((reversedPixelXInTile - 7) * -1);\n\n    // Now we can get the color for that pixel\n    // Colors are represented by getting X position of ByteTwo, and X positon of Byte One\n    // To Get the color Id.\n    // For example, the result of the color id is 0000 00[xPixelByteTwo][xPixelByteOne]\n    // See: How to draw a tile/sprite from memory: http://www.codeslinger.co.uk/pages/projects/gameboy/graphics.html\n    let paletteColorId: u8 = 0;\n    if (checkBitOnByte(<u8>pixelXInTile, byteTwoForLineOfTilePixels)) {\n      // Byte one represents the second bit in our color id, so bit shift\n      paletteColorId += 1;\n      paletteColorId = (paletteColorId << 1);\n    }\n    if (checkBitOnByte(<u8>pixelXInTile, byteOneForLineOfTilePixels)) {\n      paletteColorId += 1;\n    }\n\n    // Now get the colorId from the pallete, to get our final color\n    // Developers could change colorIds to represents different colors\n    // in their palette, thus we need to grab the color from there\n    let pixelColorInTileFromPalette: u8 = getColorFromPalette(paletteColorId, Graphics.memoryLocationBackgroundPalette);\n\n    // FINALLY, RENDER THAT PIXEL!\n    // Only rendering camera for now, so coordinates are for the camera.\n    setPixelOnFrame(i, scanlineRegister, pixelColorInTileFromPalette);\n  }\n}\n","// utility funcitons to help in rendering\nimport {\n  Graphics\n} from './graphics';\n// Assembly script really not feeling the reexport\n// using Skip Traps, because LCD has unrestricted access\n// http://gbdev.gg8.se/wiki/articles/Video_Display#LCD_OAM_DMA_Transfers\nimport {\n  eightBitLoadFromGBMemorySkipTraps\n} from '../memory/load';\nimport {\n  checkBitOnByte,\n  setBitOnByte,\n  resetBitOnByte\n} from '../helpers/index';\n\nexport function getTileDataAddress(tileDataMemoryLocation: u16, tileIdFromTileMap: u8): u16 {\n\n  // Watch this part of The ultimate gameboy talk: https://youtu.be/HyzD8pNlpwI?t=30m50s\n  // A line of 8 pixels on a single tile, is represented by 2 bytes.\n  // since a single tile is 8x8 pixels, 8 * 2 = 16 bytes\n  let sizeOfTileInMemory: u8 = 16;\n  let tileDataAddress: u16 = 0;\n\n  // Get the tile ID's tile addess from tile data.\n  // For instance, let's say our first line of tile data represents tiles for letters:\n  // a b c d e f g\n  // And we have tileId 0x02. That means we want the tile for the 'c' character\n  // Since each tile is 16 bytes, it would be the starting tileDataAddress + (tileId * tileSize), to skip over tiles we dont want\n  // The whole signed thing is weird, and has something to do how the second set of tile data is stored :p\n  if(tileDataMemoryLocation === Graphics.memoryLocationTileDataSelectZeroStart) {\n    // Treat the tile Id as a signed int, subtract an offset of 128\n    // if the tileId was 0 then the tile would be in memory region 0x9000-0x900F\n    // NOTE: Assemblyscript, Can't cast to i16, need to make negative manually\n    let convertedTileIdFromTileMap = <i16>tileIdFromTileMap;\n    let signedTileId: i16 = tileIdFromTileMap + 128;\n    if (checkBitOnByte(7, tileIdFromTileMap)) {\n      signedTileId = convertedTileIdFromTileMap - 128;\n    }\n    let tileIdAddress: i16 = signedTileId * sizeOfTileInMemory;\n    tileDataAddress = tileDataMemoryLocation + <u16>tileIdAddress;\n  } else {\n    // if the background layout gave us the tileId 0, then the tile data would be between 0x8000-0x800F.\n    let sixteenBitTileIdFromTileMap: u16 = <u16>tileIdFromTileMap;\n    tileDataAddress = tileDataMemoryLocation + <u16>(sixteenBitTileIdFromTileMap * sizeOfTileInMemory);\n  }\n\n  return tileDataAddress;\n}\n\n// TODO: Make not specifc to a single palette\nexport function getColorFromPalette(colorId: u8, paletteMemoryLocation: u16): u8 {\n  let paletteByte: u8 = eightBitLoadFromGBMemorySkipTraps(paletteMemoryLocation);\n  let color: u8 = 0;\n\n  // Shift our paletteByte, 2 times for each color ID\n  paletteByte = (paletteByte >> (colorId * 2));\n\n  // And off any extra bytes\n  paletteByte = paletteByte & 0x03;\n\n  // Return our Color (00, 01, 10, or 11)\n  return paletteByte;\n}\n","// Functions for rendering the window, very similar to renderBackground()\nimport {\n  Graphics\n} from './graphics';\nimport {\n  getTileDataAddress,\n  getColorFromPalette\n} from './renderUtils'\n// Assembly script really not feeling the reexport\n// using Skip Traps, because LCD has unrestricted access\n// http://gbdev.gg8.se/wiki/articles/Video_Display#LCD_OAM_DMA_Transfers\nimport {\n  eightBitLoadFromGBMemorySkipTraps\n} from '../memory/load';\nimport {\n  setPixelOnFrame\n} from '../memory/memory';\nimport {\n  checkBitOnByte,\n  setBitOnByte,\n  resetBitOnByte\n} from '../helpers/index';\n\nexport function renderWindow(scanlineRegister: u8, tileDataMemoryLocation: u16, tileMapMemoryLocation: u16): void {\n\n  // Get our windowX and windowY\n  let windowX: u16 = <u16>eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationWindowX);\n  let windowY: u16 = <u16>eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationWindowY);\n\n  // NOTE: Camera is reffering to what you can see inside the 160x144 viewport of the entire rendered 256x256 map.\n\n  // First ensure that the scanline is greater than our window\n  if(scanlineRegister < <u8>windowY) {\n    // Window is not within the current camera view\n    return;\n  }\n\n  // WindowX is offset by 7\n  windowX = windowX - 7;\n\n  // Get our current pixel y positon on the 160x144 camera (Row that the scanline draws across)\n  let pixelYPositionInMap: u16 = <u16>scanlineRegister - windowY;\n\n  // Loop through x to draw the line like a CRT\n  for (let i: u16 = windowX; i < 160; i++) {\n\n    // Get our Current X position of our pixel on the on the 160x144 camera\n    let pixelXPositionInMap: u16 = i - windowX;\n\n    // This is to compensate wrapping, same as above\n    if(pixelXPositionInMap >= 0x100) {\n      pixelXPositionInMap -= 0x100;\n    }\n\n    // Divide our pixel position by 8 to get our tile.\n    // Since, there are 256x256 pixels, and 32x32 tiles.\n    // 256 / 8 = 32.\n    // Also, bitshifting by 3, do do a division by 8\n    // Need to use u16s, as they will be used to compute an address, which will cause weird errors and overflows\n    let tileXPositionInMap: u16 = pixelXPositionInMap >> 3;\n    let tileYPositionInMap: u16 = pixelYPositionInMap >> 3;\n\n\n    // Get our tile address on the tileMap\n    // NOTE: (tileMap represents where each tile is displayed on the screen)\n    // NOTE: (tile map represents the entire map, now just what is within the \"camera\")\n    // For instance, if we have y pixel 144. 144 / 8 = 18. 18 * 32 = line address in map memory.\n    // And we have x pixel 160. 160 / 8 = 20.\n    // * 32, because remember, this is NOT only for the camera, the actual map is 32x32. Therefore, the next tile line of the map, is 32 byte offset.\n    // Think like indexing a 2d array, as a 1d array and it make sense :)\n    let tileMapAddress: u16 = tileMapMemoryLocation + (tileYPositionInMap * 32) + tileXPositionInMap;\n\n    // Get the tile Id on the Tile Map\n    let tileIdFromTileMap: u8 = eightBitLoadFromGBMemorySkipTraps(tileMapAddress);\n\n    // Now get our tileDataAddress for the corresponding tileID we found in the map\n    // Read the comments in _getTileDataAddress() to see what's going on.\n    // tl;dr if we had the tile map of \"a b c d\", and wanted tileId 2.\n    // This funcitons returns the start of memory locaiton for the tile 'c'.\n    let tileDataAddress: u16 = getTileDataAddress(tileDataMemoryLocation, tileIdFromTileMap);\n\n    // Now we can process the the individual bytes that represent the pixel on a tile\n\n    // Get the y pixel of the 8 by 8 tile.\n    // Simply modulo the scanline.\n    // For instance, let's say we are printing the first line of pixels on our camera,\n    // And the first line of pixels on our tile.\n    // yPixel = 1. 1 % 8 = 1.\n    // And for the last line\n    // yPixel = 144. 144 % 8 = 0.\n    // 0 Represents last line of pixels in a tile, 1 represents first. 1 2 3 4 5 6 7 0.\n    // Because remember, we are counting lines on the display NOT including zero\n    let pixelYInTile: u16 = pixelYPositionInMap % 8;\n    // Remember to represent a single line of 8 pixels on a tile, we need two bytes.\n    // Therefore, we need to times our modulo by 2, to get the correct line of pixels on the tile.\n    // Again, think like you had to map a 2d array as a 1d.\n    let byteOneForLineOfTilePixels: u8 = eightBitLoadFromGBMemorySkipTraps(tileDataAddress + (pixelYInTile * 2))\n    let byteTwoForLineOfTilePixels: u8 = eightBitLoadFromGBMemorySkipTraps(tileDataAddress + (pixelYInTile * 2) + 1);\n\n    // Same logic as pixelYInTile.\n    // However, We need to reverse our byte,\n    // As pixel 0 is on byte 7, and pixel 1 is on byte 6, etc...\n    // Therefore, is pixelX was 2, then really is need to be 5\n    // So 2 - 7 = -5, * 1 = 5\n    let reversedPixelXInTile: i16 = <i16>pixelXPositionInMap % 8;\n    let pixelXInTile: u8 = <u8>((reversedPixelXInTile - 7) * -1);\n\n    // Now we can get the color for that pixel\n    // Colors are represented by getting X position of ByteTwo, and X positon of Byte One\n    // To Get the color Id.\n    // For example, the result of the color id is 0000 00[xPixelByteTwo][xPixelByteOne]\n    // See: How to draw a tile/sprite from memory: http://www.codeslinger.co.uk/pages/projects/gameboy/graphics.html\n    let paletteColorId: u8 = 0;\n    if (checkBitOnByte(<u8>pixelXInTile, byteTwoForLineOfTilePixels)) {\n      // Byte one represents the second bit in our color id, so bit shift\n      paletteColorId += 1;\n      paletteColorId = (paletteColorId << 1);\n    }\n    if (checkBitOnByte(<u8>pixelXInTile, byteOneForLineOfTilePixels)) {\n      paletteColorId += 1;\n    }\n\n    // Now get the colorId from the pallete, to get our final color\n    // Developers could change colorIds to represents different colors\n    // in their palette, thus we need to grab the color from there\n    let pixelColorInTileFromPalette: u8 = getColorFromPalette(paletteColorId, Graphics.memoryLocationBackgroundPalette);\n\n    // FINALLY, RENDER THAT PIXEL!\n    // Only rendering camera for now, so coordinates are for the camera.\n    setPixelOnFrame(i, scanlineRegister, pixelColorInTileFromPalette);\n  }\n}\n","// Functions for rendering the sprites\nimport {\n  Graphics\n} from './graphics';\nimport {\n  getTileDataAddress,\n  getColorFromPalette\n} from './renderUtils'\n// Assembly script really not feeling the reexport\n// using Skip Traps, because LCD has unrestricted access\n// http://gbdev.gg8.se/wiki/articles/Video_Display#LCD_OAM_DMA_Transfers\nimport {\n  eightBitLoadFromGBMemorySkipTraps\n} from '../memory/load';\nimport {\n  setPixelOnFrame,\n  getPixelOnFrame\n} from '../memory/memory';\nimport {\n  checkBitOnByte,\n  setBitOnByte,\n  resetBitOnByte\n} from '../helpers/index';\n\nexport function renderSprites(scanlineRegister: u8, useLargerSprites: boolean): void {\n\n  // Need to loop through all 40 sprites to check their status\n  for(let i: u16 = 0; i < 40; i++) {\n\n    // Sprites occupy 4 bytes in the sprite attribute table\n    let spriteTableIndex: u16 = i * 4;\n    // Y positon is offset by 16, X position is offset by 8\n    // TODO: Why is OAM entry zero???\n    let spriteYPosition: u8 = eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationSpriteAttributesTable + spriteTableIndex);\n    spriteYPosition -= 16;\n    let spriteXPosition: u8 = eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationSpriteAttributesTable + spriteTableIndex + 1);\n    spriteXPosition -= 8;\n    let spriteTileId: u8 = eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationSpriteAttributesTable + spriteTableIndex + 2);\n    let spriteAttributes: u8 = eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationSpriteAttributesTable + spriteTableIndex + 3);\n\n    // Check sprite Priority\n    let isSpritePriorityBehindWindowAndBackground: boolean = checkBitOnByte(7, spriteAttributes);\n\n    // Check if we should flip the sprite on the x or y axis\n    let flipSpriteY: boolean = checkBitOnByte(6, spriteAttributes);\n    let flipSpriteX: boolean = checkBitOnByte(5, spriteAttributes);\n\n    // Get our sprite pallete\n    let spritePaletteLocation: u16 = Graphics.memoryLocationSpritePaletteOne;\n    if (checkBitOnByte(4, spriteAttributes)) {\n      spritePaletteLocation = Graphics.memoryLocationSpritePaletteTwo;\n    }\n\n    // Find our sprite height\n    let spriteHeight: u8 = 8;\n    if(useLargerSprites) {\n      spriteHeight = 16;\n    }\n\n    // Find if our sprite is on the current scanline\n    if(scanlineRegister >= spriteYPosition && scanlineRegister < (spriteYPosition + spriteHeight)) {\n      // Then we need to draw the current sprite\n\n      // Find which line on the sprite we are on\n      let currentSpriteLine: i16 = scanlineRegister - spriteYPosition;\n\n      // If we fliiped the Y axis on our sprite, need to read from memory backwards to acheive the same effect\n      if(flipSpriteY) {\n        currentSpriteLine -= <i16>spriteHeight;\n        currentSpriteLine = currentSpriteLine * -1;\n      }\n      // Each line of a tile takes two bytes of memory\n      currentSpriteLine = currentSpriteLine * 2;\n\n      // Get our sprite tile address, need to also add the current sprite line to get the correct bytes\n      let spriteTileAddressStart: i32 = <i32>getTileDataAddress(Graphics.memoryLocationTileDataSelectOneStart, spriteTileId);\n      spriteTileAddressStart = spriteTileAddressStart + currentSpriteLine;\n      let spriteTileAddress: u16 = <u16>spriteTileAddressStart;\n      let spriteDataByteOneForLineOfTilePixels: u8 = eightBitLoadFromGBMemorySkipTraps(spriteTileAddress);\n      let spriteDataByteTwoForLineOfTilePixels: u8 = eightBitLoadFromGBMemorySkipTraps(spriteTileAddress + 1);\n\n      // Iterate over the width of our sprite to found our individual pixels\n      for(let tilePixel: i8 = 7; tilePixel >= 0; tilePixel--) {\n\n        // Get our spritePixel, and check for flipping\n        let spritePixelXInTile: i8 = tilePixel;\n        if(flipSpriteX) {\n          spritePixelXInTile -= 7;\n          spritePixelXInTile = spritePixelXInTile * -1;\n        }\n\n        // Get the color Id of our sprite, similar to renderBackground()\n        // With the first byte, and second byte lined up method thing\n        // Yes, the second byte comes before the first, see ./background.ts\n        let spriteColorId: u8 = 0;\n        if (checkBitOnByte(<u8>spritePixelXInTile, spriteDataByteTwoForLineOfTilePixels)) {\n          // Byte one represents the second bit in our color id, so bit shift\n          spriteColorId += 1;\n          spriteColorId = (spriteColorId << 1);\n        }\n        if (checkBitOnByte(<u8>spritePixelXInTile, spriteDataByteOneForLineOfTilePixels)) {\n          spriteColorId += 1;\n        }\n\n        // ColorId zero (last two bits of pallette) are transparent\n        // http://gbdev.gg8.se/wiki/articles/Video_Display\n        if (spriteColorId !== 0) {\n\n          // Get our color ID from the current sprite pallete\n          let spritePixelColorFromPalette: u8 = getColorFromPalette(spriteColorId, spritePaletteLocation);\n\n          // Find our actual X pixel location on the gameboy \"camera\" view\n          let spriteXPixelLocationInCameraView: u8 = spriteXPosition + (7 - <u8>tilePixel);\n\n          // Now that we have our coordinates, check sprite priority\n          // Remember, set pixel on frame increases the value by one!\n          if (!isSpritePriorityBehindWindowAndBackground ||\n            getPixelOnFrame(spriteXPixelLocationInCameraView, scanlineRegister) <= 1) {\n            // Finally set the pixel!\n            setPixelOnFrame(spriteXPixelLocationInCameraView, scanlineRegister, spritePixelColorFromPalette);\n          }\n        }\n\n        // Done!\n      }\n    }\n  }\n}\n","// Functions to help with Handling Duty on Square Channels\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Square_Wave\n\nimport {\n  getRegister1OfChannel\n} from './registers';\nimport {\n  checkBitOnByte\n} from '../helpers/index';\n\nexport function getChannelDuty(channelNumber: i8): u8 {\n  let duty = getRegister1OfChannel(channelNumber);\n  duty = (duty >> 6);\n  return (duty & 0x03);\n}\n\n// Since there are no 2d arrays, we will use a byte to represent duty cycles (wave form from percentages)\nexport function isDutyCycleClockPositiveOrNegativeForWaveform(channelNumber: i8, waveFormPositionOnDuty: u8): boolean {\n  // Get our current Duty\n  let duty: u8 = getChannelDuty(channelNumber);\n\n  // Get our Wave Form According to the Duty\n  // Default to a duty of 1\n  // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Square_Wave\n  // 0000 0001\n  let waveform: u8 = 0x01;\n  if (duty === 0x01) {\n    // 1000 0001\n    waveform = 0x81;\n  } else if (duty === 0x02) {\n    // 1000 0111\n    waveform = 0x87;\n  } else if (duty === 0x03) {\n    // 0111 1110\n    waveform = 0x7E;\n  }\n\n  // Finally check if our duty cycle is an active bit on our byte\n  return checkBitOnByte(waveFormPositionOnDuty, waveform);\n}\n","// Imports\nimport {\n  Cpu\n} from './cpu/index';\nimport {\n  Graphics\n} from './graphics/index';\nimport {\n  Interrupts\n} from './interrupts/index';\nimport {\n  Joypad\n} from './joypad/index';\nimport {\n  Memory\n} from './memory/index';\nimport {\n  Timers\n} from './timers/index';\nimport {\n  Sound,\n  Channel1,\n  Channel2,\n  Channel3,\n  Channel4\n} from './sound/index';\nimport {\n  eightBitLoadFromGBMemory\n} from './memory/index';\n\n// Public Exports\nexport {\ninitialize\n} from './cpu/index';\nexport {\n  update,\n  emulationStep\n} from './cpu/opcodes';\nexport {\n  areInterruptsEnabled\n} from './interrupts/index';\nexport {\n  setJoypadState\n} from './joypad/index';\nexport {\n  getAudioQueueIndex,\n  resetAudioQueue\n} from './sound/index';\n\n// Function to save state to memory for all of our classes\nexport function saveState(): void {\n  Cpu.saveState();\n  Graphics.saveState();\n  Interrupts.saveState();\n  Joypad.saveState();\n  Memory.saveState();\n  Timers.saveState();\n  Sound.saveState();\n  Channel1.saveState();\n  Channel2.saveState();\n  Channel3.saveState();\n  Channel4.saveState();\n}\n\n// Function to load state from memory for all of our classes\nexport function loadState(): void {\n  Cpu.loadState();\n  Graphics.loadState();\n  Interrupts.loadState();\n  Joypad.loadState();\n  Memory.loadState();\n  Timers.loadState();\n  Sound.loadState();\n  Channel1.loadState();\n  Channel2.loadState();\n  Channel3.loadState();\n  Channel4.loadState();\n}\n\nexport function getRegisterA(): u8 {\n  return Cpu.registerA;\n}\n\nexport function getRegisterB(): u8 {\n  return Cpu.registerB;\n}\n\nexport function getRegisterC(): u8 {\n  return Cpu.registerC;\n}\n\nexport function getRegisterD(): u8 {\n  return Cpu.registerD;\n}\n\nexport function getRegisterE(): u8 {\n  return Cpu.registerE;\n}\n\nexport function getRegisterH(): u8 {\n  return Cpu.registerH;\n}\n\nexport function getRegisterL(): u8 {\n  return Cpu.registerL;\n}\n\nexport function getRegisterF(): u8 {\n  return Cpu.registerF;\n}\n\nexport function getProgramCounter(): u16 {\n  return Cpu.programCounter;\n}\n\nexport function getStackPointer(): u16 {\n  return Cpu.stackPointer;\n}\n\nexport function getPreviousOpcode(): u8 {\n  return Cpu.previousOpcode;\n}\n\nexport function getOpcodeAtProgramCounter(): u8 {\n  return eightBitLoadFromGBMemory(Cpu.programCounter);\n}\n"]}