{"version":3,"sources":["wasm/constants/constants.ts","wasm/cpu/cpu.ts","wasm/memory/load.ts","wasm/memory/memoryMap.ts","wasm/memory/memory.ts","wasm/memory/banking.ts","wasm/helpers/index.ts","wasm/memory/store.ts","wasm/sound/channel1.ts","wasm/sound/sound.ts","wasm/sound/channel2.ts","wasm/sound/channel3.ts","wasm/sound/channel4.ts","wasm/config.ts","wasm/cpu/opcodes.ts","wasm/memory/readTraps.ts","wasm/graphics/graphics.ts","wasm/joypad/index.ts","wasm/sound/length.ts","wasm/sound/registers.ts","wasm/sound/frequency.ts","wasm/sound/envelope.ts","wasm/sound/duty.ts","wasm/memory/writeTraps.ts","wasm/timers/index.ts","wasm/interrupts/index.ts","wasm/memory/dma.ts","wasm/graphics/palette.ts","wasm/cpu/flags.ts","wasm/cpu/instructions.ts","wasm/cpu/cbOpcodes.ts","wasm/graphics/lcd.ts","wasm/graphics/backgroundWindow.ts","wasm/graphics/renderUtils.ts","wasm/graphics/sprites.ts","wasm/debug/debug-cpu.ts","wasm/debug/debug-graphics.ts","wasm/index.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["// Constants that will be shared by the wasm core of the emulator\n// And libraries built around the wasm (such as the official JS), or @CryZe wasmboy-rs\n\n// TODO: Make better names for these\n\n// ----------------------------------\n// Wasmboy Memory Map\n// https://docs.google.com/spreadsheets/d/17xrEzJk5-sCB9J2mMJcVnzhbE-XH_NvczVSQH9OHvRk/edit?usp=sharing\n// ----------------------------------\n\n// WasmBoy\nexport const wasmMemorySize: u32 = 0x8B0000;\nexport const assemblyScriptMemoryBaseLocation: u32 = 0x000000;\nexport const wasmBoyInternalStateLocation: u32 = 0x000400;\nexport const wasmBoyInternalStateSize: u32 = 0x000400;\n\n// Gameboy\nexport const gameBoyInternalMemoryLocation: u32 = 0x000800;\nexport const gameBoyInternalMemorySize: u32 = 0x00FFFF;\nexport const gameBoyVramLocation: u32 = 0x000800;\nexport const gameBoyWramLocation: u32 = 0x004800;\nexport const gameBoyMemoryRegistersLocation: u32 = 0x00C800;\n\n// Video output\nexport const videoOutputLocation: u32 = 0x010800;\nexport const gameboyColorPaletteLocation: u32 = 0x010800;\nexport const frameInProgressVideoOutputLocation: u32 = 0x011000;\nexport const currentFrameVideoOutputLocation: u32 = 0x022000;\nexport const backgroundMapLocation: u32 = 0x033000;\nexport const tileDataMap: u32 = 0x063000;\nexport const oamTiles: u32 = 0x068000;\n\n// Sound output\nexport const soundOutputLocation: u32 = 0x06B000;\n\n// Game Cartridge\nexport const gameRamBanksLocation: u32 = 0x08B000;\n// Passed in Game backup or ROM from the user\nexport const gameBytesLocation: u32 = 0x0AB000;\n","import {\n  eightBitStoreIntoGBMemory,\n  eightBitStoreIntoGBMemorySkipTraps,\n  eightBitLoadFromGBMemory,\n  eightBitLoadFromGBMemorySkipTraps,\n  initializeCartridge,\n  getSaveStateMemoryOffset,\n  loadBooleanDirectlyFromWasmMemory,\n  storeBooleanDirectlyToWasmMemory\n} from '../memory/index';\n\nimport {\n  initializeSound\n} from '../sound/index'\n\nimport {\n  log,\n  hexLog\n} from '../helpers/index';\n\n// Everything Static as class instances just aren't quite there yet\n// https://github.com/AssemblyScript/assemblyscript/blob/master/tests/compiler/showcase.ts\nexport class Cpu {\n\n  // Status to track if we are in Gameboy Color Mode, and GBC State\n  static GBCEnabled: boolean = false;\n  static GBCDoubleSpeed: boolean = false;\n\n  // 8-bit Cpu.registers\n  static registerA: u8 = 0;\n  static registerB: u8 = 0;\n  static registerC: u8 = 0;\n  static registerD: u8 = 0;\n  static registerE: u8 = 0;\n  static registerH: u8 = 0;\n  static registerL: u8 = 0;\n  static registerF: u8 = 0;\n\n  // 16-bit Cpu.registers\n  static stackPointer: u16 = 0;\n  // Boot rom from 0x00 to 0x99, all games start at 0x100\n  static programCounter: u16 = 0x00;\n\n  // Current number of cycles, shouldn't execeed max number of cycles\n  static currentCycles: i32 = 0;\n  static CLOCK_SPEED(): i32 {\n    if (Cpu.GBCDoubleSpeed) {\n      // 2^23, thanks binji!\n      return 8388608;\n    }\n\n    return 4194304;\n  }\n\n  // cycles = 154 scanlines, 456 cycles per line\n  static MAX_CYCLES_PER_FRAME(): i32 {\n    if (Cpu.GBCDoubleSpeed) {\n      return 140448;\n    }\n\n    return 70224;\n  }\n\n  // HALT and STOP instructions need to stop running opcodes, but simply check timers\n  // https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n  // Matt said is should work to, so it must work!\n  static isHalted: boolean = false;\n  static isStopped: boolean = false;\n\n  // Memory Location for the GBC Speed switch\n  static readonly memoryLocationSpeedSwitch: u16 = 0xFF4D;\n\n  // Save States\n  static readonly saveStateSlot: u16 = 0;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    // Registers\n    store<u8>(getSaveStateMemoryOffset(0x00, Cpu.saveStateSlot), Cpu.registerA);\n    store<u8>(getSaveStateMemoryOffset(0x01, Cpu.saveStateSlot), Cpu.registerB);\n    store<u8>(getSaveStateMemoryOffset(0x02, Cpu.saveStateSlot), Cpu.registerC);\n    store<u8>(getSaveStateMemoryOffset(0x03, Cpu.saveStateSlot), Cpu.registerD);\n    store<u8>(getSaveStateMemoryOffset(0x04, Cpu.saveStateSlot), Cpu.registerE);\n    store<u8>(getSaveStateMemoryOffset(0x05, Cpu.saveStateSlot), Cpu.registerH);\n    store<u8>(getSaveStateMemoryOffset(0x06, Cpu.saveStateSlot), Cpu.registerL);\n    store<u8>(getSaveStateMemoryOffset(0x07, Cpu.saveStateSlot), Cpu.registerF);\n\n    store<u16>(getSaveStateMemoryOffset(0x08, Cpu.saveStateSlot), Cpu.stackPointer);\n    store<u16>(getSaveStateMemoryOffset(0x0A, Cpu.saveStateSlot), Cpu.programCounter);\n\n    store<i32>(getSaveStateMemoryOffset(0x0C, Cpu.saveStateSlot), Cpu.currentCycles);\n\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x11, Cpu.saveStateSlot), Cpu.isHalted);\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x12, Cpu.saveStateSlot), Cpu.isStopped);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    // Registers\n    Cpu.registerA = load<u8>(getSaveStateMemoryOffset(0x00, Cpu.saveStateSlot));\n    Cpu.registerB = load<u8>(getSaveStateMemoryOffset(0x01, Cpu.saveStateSlot));\n    Cpu.registerC = load<u8>(getSaveStateMemoryOffset(0x02, Cpu.saveStateSlot));\n    Cpu.registerD = load<u8>(getSaveStateMemoryOffset(0x03, Cpu.saveStateSlot));\n    Cpu.registerE = load<u8>(getSaveStateMemoryOffset(0x04, Cpu.saveStateSlot));\n    Cpu.registerH = load<u8>(getSaveStateMemoryOffset(0x05, Cpu.saveStateSlot));\n    Cpu.registerL = load<u8>(getSaveStateMemoryOffset(0x06, Cpu.saveStateSlot));\n    Cpu.registerF = load<u8>(getSaveStateMemoryOffset(0x07, Cpu.saveStateSlot));\n\n    Cpu.stackPointer = load<u16>(getSaveStateMemoryOffset(0x08, Cpu.saveStateSlot));\n    Cpu.programCounter = load<u16>(getSaveStateMemoryOffset(0x0A, Cpu.saveStateSlot));\n\n    Cpu.currentCycles = load<i32>(getSaveStateMemoryOffset(0x0C, Cpu.saveStateSlot));\n\n    Cpu.isHalted = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x11, Cpu.saveStateSlot));\n    Cpu.isStopped = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x12, Cpu.saveStateSlot));\n  }\n}\n\nexport function initialize(useGBCMode: i32 = 1, includeBootRom: i32 = 0): void {\n\n  // First, try to switch to Gameboy Color Mode\n  // Get our GBC support from the cartridge header\n  // http://gbdev.gg8.se/wiki/articles/The_Cartridge_Header\n  let gbcType: u8 = eightBitLoadFromGBMemorySkipTraps(0x0143);\n\n  // Detecting GBC http://bgb.bircd.org/pandocs.htm#cgbregisters\n  if (gbcType === 0xC0 ||\n    (useGBCMode > 0 && gbcType === 0x80)) {\n    Cpu.GBCEnabled = true;\n  }\n\n  // TODO: depending on the boot rom, initialization may be different\n  // From: http://www.codeslinger.co.uk/pages/projects/gameboy/hardware.html\n  // All values default to zero in memory, so not setting them yet\n  log(\"initializing (includeBootRom=$0)\", 1, includeBootRom);\n  if(includeBootRom <= 0) {\n\n    // Initialization variables from BGB\n\n    if(Cpu.GBCEnabled) {\n\n      // CPU Registers\n      Cpu.registerA = 0x11;\n      Cpu.registerF = 0x80;\n      Cpu.registerB = 0x00;\n      Cpu.registerC = 0x00;\n      Cpu.registerD = 0xFF;\n      Cpu.registerE = 0x56;\n      Cpu.registerH = 0x00;\n      Cpu.registerL = 0x0D;\n\n      // Cpu Control Flow\n      Cpu.programCounter = 0x100;\n      Cpu.stackPointer = 0xFFFE;\n\n      // LCD / Graphics\n      eightBitStoreIntoGBMemorySkipTraps(0xFF40, 0x91);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF41, 0x81);\n      // 0xFF42 -> 0xFF43 = 0x00\n      eightBitStoreIntoGBMemorySkipTraps(0xFF44, 0x90);\n      // 0xFF45 -> 0xFF46 = 0x00\n      eightBitStoreIntoGBMemorySkipTraps(0xFF47, 0xFC);\n      // 0xFF48 -> 0xFF4B = 0x00\n\n      // Various other registers\n      eightBitStoreIntoGBMemorySkipTraps(0xFF70, 0xF8);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF4F, 0xFE);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF4D, 0x7E);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF00, 0xCF);\n      // FF01 = 0x00\n      eightBitStoreIntoGBMemorySkipTraps(0xFF02, 0x7C);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF04, 0x2F);\n      // 0xFF05 -> 0xFF06 = 0x00\n      eightBitStoreIntoGBMemorySkipTraps(0xFF07, 0xF8);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF0F, 0xE1);\n      // 0xFFFF = 0x00\n\n      // GBC Palettes\n      eightBitStoreIntoGBMemorySkipTraps(0xFF68, 0xC0);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF69, 0xFF);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF6A, 0xC1);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF6B, 0x0D);\n\n      // GBC Banks\n      eightBitStoreIntoGBMemorySkipTraps(0xFF4F, 0x00);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF70, 0x01);\n\n      // GBC DMA\n      eightBitStoreIntoGBMemorySkipTraps(0xFF51, 0xFF);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF52, 0xFF);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF53, 0xFF);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF54, 0xFF);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF55, 0xFF);\n\n      // Undocumented from Pandocs\n      eightBitStoreIntoGBMemorySkipTraps(0xFF6C, 0xFE);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF75, 0x8F);\n\n    } else {\n      // Cpu Registers\n      Cpu.registerA = 0x01;\n      Cpu.registerF = 0xB0;\n      Cpu.registerB = 0x00;\n      Cpu.registerC = 0x13;\n      Cpu.registerD = 0x00;\n      Cpu.registerE = 0xD8;\n      Cpu.registerH = 0x01;\n      Cpu.registerL = 0x4D;\n\n      // Cpu Control Flow\n      Cpu.programCounter = 0x100;\n      Cpu.stackPointer = 0xFFFE;\n\n      // LCD / Graphics\n      eightBitStoreIntoGBMemorySkipTraps(0xFF40, 0x91);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF41, 0x85);\n      // 0xFF42 -> 0xFF45 = 0x00\n      eightBitStoreIntoGBMemorySkipTraps(0xFF46, 0xFF);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF47, 0xFC);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF48, 0xFF);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF49, 0xFF);\n      // 0xFF4A -> 0xFF4B = 0x00\n\n      // Various other registers\n      eightBitStoreIntoGBMemorySkipTraps(0xFF70, 0xFF);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF4F, 0xFF);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF4D, 0xFF);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF00, 0xCF);\n      // FF01 = 0x00\n      eightBitStoreIntoGBMemorySkipTraps(0xFF02, 0x7E);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF04, 0xAB);\n      // 0xFF05 -> 0xFF06 = 0x00\n      eightBitStoreIntoGBMemorySkipTraps(0xFF07, 0xF8);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF0F, 0xE1);\n      // 0xFFFF = 0x00\n\n\n      // GBC Palettes\n      eightBitStoreIntoGBMemorySkipTraps(0xFF68, 0xFF);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF69, 0xFF);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF6A, 0xFF);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF6B, 0xFF);\n\n      // GBC Banks\n      eightBitStoreIntoGBMemorySkipTraps(0xFF4F, 0x00);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF70, 0x01);\n\n      // GBC DMA\n      eightBitStoreIntoGBMemorySkipTraps(0xFF51, 0xFF);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF52, 0xFF);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF53, 0xFF);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF54, 0xFF);\n      eightBitStoreIntoGBMemorySkipTraps(0xFF55, 0xFF);\n    }\n\n    // Call our memory to initialize our cartridge type\n    initializeCartridge();\n\n    // Initialize our sound registers\n    initializeSound();\n  }\n}\n","// Load/Read functionality for memory\nimport {\n  checkReadTraps\n} from './readTraps';\nimport {\n  getWasmBoyOffsetFromGameBoyOffset\n} from './memoryMap';\nimport {\n  concatenateBytes,\n  performanceTimestamp\n} from '../helpers/index';\n\nexport function eightBitLoadFromGBMemory(offset: u16): u8 {\n  let readTrapResult: i32 = checkReadTraps(offset);\n  switch (readTrapResult) {\n    case -1:\n      return _eightBitLoadFromWasmBoyMemory(offset);\n    default:\n      return <u8>readTrapResult;\n  }\n}\n\nexport function eightBitLoadFromGBMemorySkipTraps(offset: u16): u8 {\n  return _eightBitLoadFromWasmBoyMemory(offset);\n}\n\nexport function sixteenBitLoadFromGBMemory(offset: u16): u16 {\n\n  // Get our low byte\n  let lowByte: u8 = 0;\n  let lowByteReadTrapResult: i32 = checkReadTraps(offset);\n  switch (lowByteReadTrapResult) {\n    case -1:\n      lowByte = _eightBitLoadFromWasmBoyMemory(offset);\n      break;\n    default:\n      lowByte = <u8>lowByteReadTrapResult;\n      break;\n  }\n\n  // Get the next offset for the second byte\n  let nextOffset: u16 = offset + 1;\n\n  // Get our high byte\n  let highByte: u8 = 0;\n  let highByteReadTrapResult: i32 = checkReadTraps(nextOffset);\n  switch (highByteReadTrapResult) {\n    case -1:\n      highByte = _eightBitLoadFromWasmBoyMemory(nextOffset);\n      break;\n    default:\n      highByte = <u8>highByteReadTrapResult;\n      break;\n  }\n\n  // Concatenate the bytes and return\n  return concatenateBytes(highByte, lowByte);\n}\n\nfunction _eightBitLoadFromWasmBoyMemory(gameboyOffset: u16): u8 {\n  return load<u8>(getWasmBoyOffsetFromGameBoyOffset(gameboyOffset));\n}\n\nexport function loadBooleanDirectlyFromWasmMemory(offset: u32): boolean {\n  let booleanAsInt: u8 = load<u8>(offset);\n  if(booleanAsInt > 0) {\n    return true;\n  }\n  return false;\n}\n","// WasmBoy memory map:\n// https://docs.google.com/spreadsheets/d/17xrEzJk5-sCB9J2mMJcVnzhbE-XH_NvczVSQH9OHvRk/edit?usp=sharing\n\nimport {\n  Memory\n} from './memory';\nimport {\n  eightBitLoadFromGBMemorySkipTraps\n} from './load';\nimport {\n  getRomBankAddress,\n  getRamBankAddress\n} from './banking';\nimport {\n  Cpu\n} from '../cpu/cpu'\nimport {\n  hexLog\n} from '../helpers/index';\n\n// Private function to translate a offset meant for the gameboy memory map\n// To the wasmboy memory map\n// Following: http://gameboy.mongenel.com/dmg/asmmemmap.html\n// And https://github.com/Dooskington/GameLad/wiki/Part-11---Memory-Bank-Controllers\n// Performance help from @dcodeIO, and awesome-gbdev\nexport function getWasmBoyOffsetFromGameBoyOffset(gameboyOffset: i32): i32 {\n\n  // Get the top byte and switch\n  let gameboyOffsetHighByte: i32 = (gameboyOffset >> 12);\n  switch(gameboyOffsetHighByte) {\n    case 0x00:\n    case 0x01:\n    case 0x02:\n    case 0x03:\n      // Cartridge ROM - Bank 0 (fixed)\n      // 0x0000 -> 0x0D2400\n      return gameboyOffset + Memory.gameBytesLocation;\n    case 0x04:\n    case 0x05:\n    case 0x06:\n    case 0x07:\n      // Cartridge ROM - Switchable Banks 1-xx\n      // 0x4000 -> (0x0D2400 + 0x4000)\n      return getRomBankAddress(gameboyOffset) + Memory.gameBytesLocation;\n    case 0x08:\n    case 0x09:\n      // Video RAM\n      // 0x8000 -> 0x000400\n      let vramBankId: u32 = 0;\n      if (Cpu.GBCEnabled) {\n        // Find our current VRAM Bank\n        vramBankId = (eightBitLoadFromGBMemorySkipTraps(Memory.memoryLocationGBCVRAMBAnk) & 0x01);\n        // Even though We added another 0x2000, the Cartridge ram is pulled out of our Internal Memory Space\n        // Therefore, we do not need to adjust for this extra 0x2000\n      }\n\n      return (gameboyOffset - Memory.videoRamLocation) + Memory.gameBoyVramLocation + (0x2000 * vramBankId);\n    case 0x0A:\n    case 0x0B:\n      // Cartridge RAM - A.K.A External RAM\n      // 0xA000 -> 0x008400\n      return getRamBankAddress(gameboyOffset) + Memory.gameRamBanksLocation;\n    case 0x0C:\n      // Gameboy Ram Bank 0\n      // 0xC000 -> 0x000400\n      // Don't need to add head, since we move out 0x200 from the cartridge ram\n      return (gameboyOffset - Memory.internalRamBankZeroLocation) + Memory.gameBoyWramLocation;\n    case 0x0D:\n      // Gameboy Ram Banks, Switchable in GBC Mode\n      // 0xD000 -> 0x000400\n      // In CGB Mode 32 KBytes internal RAM are available.\n      // This memory is divided into 8 banks of 4 KBytes each.\n      // Bank 0 is always available in memory at C000-CFFF,\n      // Bank 1-7 can be selected into the address space at D000-DFFF.\n      // http://gbdev.gg8.se/wiki/articles/CGB_Registers#FF70_-_SVBK_-_CGB_Mode_Only_-_WRAM_Bank\n      // Get the last 3 bits to find our wram ID\n      let wramBankId: u32 = 0;\n      if(Cpu.GBCEnabled) {\n        wramBankId  = (eightBitLoadFromGBMemorySkipTraps(Memory.memoryLocationGBCWRAMBank) & 0x07);\n        if (wramBankId < 1) {\n          wramBankId = 1;\n        }\n      }\n      // (0x1000 * (wramBankId - 1)) -> To find the correct wram bank.\n      // wramBankId - 1, because we alreayd have the space for wramBank 1, and are currently in it\n      // So need to address space for 6 OTHER banks\n      return (gameboyOffset - Memory.internalRamBankZeroLocation) + Memory.gameBoyWramLocation + (0x1000 * (wramBankId - 1));\n    default:\n      // Everything Else after Gameboy Ram Banks\n      // 0xE000 -> 0x000400\n      // 0x6000 For the Extra WRAM Banks\n      return (gameboyOffset - Memory.echoRamLocation) + Memory.gameBoyMemoryRegistersLocation;\n  }\n}\n","// WasmBoy memory map:\n// https://docs.google.com/spreadsheets/d/17xrEzJk5-sCB9J2mMJcVnzhbE-XH_NvczVSQH9OHvRk/edit?usp=sharing\nimport {\n  wasmMemorySize,\n  gameBoyInternalMemoryLocation,\n  videoOutputLocation,\n  currentFrameVideoOutputLocation,\n  frameInProgressVideoOutputLocation,\n  gameboyColorPaletteLocation,\n  soundOutputLocation,\n  gameBytesLocation,\n  gameRamBanksLocation,\n  gameBoyVramLocation,\n  gameBoyWramLocation,\n  gameBoyMemoryRegistersLocation\n} from '../constants/constants';\nimport {\n  eightBitLoadFromGBMemorySkipTraps,\n  loadBooleanDirectlyFromWasmMemory\n} from './load';\nimport {\n  eightBitStoreIntoGBMemorySkipTraps,\n  storeBooleanDirectlyToWasmMemory\n} from './store';\nimport {\n  handleBanking\n} from './banking';\nimport {\n  checkBitOnByte,\n  resetBitOnByte,\n  hexLog\n} from '../helpers/index';\n\nexport class Memory {\n\n  // ----------------------------------\n  // Gameboy Memory Map\n  // ----------------------------------\n  // https://github.com/AntonioND/giibiiadvance/blob/master/docs/TCAGBD.pdf\n  // http://gameboy.mongenel.com/dmg/asmmemmap.html\n  // using Arrays, first index is start, second is end\n  static readonly cartridgeRomLocation: u16 = 0x0000;\n\n  static readonly switchableCartridgeRomLocation: u16 = 0x4000;\n\n  static readonly videoRamLocation: u16 = 0x8000;\n\n  static readonly cartridgeRamLocation: u16 = 0xA000;\n\n  static readonly internalRamBankZeroLocation: u16 = 0xC000;\n\n  // This ram bank is switchable\n  static readonly internalRamBankOneLocation: u16 = 0xD000;\n\n  static readonly echoRamLocation: u16 = 0xE000;\n\n  static readonly spriteInformationTableLocation: u16 = 0xFE00;\n\n  static readonly spriteInformationTableLocationEnd: u16 = 0xFE9F;\n\n  static readonly unusableMemoryLocation: u16 = 0xFEA0;\n  static readonly unusableMemoryEndLocation: u16 = 0xFEFF;\n\n  // Hardware I/O, 0xFF00 -> 0xFF7F\n  // Zero Page, 0xFF80 -> 0xFFFE\n  // Intterupt Enable Flag, 0xFFFF\n\n  // ----------------------------------\n  // Wasmboy Memory Map\n  // ----------------------------------\n  static readonly gameBoyInternalMemoryLocation: u32 = gameBoyInternalMemoryLocation;\n  static readonly gameBoyVramLocation: u32 = gameBoyVramLocation;\n  static readonly gameBoyWramLocation: u32 = gameBoyWramLocation;\n  static readonly gameBoyMemoryRegistersLocation: u32 = gameBoyMemoryRegistersLocation;\n  static readonly videoOutputLocation: u32 = videoOutputLocation;\n  static readonly currentFrameVideoOutputLocation: u32 = currentFrameVideoOutputLocation;\n  static readonly frameInProgressVideoOutputLocation: u32 = frameInProgressVideoOutputLocation;\n  static readonly gameboyColorPaletteLocation: u32 = gameboyColorPaletteLocation;\n  static readonly soundOutputLocation: u32 = soundOutputLocation;\n\n  // Passed in Game backup or ROM from the user\n  static readonly gameRamBanksLocation: u32 = gameRamBanksLocation;\n  static readonly gameBytesLocation: u32 = gameBytesLocation;\n\n\n  // ----------------------------------\n  // Rom/Ram Banking\n  // ----------------------------------\n  // http://gbdev.gg8.se/wiki/articles/Memory_Bank_Controllers#MBC3_.28max_2MByte_ROM_and.2For_32KByte_RAM_and_Timer.29\n  // http://www.codeslinger.co.uk/pages/projects/gameboy/banking.html\n  static currentRomBank: u16 = 0x00;\n  static currentRamBank: u16 = 0x00;\n  static isRamBankingEnabled: boolean = false;\n  static isMBC1RomModeEnabled: boolean = true;\n\n  // Cartridge Types\n  // http://gbdev.gg8.se/wiki/articles/The_Cartridge_Header\n  static isRomOnly: boolean = true;\n  static isMBC1: boolean = false;\n  static isMBC2: boolean = false;\n  static isMBC3: boolean = false;\n  static isMBC5: boolean = false;\n\n  // DMA\n  static memoryLocationHdmaSourceHigh: u16 = 0xFF51;\n  static memoryLocationHdmaSourceLow: u16 = 0xFF52;\n  static memoryLocationHdmaDestinationHigh: u16 = 0xFF53;\n  static memoryLocationHdmaDestinationLow: u16 = 0xFF54;\n  static memoryLocationHdmaTrigger: u16 = 0xFF55;\n  // Cycles accumulated for DMA\n  static DMACycles: i32 = 0;\n  // Boolean we will mirror to indicate if Hdma is active\n  static isHblankHdmaActive: boolean = false;\n  static hblankHdmaIndex: i32 = 0x00;\n  static hblankHdmaTotalBytes: i32 = 0x00;\n  // Store the source and destination for performance, and update as needed\n  static hblankHdmaSource: u16 = 0x00;\n  static hblankHdmaDestination: u16 = 0x00;\n\n  // GBC Registers\n  static memoryLocationGBCVRAMBAnk: u16 = 0xFF4F;\n  static memoryLocationGBCWRAMBank: u16 = 0xFF70;\n\n  // Save States\n\n  static readonly saveStateSlot: u16 = 4;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    store<u16>(getSaveStateMemoryOffset(0x00, Memory.saveStateSlot), Memory.currentRomBank);\n    store<u16>(getSaveStateMemoryOffset(0x02, Memory.saveStateSlot), Memory.currentRamBank);\n\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x04, Memory.saveStateSlot), Memory.isRamBankingEnabled);\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x05, Memory.saveStateSlot), Memory.isMBC1RomModeEnabled);\n\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x06, Memory.saveStateSlot), Memory.isRomOnly);\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x07, Memory.saveStateSlot), Memory.isMBC1);\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x08, Memory.saveStateSlot), Memory.isMBC2);\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x09, Memory.saveStateSlot), Memory.isMBC3);\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x0A, Memory.saveStateSlot), Memory.isMBC5);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    Memory.currentRomBank = load<u16>(getSaveStateMemoryOffset(0x00, Memory.saveStateSlot));\n    Memory.currentRamBank = load<u16>(getSaveStateMemoryOffset(0x02, Memory.saveStateSlot));\n\n    Memory.isRamBankingEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x04, Memory.saveStateSlot));\n    Memory.isMBC1RomModeEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x05, Memory.saveStateSlot));\n\n    Memory.isRomOnly = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x06, Memory.saveStateSlot));\n    Memory.isMBC1 = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x07, Memory.saveStateSlot));\n    Memory.isMBC2 = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x08, Memory.saveStateSlot));\n    Memory.isMBC3 = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x09, Memory.saveStateSlot));\n    Memory.isMBC5 = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x0A, Memory.saveStateSlot));\n  }\n}\n\nexport function initializeCartridge(): void {\n  // Get our game MBC type from the cartridge header\n  // http://gbdev.gg8.se/wiki/articles/The_Cartridge_Header\n  let cartridgeType: u8 = eightBitLoadFromGBMemorySkipTraps(0x0147);\n\n  // Reset our Cartridge types\n  Memory.isRomOnly = false;\n  Memory.isMBC1 = false;\n  Memory.isMBC2 = false;\n  Memory.isMBC3 = false;\n  Memory.isMBC5 = false;\n\n  if(cartridgeType === 0x00) {\n    Memory.isRomOnly = true;\n  } else if (cartridgeType >= 0x01 && cartridgeType <= 0x03) {\n    Memory.isMBC1 = true;\n  } else if (cartridgeType >= 0x05 && cartridgeType <= 0x06) {\n    Memory.isMBC2 = true;\n  } else if (cartridgeType >= 0x0F && cartridgeType <= 0x13) {\n    Memory.isMBC3 = true;\n  } else if (cartridgeType >= 0x19 && cartridgeType <= 0x1E) {\n    Memory.isMBC5 = true;\n  }\n\n  Memory.currentRomBank = 0x01;\n  Memory.currentRamBank = 0x00;\n}\n\n// Also need to store current frame in memory to be read by JS\nexport function setPixelOnFrame(x: i32, y: i32, colorId: i32, color: u8): void {\n  // Currently only supports 160x144\n  // Storing in X, then y\n  // So need an offset\n\n  let offset: i32 = Memory.frameInProgressVideoOutputLocation + getRgbPixelStart(x, y) + colorId;\n  store<u8>(offset, color);\n}\n\n// Need to also get our pixel on the frame for sprite priority\nexport function getPixelOnFrame(x: i32, y: i32): u8 {\n  // Currently only supports 160x144\n  // Storing in X, then y\n  // So need an offset\n\n  let offset: i32 = Memory.frameInProgressVideoOutputLocation + getRgbPixelStart(x, y);\n\n  // Added one to the color, that way you don't ge the default zero\n  return load<u8>(offset);\n}\n\n// Function to get the start of a RGB pixel (R, G, B)\nfunction getRgbPixelStart(x: i32, y: i32): i32 {\n  // Get the pixel number\n  let pixelNumber: i32 = (y * 160) + x;\n  // Each pixel takes 3 slots, therefore, multiply by 3!\n  return pixelNumber * 3;\n}\n\n// V-Blank occured, move our frame in progress to our render frame\nexport function storeFrameToBeRendered(): void {\n\n  // Cache our constant for performance\n  let currentFrameVideoOutputLocation: i32 = Memory.currentFrameVideoOutputLocation;\n  let frameInProgressVideoOutputLocation: i32 = Memory.frameInProgressVideoOutputLocation;\n\n  // Not using getPixelOnFrame() for performance\n\n  for(let y: i32 = 0; y < 144; y++) {\n    for (let x: i32 = 0; x < 160; x++) {\n      // Store three times for each pixel\n      let pixelStart: i32 = getRgbPixelStart(x, y);\n      for (let colorId: i32 = 0; colorId < 3; colorId++) {\n        store<u8>(\n          currentFrameVideoOutputLocation + pixelStart + colorId,\n          load<u8>(frameInProgressVideoOutputLocation + pixelStart + colorId)\n        )\n      }\n    }\n  }\n}\n\n// Function to set our left and right channels at the correct queue index\nexport function setLeftAndRightOutputForAudioQueue(leftVolume: u8, rightVolume: u8, audioQueueIndex: u32): void {\n  // Get our stereo index\n  let audioQueueOffset = Memory.soundOutputLocation + (audioQueueIndex * 2);\n\n  // Store our volumes\n  // +1 that way we don't have empty data to ensure that the value is set\n  store<u8>(audioQueueOffset, leftVolume + 1);\n  store<u8>(audioQueueOffset + 1, rightVolume + 1);\n}\n\n// Function to shortcut the memory map, and load directly from the VRAM Bank\nexport function loadFromVramBank(gameboyOffset: i32, vramBankId: i32): u8 {\n  let wasmBoyAddress: u32 = (gameboyOffset - Memory.videoRamLocation) + Memory.gameBoyInternalMemoryLocation + (0x2000 * (vramBankId & 0x01));\n  return load<u8>(wasmBoyAddress);\n}\n\n// Function to store a byte to our Gbc Palette memory\nexport function storePaletteByteInWasmMemory(paletteIndexByte: u8, value: u8, isSprite: boolean): void {\n\n  // Clear the top two bits to just get the bottom palette Index\n  let paletteIndex: u32 = (paletteIndexByte & 0x3F);\n\n  // Move over the palette index to not overlap the background (has 0x3F, so Zero for Sprites is 0x40)\n  if(isSprite) {\n    paletteIndex += 0x40;\n  }\n\n  store<u8>(Memory.gameboyColorPaletteLocation + paletteIndex, value);\n}\n\n// Function to load a byte from our Gbc Palette memory\n// Function to store a byte to our Gbc Palette memory\nexport function loadPaletteByteFromWasmMemory(paletteIndexByte: u8, isSprite: boolean): u8 {\n\n  // Clear the top two bits to just get the bottom palette Index\n  let paletteIndex: u32 = (paletteIndexByte & 0x3F);\n\n  // Move over the palette index to not overlap the background has 0x3F, so Zero for Sprites is 0x40)\n  if(isSprite) {\n    paletteIndex += 0x40;\n  }\n\n  return load<u8>(Memory.gameboyColorPaletteLocation + paletteIndex);\n}\n\n\n// Function to return an address to store into save state memory\n// this is to regulate our 20 slots\n// https://docs.google.com/spreadsheets/d/17xrEzJk5-sCB9J2mMJcVnzhbE-XH_NvczVSQH9OHvRk/edit?usp=sharing\nexport function getSaveStateMemoryOffset(offset: u16, saveStateSlot: u16): u16 {\n  // 50 byutes per save state memory partiton slot\n  let address: u16 = offset + (50 * saveStateSlot);\n  return address;\n}\n","// Function to handle rom/rambanking\nimport {\nMemory\n} from './memory';\nimport {\n  concatenateBytes,\n  checkBitOnByte,\n  splitLowByte,\n  hexLog\n} from '../helpers/index';\n\nexport function handleBanking(offset: u16, value: u16): void {\n      // Is rom Only does not bank\n      if(Memory.isRomOnly) {\n        return;\n      }\n\n      // Enable Ram Banking\n      if(offset <= 0x1FFF) {\n\n        if(Memory.isMBC2 && !checkBitOnByte(4, <u8>value)) {\n          // Do Nothing\n          return;\n        } else {\n          let romEnableByte = value & 0x0F;\n          if(romEnableByte === 0x00) {\n            Memory.isRamBankingEnabled = false;\n          } else if (romEnableByte === 0x0A) {\n            Memory.isRamBankingEnabled = true;\n          }\n        }\n      } else if(offset <= 0x3FFF) {\n        if(!Memory.isMBC5 || offset <= 0x2FFF) {\n          // Change Low Bits on the Current Rom Bank\n          if (Memory.isMBC2) {\n\n            Memory.currentRomBank = value & 0x0F;\n          }\n\n          // Set the number of bottom bytes from the MBC type\n          let romBankLowerBits = value;\n          if (Memory.isMBC1) {\n            // Only want the bottom 5\n            romBankLowerBits = romBankLowerBits & 0x1F;\n            Memory.currentRomBank = Memory.currentRomBank & 0xE0;\n          } else if (Memory.isMBC3) {\n            // Only Want the bottom 7\n            romBankLowerBits = romBankLowerBits & 0x7F;\n            Memory.currentRomBank = Memory.currentRomBank & 0x80;\n          } else if (Memory.isMBC5) {\n            // Going to switch the whole thing\n            Memory.currentRomBank = Memory.currentRomBank & 0x00;\n          }\n\n          // Set the lower bytes\n          Memory.currentRomBank = Memory.currentRomBank | romBankLowerBits;\n          return;\n        } else {\n          // TODO: MBC5 High bits Rom bank, check if this works, not sure about the value\n          let highByte: u8 = 0;\n          let lowByte: u8 = splitLowByte(Memory.currentRomBank);\n          if(value > 0) {\n            highByte = 1;\n          }\n          Memory.currentRomBank = concatenateBytes(highByte, lowByte);\n        }\n      } else if(!Memory.isMBC2 &&\n      offset <= 0x5FFF) {\n        // ROM / RAM Banking, MBC2 doesn't do this\n        if (Memory.isMBC1 && Memory.isMBC1RomModeEnabled) {\n          // Do an upper bit rom bank for MBC 1\n          // Remove upper bits of currentRomBank\n          Memory.currentRomBank = Memory.currentRomBank & 0x1F;\n\n          let romBankHigherBits = value & 0xE0;\n\n          Memory.currentRomBank = Memory.currentRomBank | romBankHigherBits;\n          return;\n        }\n\n        if (Memory.isMBC3) {\n          if(value >= 0x08 && value <= 0x0C) {\n            // TODO: MBC3 RTC Register Select\n          }\n        }\n\n        let ramBankBits = value;\n\n        if(!Memory.isMBC5) {\n          // Get the bottom 2 bits\n          ramBankBits = ramBankBits & 0x03;\n        } else {\n          // Get the bottom nibble\n          ramBankBits = ramBankBits & 0x0F;\n        }\n\n        // Set our ram bank\n        Memory.currentRamBank = ramBankBits;\n        return;\n      } else if(!Memory.isMBC2 &&\n      offset <= 0x7FFF) {\n        if(Memory.isMBC1) {\n          if(checkBitOnByte(0, <u8>value)) {\n            Memory.isMBC1RomModeEnabled = true;\n          } else {\n            Memory.isMBC1RomModeEnabled = false;\n          }\n        }\n        // TODO: MBC3 Latch Clock Data\n      }\n}\n\nexport function getRomBankAddress(gameboyOffset: u32): u32 {\n  let currentRomBank: u16 = Memory.currentRomBank;\n  if(!Memory.isMBC5 && currentRomBank === 0) {\n    currentRomBank = 1;\n  }\n\n  // Adjust our gameboy offset relative to zero for the gameboy memory map\n  return <u32>((0x4000 * currentRomBank) + (gameboyOffset - Memory.switchableCartridgeRomLocation));\n}\n\nexport function getRamBankAddress(gameboyOffset: u32): u32 {\n  // Adjust our gameboy offset relative to zero for the gameboy memory map\n  return <u32>((0x2000 * Memory.currentRamBank) + (gameboyOffset - Memory.cartridgeRamLocation));\n}\n","import {\n  getCarryFlag\n} from '../cpu/flags';\n\n// Grouped registers\n// possible overload these later to performace actions\n// AF, BC, DE, HL\nexport function concatenateBytes(highByte: u8, lowByte: u8): u16 {\n  //https://stackoverflow.com/questions/38298412/convert-two-bytes-into-signed-16-bit-integer-in-javascript\n  return (((<u16>highByte & 0xFF) << 8) | (lowByte & 0xFF))\n}\n\nexport function splitHighByte(groupedByte: u16): u8 {\n  return <u8>((groupedByte & 0xFF00) >> 8);\n}\n\nexport function splitLowByte(groupedByte: u16): u8 {\n  return <u8>groupedByte & 0x00FF;\n}\n\nexport function rotateByteLeft(value: u8): u8 {\n  // Rotate left\n  // https://stackoverflow.com/questions/19204750/how-do-i-perform-a-circular-rotation-of-a-byte\n  // 4-bit example:\n  // 1010 -> 0100 | 0001\n  return (value << 1) | (value >> 7);\n}\n\nexport function rotateByteLeftThroughCarry(value: u8): u8 {\n  // Example: https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n  // Through carry meaning, instead of raotating the bit that gets dropped off, but the carry there instead\n  return (value << 1) | getCarryFlag();\n}\n\nexport function rotateByteRight(value: u8): u8 {\n  // Rotate right\n  // 4-bit example:\n  // 1010 -> 0101 | 0000\n  return (value >> 1) | (value << 7);\n}\n\nexport function rotateByteRightThroughCarry(value: u8): u8 {\n  // Example: https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n  // Through carry meaning, instead of raotating the bit that gets dropped off, put the carry there instead\n  return (value >> 1) | (getCarryFlag() << 7);\n}\n\nexport function setBitOnByte(bitPosition: u8, byte: u8): u8 {\n  return byte | (0x01 << bitPosition);\n}\n\nexport function resetBitOnByte(bitPosition: u8, byte: u8): u8 {\n  return byte & ~(0x01 << bitPosition);\n}\n\nexport function checkBitOnByte(bitPosition: u8, byte: u8): boolean {\n  // Perforamnce improvements\n  // https://github.com/AssemblyScript/assemblyscript/issues/40\n  return (<u32>byte & (1 << bitPosition)) != 0;\n}\n\nnamespace env {\n  export declare function log(message: string, arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: i32, arg5: i32): void;\n  export declare function hexLog(arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: i32, arg5: i32): void;\n  export declare function performanceTimestamp(id: i32, value: i32): void;\n}\n\nexport function log(message: string, arg0: i32 = -9999, arg1: i32 = -9999, arg2: i32 = -9999, arg3: i32 = -9999, arg4: i32 = -9999, arg5: i32 = -9999): void {\n  env.log(message, arg0, arg1, arg2, arg3, arg4, arg5);\n}\n\nexport function hexLog(arg0: i32 = -9999, arg1: i32 = -9999, arg2: i32 = -9999, arg3: i32 = -9999, arg4: i32 = -9999, arg5: i32 = -9999): void {\n  env.hexLog(arg0, arg1, arg2, arg3, arg4, arg5);\n}\n\nexport function performanceTimestamp(id: i32 = -9999, value: i32 = -9999): void {\n  env.performanceTimestamp(id, value);\n}\n","// Store / Write memory access\nimport {\n  checkWriteTraps\n} from './writeTraps';\nimport {\n  getWasmBoyOffsetFromGameBoyOffset\n} from './memoryMap';\nimport {\n  splitHighByte,\n  splitLowByte,\n  hexLog\n} from '../helpers/index';\n\nexport function eightBitStoreIntoGBMemory(offset: u16, value: u8): void {\n  if(checkWriteTraps(offset, <u16>value, true)) {\n    _eightBitStoreIntoWasmBoyMemory(offset, value);\n  }\n}\n\nexport function sixteenBitStoreIntoGBMemory(offset: u16, value: u16): void {\n\n  // Dividing into two seperate eight bit calls to help with debugging tilemap overwrites\n  // Split the value into two seperate bytes\n  let highByte: u8 = splitHighByte(value);\n  let lowByte: u8 = splitLowByte(value);\n  let nextOffset: u16 = offset + 1;\n\n  if(checkWriteTraps(offset, lowByte, false)) {\n    _eightBitStoreIntoWasmBoyMemory(offset, lowByte);\n  }\n\n  if(checkWriteTraps(nextOffset, highByte, false)) {\n    _eightBitStoreIntoWasmBoyMemory(nextOffset, highByte);\n  }\n}\n\nexport function eightBitStoreIntoGBMemorySkipTraps(offset: u16, value: u8): void {\n  _eightBitStoreIntoWasmBoyMemory(offset, value);\n}\n\nexport function sixteenBitStoreIntoGBMemorySkipTraps(offset: u16, value: u16): void {\n\n  // Dividing into two seperate eight bit calls to help with debugging tilemap overwrites\n  // Split the value into two seperate bytes\n  let highByte: u8 = splitHighByte(value);\n  let lowByte: u8 = splitLowByte(value);\n  let nextOffset: u16 = offset + 1;\n\n  _eightBitStoreIntoWasmBoyMemory(offset, lowByte);\n  _eightBitStoreIntoWasmBoyMemory(nextOffset, highByte);\n}\n\nfunction _eightBitStoreIntoWasmBoyMemory(gameboyOffset: u16, value: u8): void {\n  store<u8>(getWasmBoyOffsetFromGameBoyOffset(gameboyOffset), value);\n}\n\nexport function storeBooleanDirectlyToWasmMemory(offset: u32, value: boolean): void {\n  if (value) {\n    store<u8>(offset, 0x01);\n  } else {\n    store<u8>(offset, 0x00);\n  }\n}\n","// NOTE: Tons of Copy-pasta btween channels, because Classes cannot be instantiated yet in assemblyscript\n\n// Square Channel with Frequency Sweep\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Square_Wave\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Frequency_Sweep\n\nimport {\n  getChannelStartingVolume,\n  isChannelDacEnabled\n} from './registers';\nimport {\n  getChannelFrequency,\n  setChannelFrequency\n} from './frequency';\nimport {\n  isChannelLengthEnabled\n} from './length';\nimport {\n  getChannelEnvelopePeriod,\n  getChannelEnvelopeAddMode\n} from './envelope';\nimport {\n  isDutyCycleClockPositiveOrNegativeForWaveform\n} from './duty';\nimport {\n  Cpu\n} from '../cpu/cpu';\nimport {\n  eightBitLoadFromGBMemorySkipTraps,\n  eightBitStoreIntoGBMemorySkipTraps,\n  getSaveStateMemoryOffset,\n  loadBooleanDirectlyFromWasmMemory,\n  storeBooleanDirectlyToWasmMemory\n} from '../memory/index';\nimport {\n  checkBitOnByte,\n  hexLog\n} from '../helpers/index';\n\nexport class Channel1 {\n\n  // Cycle Counter for our sound accumulator\n  static cycleCounter: i32 = 0;\n\n  // Squarewave channel with volume envelope and frequency sweep functions.\n  // NR10 -> Sweep Register R/W\n  static readonly memoryLocationNRx0: u16 = 0xFF10;\n  // NR11 -> Sound length/Wave pattern duty (R/W)\n  static readonly memoryLocationNRx1: u16 = 0xFF11;\n  // NR12 -> Volume Envelope (R/W)\n  static readonly memoryLocationNRx2: u16 = 0xFF12;\n  // NR13 -> Frequency lo (W)\n  static readonly memoryLocationNRx3: u16 = 0xFF13;\n  // NR14 -> Frequency hi (R/W)\n  static readonly memoryLocationNRx4: u16 = 0xFF14;\n\n  // Channel Properties\n  static readonly channelNumber: i32 = 1;\n  static isEnabled: boolean = false;\n  static frequencyTimer: i32 = 0x00;\n  static envelopeCounter: i32 = 0x00;\n  static lengthCounter: i32 = 0x00;\n  static volume: i32 = 0x00;\n\n  // Square Wave properties\n  static dutyCycle: u8 = 0x00;\n  static waveFormPositionOnDuty: u8 = 0x00;\n\n  // Channel 1 Sweep\n  static isSweepEnabled: boolean = false;\n  static sweepCounter: i32 = 0x00;\n  static sweepShadowFrequency: u16 = 0x00;\n\n  // Save States\n\n  static readonly saveStateSlot: u16 = 7;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x00, Channel1.saveStateSlot), Channel1.isEnabled);\n    store<i32>(getSaveStateMemoryOffset(0x01, Channel1.saveStateSlot), Channel1.frequencyTimer);\n    store<i32>(getSaveStateMemoryOffset(0x05, Channel1.saveStateSlot), Channel1.envelopeCounter);\n    store<i32>(getSaveStateMemoryOffset(0x09, Channel1.saveStateSlot), Channel1.lengthCounter);\n    store<i32>(getSaveStateMemoryOffset(0x0E, Channel1.saveStateSlot), Channel1.volume);\n\n    store<u8>(getSaveStateMemoryOffset(0x13, Channel1.saveStateSlot), Channel1.dutyCycle);\n    store<u8>(getSaveStateMemoryOffset(0x14, Channel1.saveStateSlot), Channel1.waveFormPositionOnDuty);\n\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x19, Channel1.saveStateSlot), Channel1.isSweepEnabled);\n    store<i32>(getSaveStateMemoryOffset(0x1A, Channel1.saveStateSlot), Channel1.sweepCounter);\n    store<u16>(getSaveStateMemoryOffset(0x1F, Channel1.saveStateSlot), Channel1.sweepShadowFrequency);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    Channel1.isEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x00, Channel1.saveStateSlot));\n    Channel1.frequencyTimer = load<i32>(getSaveStateMemoryOffset(0x01, Channel1.saveStateSlot));\n    Channel1.envelopeCounter = load<i32>(getSaveStateMemoryOffset(0x05, Channel1.saveStateSlot));\n    Channel1.lengthCounter = load<i32>(getSaveStateMemoryOffset(0x09, Channel1.saveStateSlot));\n    Channel1.volume = load<i32>(getSaveStateMemoryOffset(0x0E, Channel1.saveStateSlot));\n\n    Channel1.dutyCycle = load<u8>(getSaveStateMemoryOffset(0x13, Channel1.saveStateSlot));\n    Channel1.waveFormPositionOnDuty = load<u8>(getSaveStateMemoryOffset(0x14, Channel1.saveStateSlot));\n\n    Channel1.isSweepEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x19, Channel1.saveStateSlot));\n    Channel1.sweepCounter = load<i32>(getSaveStateMemoryOffset(0x1A, Channel1.saveStateSlot));\n    Channel1.sweepShadowFrequency = load<u16>(getSaveStateMemoryOffset(0x1F, Channel1.saveStateSlot));\n  }\n\n\n  static initialize(): void {\n    eightBitStoreIntoGBMemorySkipTraps(Channel1.memoryLocationNRx0, 0x80);\n    eightBitStoreIntoGBMemorySkipTraps(Channel1.memoryLocationNRx1, 0xBF);\n    eightBitStoreIntoGBMemorySkipTraps(Channel1.memoryLocationNRx2, 0xF3);\n    eightBitStoreIntoGBMemorySkipTraps(Channel1.memoryLocationNRx3, 0xC1);\n    eightBitStoreIntoGBMemorySkipTraps(Channel1.memoryLocationNRx4, 0xBF);\n  }\n\n  // Function to get a sample using the cycle counter on the channel\n  static getSampleFromCycleCounter(): i32 {\n    let accumulatedCycles: i32 = Channel1.cycleCounter;\n    Channel1.cycleCounter = 0;\n    return Channel1.getSample(accumulatedCycles);\n  }\n\n  // Function to reset our timer, useful for GBC double speed mode\n  static resetTimer(): void {\n    Channel1.frequencyTimer = (2048 - getChannelFrequency(Channel1.channelNumber)) * 4;\n\n    // TODO: Ensure this is correct for GBC Double Speed Mode\n    if (Cpu.GBCDoubleSpeed) {\n      Channel1.frequencyTimer = Channel1.frequencyTimer * 2;\n    }\n  }\n\n  static getSample(numberOfCycles: i32): i32 {\n\n    // Decrement our channel timer\n    Channel1.frequencyTimer -= numberOfCycles;\n    if(Channel1.frequencyTimer <= 0) {\n\n      // Get the amount that overflowed so we don't drop cycles\n      let overflowAmount: i32 = abs(Channel1.frequencyTimer);\n\n      // Reset our timer\n      // A square channel's frequency timer period is set to (2048-frequency)*4.\n      // Four duty cycles are available, each waveform taking 8 frequency timer clocks to cycle through:\n      Channel1.resetTimer();\n      Channel1.frequencyTimer -= overflowAmount;\n\n      // Also increment our duty cycle\n      // What is duty? https://en.wikipedia.org/wiki/Duty_cycle\n      // Duty cycle for square wave: http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Square_Wave\n      Channel1.waveFormPositionOnDuty += 1;\n      if (Channel1.waveFormPositionOnDuty >= 8) {\n        Channel1.waveFormPositionOnDuty = 0;\n      }\n    }\n\n    // Get our ourput volume\n    let outputVolume: i32 = 0;\n\n    // Finally to set our output volume, the channel must be enabled,\n    // Our channel DAC must be enabled, and we must be in an active state\n    // Of our duty cycle\n    if(Channel1.isEnabled &&\n    isChannelDacEnabled(Channel1.channelNumber)) {\n      outputVolume = Channel1.volume;\n    } else {\n      // Return silence\n      // Since range from -15 - 15, or 0 to 30 for our unsigned\n      return 15;\n    }\n\n    // Get the current sampleValue\n    let sample: i32 = 1;\n    if (!isDutyCycleClockPositiveOrNegativeForWaveform(1, Channel1.waveFormPositionOnDuty)) {\n      sample = sample * -1;\n    }\n\n    sample = sample * outputVolume;\n\n    // Square Waves Can range from -15 - 15. Therefore simply add 15\n    sample = sample + 15;\n    return <i32>sample;\n  }\n\n  //http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Trigger_Event\n  static trigger(): void {\n    Channel1.isEnabled = true;\n    if(Channel1.lengthCounter === 0) {\n      Channel1.lengthCounter = 64;\n    }\n\n    // Reset our timer\n    // A square channel's frequency timer period is set to (2048-frequency)*4.\n    // Four duty cycles are available, each waveform taking 8 frequency timer clocks to cycle through:\n    Channel1.resetTimer();\n\n    Channel1.envelopeCounter = getChannelEnvelopePeriod(Channel1.channelNumber);\n\n    Channel1.volume = getChannelStartingVolume(Channel1.channelNumber);\n\n    // Handle Channel Sweep\n    // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware\n    Channel1.sweepShadowFrequency = getChannelFrequency(Channel1.channelNumber);\n\n    // Reset back to the sweep period\n    Channel1.sweepCounter = getSweepPeriod();\n\n    // The internal enabled flag is set if either the sweep period or shift are non-zero, cleared otherwise.\n    if(getSweepPeriod() > 0 && getSweepShift() > 0) {\n      Channel1.isSweepEnabled = true;\n    } else {\n      Channel1.isSweepEnabled = false;\n    }\n\n    // If the sweep shift is non-zero, frequency calculation and the overflow check are performed immediately.\n    if(getSweepShift() > 0) {\n        calculateSweepAndCheckOverflow();\n    }\n\n    // Finally if DAC is off, channel is still disabled\n    if(!isChannelDacEnabled(Channel1.channelNumber)) {\n      Channel1.isEnabled = false;\n    }\n  }\n\n  // Function to determine if the current channel would update when getting the sample\n  // This is used to accumulate samples\n  static willChannelUpdate(numberOfCycles: i32): boolean {\n\n    //Increment our cycle counter\n    Channel1.cycleCounter += numberOfCycles;\n\n    if (Channel1.frequencyTimer - Channel1.cycleCounter > 0 &&\n      isChannelDacEnabled(Channel1.channelNumber)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  static updateSweep(): void {\n    // Obscure behavior\n    // TODO: The volume envelope and sweep timers treat a period of 0 as 8.\n    // Decrement the sweep counter\n    Channel1.sweepCounter -= 1;\n\n    if (Channel1.sweepCounter <= 0) {\n\n      // Reset back to the sweep period\n      Channel1.sweepCounter = getSweepPeriod();\n\n      // Calculate our sweep\n      // When it generates a clock and the sweep's internal enabled flag is set and the sweep period is not zero,\n      // a new frequency is calculated and the overflow check is performed.\n      if(Channel1.isSweepEnabled && getSweepPeriod() > 0) {\n        calculateSweepAndCheckOverflow();\n      }\n    }\n  }\n\n  static updateLength(): void {\n\n    if(Channel1.lengthCounter > 0 && isChannelLengthEnabled(Channel1.channelNumber)) {\n      Channel1.lengthCounter -= 1;\n    }\n\n    if(Channel1.lengthCounter === 0) {\n      Channel1.isEnabled = false;\n    }\n  }\n\n  static updateEnvelope(): void {\n\n    // Obscure behavior\n    // TODO: The volume envelope and sweep timers treat a period of 0 as 8.\n\n    Channel1.envelopeCounter -= 1;\n    if (Channel1.envelopeCounter <= 0) {\n      Channel1.envelopeCounter = getChannelEnvelopePeriod(Channel1.channelNumber);\n\n      // When the timer generates a clock and the envelope period is NOT zero, a new volume is calculated\n      // NOTE: There is some weiirrdd obscure behavior where zero can equal 8, so watch out for that\n      // If notes are sustained for too long, this is probably why\n      if(Channel1.envelopeCounter !== 0) {\n        if(getChannelEnvelopeAddMode(Channel1.channelNumber) && Channel1.volume < 15) {\n          Channel1.volume += 1;\n        } else if (!getChannelEnvelopeAddMode(Channel1.channelNumber) && Channel1.volume > 0) {\n          Channel1.volume -= 1;\n        }\n      }\n    }\n  }\n  // Done!\n}\n\n\n// Sweep Specific functions\n\nfunction getSweepPeriod(): u8 {\n  let sweepRegister: u8 = eightBitLoadFromGBMemorySkipTraps(Channel1.memoryLocationNRx0);\n  // Get bits 4-6\n  let sweepPeriod: u8 = sweepRegister & 0x70;\n  sweepPeriod = (sweepPeriod >> 4);\n  return sweepPeriod;\n}\n\nfunction getSweepShift(): u8 {\n  let sweepRegister: u8 = eightBitLoadFromGBMemorySkipTraps(Channel1.memoryLocationNRx0);\n  // Get bits 0-2\n  let sweepShift: u8 = sweepRegister & 0x07;\n\n  return sweepShift;\n}\n\nfunction calculateSweepAndCheckOverflow(): void {\n\n  let newFrequency: u16 = getNewFrequencyFromSweep();\n  // 7FF is the highest value of the frequency: 111 1111 1111\n  if (newFrequency <= 0x7FF && getSweepShift() > 0) {\n    // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware\n    // If the new frequency is 2047 or less and the sweep shift is not zero,\n    // this new frequency is written back to the shadow frequency and square 1's frequency in NR13 and NR14,\n    // then frequency calculation and overflow check are run AGAIN immediately using this new value,\n    // but this second new frequency is not written back.\n    Channel1.sweepShadowFrequency = newFrequency;\n    setChannelFrequency(Channel1.channelNumber, newFrequency);\n    // Re calculate the new frequency\n    newFrequency = getNewFrequencyFromSweep();\n  }\n\n  // Next check if the new Frequency is above 0x7FF\n  // if So, disable our sweep\n  if (newFrequency > 0x7FF) {\n    Channel1.isEnabled = false;\n  }\n}\n\n// Function to determing a new sweep in the current context\nfunction getNewFrequencyFromSweep(): u16 {\n\n  // Start our new frequency, by making it equal to the \"shadow frequency\"\n  let newFrequency: u16 = Channel1.sweepShadowFrequency;\n  newFrequency = (newFrequency >> getSweepShift());\n\n  // Check for sweep negation\n  let sweepRegister: u8 = eightBitLoadFromGBMemorySkipTraps(Channel1.memoryLocationNRx0);\n  if (checkBitOnByte(3, sweepRegister)) {\n    newFrequency = Channel1.sweepShadowFrequency - newFrequency;\n  } else {\n    newFrequency = Channel1.sweepShadowFrequency + newFrequency;\n  }\n\n  return newFrequency;\n}\n","// https://emu-docs.org/Game%20Boy/gb_sound.txt\n// https://www.youtube.com/watch?v=HyzD8pNlpwI\n// https://gist.github.com/drhelius/3652407\n\n// For our wasm -> JS, we will be passing in our -1.0 to 1.0 volume\n// As an unsigned byte. Each channel will give 0 (representing -1.0), to\n// 30 (representing 1.0), and will be added together. in the fucntion\n// getSampleAsUnsignedByte() will do the conversion of getting the total\n// of all the channels, times the (mixer volume + 1), to give us an unsigned\n// byte from 0 (-1.0) to 254 (1.0)\n\nimport {\n    Channel1\n} from './channel1';\nimport {\n    Channel2\n} from './channel2';\nimport {\n    Channel3\n} from './channel3';\nimport {\n    Channel4\n} from './channel4';\nimport {\n  isChannelEnabledOnLeftOutput,\n  isChannelEnabledOnRightOutput\n} from './registers';\nimport {\n  Cpu\n} from '../cpu/index';\nimport {\n  Config\n} from '../config';\nimport {\n  eightBitLoadFromGBMemorySkipTraps,\n  eightBitStoreIntoGBMemorySkipTraps,\n  setLeftAndRightOutputForAudioQueue,\n  getSaveStateMemoryOffset,\n  loadBooleanDirectlyFromWasmMemory,\n  storeBooleanDirectlyToWasmMemory\n} from '../memory/index';\nimport {\n  concatenateBytes,\n  splitLowByte,\n  splitHighByte,\n  hexLog,\n  performanceTimestamp\n} from '../helpers/index';\n\nexport class Sound {\n\n  // Current cycles\n  // This will be used for batch processing\n  // https://github.com/binji/binjgb/commit/e028f45e805bc0b0aa4697224a209f9ae514c954\n  // TODO: May Also need to do this for Reads\n  static currentCycles: i32 = 0;\n\n  // Number of cycles to run in each batch process\n  // This number should be in sync so that sound doesn't run too many cyles at once\n  // and does not exceed the minimum number of cyles for either down sampling, or\n  // How often we change the frame, or a channel's update process\n  static batchProcessCycles(): i32 {\n    if (Cpu.GBCDoubleSpeed) {\n      return 174;\n    }\n\n    return 87;\n  }\n\n  // Channel control / On-OFF / Volume (RW)\n  static readonly memoryLocationNR50: u16 = 0xFF24;\n\n  // 0xFF25 selects which output each channel goes to, Referred to as NR51\n  static readonly memoryLocationNR51: u16 = 0xFF25;\n\n  // Sound on/off\n  static readonly memoryLocationNR52: u16 = 0xFF26;\n\n  // $FF30 -- $FF3F is the load register space for the 4-bit samples for channel 3\n  static readonly memoryLocationChannel3LoadRegisterStart: u16 = 0xFF30;\n\n  // Need to count how often we need to increment our frame sequencer\n  // Which you can read about below\n  static frameSequenceCycleCounter: i32 = 0x0000;\n  static maxFrameSequenceCycles(): i32 {\n    if (Cpu.GBCDoubleSpeed) {\n      return 16384;\n    }\n\n    return 8192;\n  }\n\n  // Also need to downsample our audio to average audio qualty\n  // https://www.reddit.com/r/EmuDev/comments/5gkwi5/gb_apu_sound_emulation/\n  // Want to do 48000hz, so CpuRate / Sound Rate, 4194304 / 48000 ~ 87 cycles\n  static downSampleCycleCounter: i32 = 0x00;\n  static downSampleCycleMultiplier: i32 = 48000;\n  static maxDownSampleCycles(): i32 {\n    return Cpu.CLOCK_SPEED();\n  }\n\n  // Frame sequencer controls what should be updated and and ticked\n  // Everyt time the sound is updated :) It is updated everytime the\n  // Cycle counter reaches the max cycle\n  static frameSequencer: u8 = 0x00;\n\n  // Our current sample number we are passing back to the wasmboy memory map\n  // Found that a static number of samples doesn't work well on mobile\n  // Will just update the queue index, grab as much as we can whenever we need more audio, then reset\n  // NOTE: Giving a really large sample rate gives more latency, but less pops!\n  //static readonly MAX_NUMBER_OF_SAMPLES: i32 = 4096;\n  static audioQueueIndex: i32 = 0x0000\n  static wasmBoyMemoryMaxBufferSize: i32 = 0x20000;\n\n  // Save States\n  static readonly saveStateSlot: u16 = 6;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    store<i32>(getSaveStateMemoryOffset(0x00, Sound.saveStateSlot), Sound.frameSequenceCycleCounter);\n    store<u8>(getSaveStateMemoryOffset(0x04, Sound.saveStateSlot), Sound.downSampleCycleCounter);\n    store<u8>(getSaveStateMemoryOffset(0x05, Sound.saveStateSlot), Sound.frameSequencer);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    Sound.frameSequenceCycleCounter = load<i32>(getSaveStateMemoryOffset(0x00, Sound.saveStateSlot));\n    Sound.downSampleCycleCounter = load<u8>(getSaveStateMemoryOffset(0x04, Sound.saveStateSlot));\n    Sound.frameSequencer = load<u8>(getSaveStateMemoryOffset(0x05, Sound.saveStateSlot));\n\n    resetAudioQueue();\n  }\n}\n\n// Another class simply for accumulating samples\n// Default everything to silence\nexport class SoundAccumulator {\n  static channel1Sample: i32 = 15;\n  static channel2Sample: i32 = 15;\n  static channel3Sample: i32 = 15;\n  static channel4Sample: i32 = 15;\n  static leftChannelSampleUnsignedByte: u8 = 127;\n  static rightChannelSampleUnsignedByte: u8 = 127;\n  static mixerVolumeChanged: boolean = false;\n  static mixerEnabledChanged: boolean = false;\n}\n\n// Initialize sound registers\n// From: https://emu-docs.org/Game%20Boy/gb_sound.txt\nexport function initializeSound(): void {\n\n  // intiialize our channels\n  Channel1.initialize();\n  Channel2.initialize();\n  Channel3.initialize();\n  Channel4.initialize();\n\n  // Other Sound Registers\n  eightBitStoreIntoGBMemorySkipTraps(Sound.memoryLocationNR50, 0x77);\n  eightBitStoreIntoGBMemorySkipTraps(Sound.memoryLocationNR51, 0xF3);\n  eightBitStoreIntoGBMemorySkipTraps(Sound.memoryLocationNR52, 0xF1);\n\n  SoundAccumulator.mixerVolumeChanged = true;\n  SoundAccumulator.mixerEnabledChanged = true;\n}\n\n// Function to batch process our audio after we skipped so many cycles\nexport function batchProcessAudio(): void {\n\n  if (Sound.currentCycles < Sound.batchProcessCycles()) {\n    return;\n  }\n\n  while (Sound.currentCycles >= Sound.batchProcessCycles()) {\n    updateSound(Sound.batchProcessCycles());\n    Sound.currentCycles = Sound.currentCycles - Sound.batchProcessCycles();\n  }\n}\n\n// Function for updating sound\nexport function updateSound(numberOfCycles: i32): void {\n\n  // Check if our frameSequencer updated\n  let frameSequencerUpdated: boolean = updateFrameSequencer(numberOfCycles);\n\n  if(Config.audioAccumulateSamples && !frameSequencerUpdated) {\n    accumulateSound(numberOfCycles);\n  } else {\n    calculateSound(numberOfCycles);\n  }\n}\n\n// Funciton to get the current Audio Queue index\nexport function getAudioQueueIndex(): i32 {\n  return Sound.audioQueueIndex;\n}\n\n// Function to reset the audio queue\nexport function resetAudioQueue(): void {\n  Sound.audioQueueIndex = 0;\n}\n\nfunction calculateSound(numberOfCycles: i32): void {\n\n  // Update all of our channels\n  // All samples will be returned as 0 to 30\n  // 0 being -1.0, and 30 being 1.0\n  // (see blurb at top)\n  let channel1Sample: i32 = Channel1.getSample(numberOfCycles);\n  let channel2Sample: i32 = Channel2.getSample(numberOfCycles);\n  let channel3Sample: i32 = Channel3.getSample(numberOfCycles);\n  let channel4Sample: i32 = Channel4.getSample(numberOfCycles);\n\n  // Save the samples in the accumulator\n  SoundAccumulator.channel1Sample = channel1Sample;\n  SoundAccumulator.channel2Sample = channel2Sample;\n  SoundAccumulator.channel3Sample = channel3Sample;\n  SoundAccumulator.channel4Sample = channel4Sample;\n\n  // Do Some downsampling magic\n  Sound.downSampleCycleCounter += (numberOfCycles * Sound.downSampleCycleMultiplier);\n  if(Sound.downSampleCycleCounter >= Sound.maxDownSampleCycles()) {\n\n    // Reset the downsample counter\n    // Don't set to zero to catch overflowed cycles\n    Sound.downSampleCycleCounter -= Sound.maxDownSampleCycles();\n\n    // Mixe our samples\n    let mixedSample: u16 = mixChannelSamples(channel1Sample, channel2Sample, channel3Sample, channel4Sample);\n    let leftChannelSampleUnsignedByte: u8 = splitHighByte(mixedSample);\n    let rightChannelSampleUnsignedByte: u8 = splitLowByte(mixedSample);\n\n    // Set our volumes in memory\n    // +1 so it can not be zero\n    setLeftAndRightOutputForAudioQueue(leftChannelSampleUnsignedByte + 1, rightChannelSampleUnsignedByte + 1, Sound.audioQueueIndex);\n    Sound.audioQueueIndex += 1;\n\n    // Don't allow our audioQueueIndex to overflow into other parts of the wasmBoy memory map\n    // https://docs.google.com/spreadsheets/d/17xrEzJk5-sCB9J2mMJcVnzhbE-XH_NvczVSQH9OHvRk/edit#gid=0\n    // Not 0xFFFF because we need half of 64kb since we store left and right channel\n    if(Sound.audioQueueIndex >= (Sound.wasmBoyMemoryMaxBufferSize / 2) - 1) {\n      Sound.audioQueueIndex -= 1;\n    }\n  }\n}\n\nfunction accumulateSound(numberOfCycles: i32): void {\n\n  // Check if any of the individual channels will update\n  let channel1WillUpdate: boolean = Channel1.willChannelUpdate(numberOfCycles);\n  let channel2WillUpdate: boolean = Channel2.willChannelUpdate(numberOfCycles);\n  let channel3WillUpdate: boolean = Channel3.willChannelUpdate(numberOfCycles);\n  let channel4WillUpdate: boolean = Channel4.willChannelUpdate(numberOfCycles);\n\n  if (channel1WillUpdate) {\n    SoundAccumulator.channel1Sample = Channel1.getSampleFromCycleCounter();\n  }\n  if (channel2WillUpdate) {\n    SoundAccumulator.channel2Sample = Channel2.getSampleFromCycleCounter();\n  }\n  if (channel3WillUpdate) {\n    SoundAccumulator.channel3Sample = Channel3.getSampleFromCycleCounter();\n  }\n  if (channel4WillUpdate) {\n    SoundAccumulator.channel4Sample = Channel4.getSampleFromCycleCounter();\n  }\n\n  // If any channel updated, we need to re-mix our samples\n  if(channel1WillUpdate ||\n    channel2WillUpdate ||\n    channel3WillUpdate ||\n    channel4WillUpdate) {\n    mixChannelSamples(SoundAccumulator.channel1Sample, SoundAccumulator.channel2Sample, SoundAccumulator.channel3Sample, SoundAccumulator.channel4Sample);\n  }\n\n  // Do Some downsampling magic\n  Sound.downSampleCycleCounter += (numberOfCycles * Sound.downSampleCycleMultiplier);\n  if(Sound.downSampleCycleCounter >= Sound.maxDownSampleCycles()) {\n\n    // Reset the downsample counter\n    // Don't set to zero to catch overflowed cycles\n    Sound.downSampleCycleCounter -= Sound.maxDownSampleCycles();\n\n    if (SoundAccumulator.mixerVolumeChanged ||\n      SoundAccumulator.mixerEnabledChanged) {\n      mixChannelSamples(SoundAccumulator.channel1Sample, SoundAccumulator.channel2Sample, SoundAccumulator.channel3Sample, SoundAccumulator.channel4Sample);\n    }\n\n    // Finally Simply place the accumulated sample in memory\n    // Set our volumes in memory\n    // +1 so it can not be zero\n    setLeftAndRightOutputForAudioQueue(SoundAccumulator.leftChannelSampleUnsignedByte + 1, SoundAccumulator.rightChannelSampleUnsignedByte + 1, Sound.audioQueueIndex);\n    Sound.audioQueueIndex += 1;\n\n    // Don't allow our audioQueueIndex to overflow into other parts of the wasmBoy memory map\n    // https://docs.google.com/spreadsheets/d/17xrEzJk5-sCB9J2mMJcVnzhbE-XH_NvczVSQH9OHvRk/edit#gid=0\n    // Not 0xFFFF because we need half of 64kb since we store left and right channel\n    if(Sound.audioQueueIndex >= (Sound.wasmBoyMemoryMaxBufferSize / 2) - 1) {\n      Sound.audioQueueIndex -= 1;\n    }\n  }\n}\n\nfunction updateFrameSequencer(numberOfCycles: i32): boolean {\n  // APU runs at 4194304 / 512\n  // Or Cpu.clockSpeed / 512\n  // Which means, we need to update once every 8192 cycles :)\n  Sound.frameSequenceCycleCounter += numberOfCycles;\n  if(Sound.frameSequenceCycleCounter >= Sound.maxFrameSequenceCycles()) {\n    // Reset the frameSequenceCycleCounter\n    // Not setting to zero as we do not want to drop cycles\n    Sound.frameSequenceCycleCounter -= Sound.maxFrameSequenceCycles();\n\n    // Check our frame sequencer\n    // https://gist.github.com/drhelius/3652407\n    switch (Sound.frameSequencer) {\n      case 0:\n        // Update Length on Channels\n        Channel1.updateLength();\n        Channel2.updateLength();\n        Channel3.updateLength();\n        Channel4.updateLength();\n        break;\n      /* Do Nothing on one */\n      case 2:\n        // Update Sweep and Length on Channels\n        Channel1.updateLength();\n        Channel2.updateLength();\n        Channel3.updateLength();\n        Channel4.updateLength();\n\n        Channel1.updateSweep();\n        break;\n      /* Do Nothing on three */\n      case 4:\n        // Update Length on Channels\n        Channel1.updateLength();\n        Channel2.updateLength();\n        Channel3.updateLength();\n        Channel4.updateLength();\n        break;\n      /* Do Nothing on five */\n      case 6:\n        // Update Sweep and Length on Channels\n        Channel1.updateLength();\n        Channel2.updateLength();\n        Channel3.updateLength();\n        Channel4.updateLength();\n\n        Channel1.updateSweep();\n        break;\n      case 7:\n        // Update Envelope on channels\n        Channel1.updateEnvelope();\n        Channel2.updateEnvelope();\n        Channel4.updateEnvelope();\n        break;\n    }\n\n    // Update our frame sequencer\n    Sound.frameSequencer += 1;\n    if(Sound.frameSequencer >= 8) {\n      Sound.frameSequencer = 0;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\n\nfunction mixChannelSamples(channel1Sample: i32 = 15, channel2Sample: i32 = 15, channel3Sample: i32 = 15, channel4Sample: i32 = 15): u16 {\n\n  // Do Some Cool mixing\n  // NR50 FF24 ALLL BRRR Vin L enable, Left vol, Vin R enable, Right vol\n  // NR51 FF25 NW21 NW21 Left enables, Right enables\n  // NR52 FF26 P--- NW21 Power control/status, Channel length statuses\n  // NW21 = 4 bits on byte\n  // 3 -> Channel 4, 2 -> Channel 3, 1 -> Channel 2, 0 -> Channel 1\n\n  // Matt's Proccess\n  // I push out 1024 samples at a time and use 96000 hz sampling rate, so I guess i'm a bit less than one frame,\n  // but I let the queue fill up with 4 x 1024 samples before I start waiting for the audio\n\n  // TODO: Vin Mixing\n\n  // Simply get the left/right volume, add up the values, and put into memory!\n  let registerNR50 = eightBitLoadFromGBMemorySkipTraps(Sound.memoryLocationNR50);\n  // Want bits 6-4\n  let leftMixerVolume: i32 = (registerNR50 >> 4);\n  leftMixerVolume = leftMixerVolume & 0x07;\n  // Want bits 0-2\n  let rightMixerVolume: i32 = registerNR50;\n  rightMixerVolume = rightMixerVolume & 0x07;\n\n  SoundAccumulator.mixerVolumeChanged = false;\n\n  // cache channel numbers for performance\n  let channel1ChannelNumber: i32 = Channel1.channelNumber;\n  let channel2ChannelNumber: i32 = Channel2.channelNumber;\n  let channel3ChannelNumber: i32 = Channel3.channelNumber;\n  let channel4ChannelNumber: i32 = Channel4.channelNumber;\n\n  // Get our channel volume for left/right\n  let leftChannelSample: i32 = 0;\n  let rightChannelSample: i32 = 0;\n\n  // Find the sample for the left if enabled\n  // other wise add silence (15) for the channel\n  if (isChannelEnabledOnLeftOutput(channel1ChannelNumber)) {\n    leftChannelSample += channel1Sample;\n  } else {\n    leftChannelSample += 15;\n  }\n  if (isChannelEnabledOnLeftOutput(channel2ChannelNumber)) {\n    leftChannelSample += channel2Sample;\n  } else {\n    leftChannelSample += 15;\n  }\n  if (isChannelEnabledOnLeftOutput(channel3ChannelNumber)) {\n    leftChannelSample += channel3Sample;\n  } else {\n    leftChannelSample += 15;\n  }\n  if (isChannelEnabledOnLeftOutput(channel4ChannelNumber)) {\n    leftChannelSample += channel4Sample;\n  } else {\n    leftChannelSample += 15;\n  }\n\n\n  // Find the sample for the right if enabled\n  // other wise add silence (15) for the channel\n  if (isChannelEnabledOnRightOutput(channel1ChannelNumber)) {\n    rightChannelSample += channel1Sample;\n  } else {\n    rightChannelSample += 15;\n  }\n  if (isChannelEnabledOnRightOutput(channel2ChannelNumber)) {\n    rightChannelSample += channel2Sample;\n  } else {\n    rightChannelSample += 15;\n  }\n  if (isChannelEnabledOnRightOutput(channel3ChannelNumber)) {\n    rightChannelSample += channel3Sample;\n  } else {\n    rightChannelSample += 15;\n  }\n  if (isChannelEnabledOnRightOutput(channel4ChannelNumber)) {\n    rightChannelSample += channel4Sample;\n  } else {\n    rightChannelSample += 15;\n  }\n\n  SoundAccumulator.mixerEnabledChanged = false;\n\n  // Finally multiply our volumes by the mixer volume\n  // Mixer volume can be at most 7 + 1\n  // Can be at most 7, because we only have 3 bits, 111 = 7\n  // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Mixer\n  // Done in the getSampleAsUnsignedByte(), since we are doing some weirdness there :)\n\n  // Convert our samples from unsigned 32 to unsigned byte\n  // Reason being, We want to be able to pass in wasm memory as usigned byte. Javascript will handle the conversion back\n  let leftChannelSampleUnsignedByte: u8 = getSampleAsUnsignedByte(leftChannelSample, (leftMixerVolume + 1));\n  let rightChannelSampleUnsignedByte: u8 = getSampleAsUnsignedByte(rightChannelSample, (rightMixerVolume + 1));\n\n  // Save these samples in the accumulator\n  SoundAccumulator.leftChannelSampleUnsignedByte = leftChannelSampleUnsignedByte;\n  SoundAccumulator.rightChannelSampleUnsignedByte = rightChannelSampleUnsignedByte;\n\n  return concatenateBytes(leftChannelSampleUnsignedByte, rightChannelSampleUnsignedByte);\n}\n\nfunction getSampleAsUnsignedByte(sample: i32, mixerVolume: i32): u8 {\n\n  // If the sample is silence, return silence as unsigned byte\n  // Silence is common, and should be checked for performance\n  if(sample === 60) {\n    return 127;\n  }\n\n  // convert to a signed, precise scale of -6000 to 6000 (cheap way of -1.0 to 1.0)\n  // Multiply by the mixer volume fraction (to find the actual volume)\n  let precision: i32 = 100000;\n  let convertedSample: i32 = sample - 60;\n  convertedSample = convertedSample * precision;\n\n  // Multiply by the mixer volume fraction (to find the actual volume)\n  convertedSample = convertedSample * mixerVolume / 8;\n\n  // Convert back to scale of 0 to 120\n  convertedSample = convertedSample / precision;\n  convertedSample = convertedSample + 60;\n\n  // Finally, convert to an unsigned byte scale\n  // With Four Channels (0 to 30) and no global volume. Max is 120\n  // max unsigned byte goal is 254 (see blurb at top).\n  // 120 / 254 should give the correct conversion\n  // For example, 120 / 254 = 0.47244094488188976\n  // Multiply by 1000 to increase the float into an int\n  // so, 120 * 1000 / (0.47244094488188976 * 1000) should give approximate answer for max mixer volume\n  let maxDivider: i32 = (120 * precision) / 254;\n  convertedSample = (convertedSample * precision) / maxDivider;\n\n  return <u8>(convertedSample);\n}\n","// NOTE: Tons of Copy-pasta btween channels, because Classes cannot be instantiated yet in assemblyscript\n\n// Simple Square Channel\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Square_Wave\n\nimport {\n  getChannelStartingVolume,\n  isChannelDacEnabled,\n  getRegister2OfChannel\n} from './registers';\nimport {\n  getChannelFrequency,\n  setChannelFrequency\n} from './frequency';\nimport {\n  isChannelLengthEnabled\n} from './length';\nimport {\n  getChannelEnvelopePeriod,\n  getChannelEnvelopeAddMode\n} from './envelope';\nimport {\n  isDutyCycleClockPositiveOrNegativeForWaveform\n} from './duty';\nimport {\n  Cpu\n} from '../cpu/cpu';\nimport {\n  eightBitLoadFromGBMemorySkipTraps,\n  eightBitStoreIntoGBMemorySkipTraps,\n  getSaveStateMemoryOffset,\n  loadBooleanDirectlyFromWasmMemory,\n  storeBooleanDirectlyToWasmMemory\n} from '../memory/index';\nimport {\n  checkBitOnByte,\n  hexLog\n} from '../helpers/index';\n\nexport class Channel2 {\n\n  // Cycle Counter for our sound accumulator\n  static cycleCounter: i32 = 0;\n\n  // Squarewave channel with volume envelope functions only.\n  // NR21 -> Sound length/Wave pattern duty (R/W)\n  static readonly memoryLocationNRx1: u16 = 0xFF16;\n  // NR22 -> Volume Envelope (R/W)\n  static readonly memoryLocationNRx2: u16 = 0xFF17;\n  // NR23 -> Frequency lo (W)\n  static readonly memoryLocationNRx3: u16 = 0xFF18;\n  // NR24 -> Frequency hi (R/W)\n  static readonly memoryLocationNRx4: u16 = 0xFF19;\n\n  // Channel Properties\n  static readonly channelNumber: i32 = 2;\n  static isEnabled: boolean = false;\n  static frequencyTimer: i32 = 0x00;\n  static envelopeCounter: i32 = 0x00;\n  static lengthCounter: i32 = 0x00;\n  static volume: i32 = 0x00;\n\n  // Square Wave properties\n  static dutyCycle: u8 = 0x00;\n  static waveFormPositionOnDuty: u8 = 0x00;\n\n  // Save States\n\n  static readonly saveStateSlot: u16 = 8;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x00, Channel2.saveStateSlot), Channel2.isEnabled);\n    store<i32>(getSaveStateMemoryOffset(0x01, Channel2.saveStateSlot), Channel2.frequencyTimer);\n    store<i32>(getSaveStateMemoryOffset(0x05, Channel2.saveStateSlot), Channel2.envelopeCounter);\n    store<i32>(getSaveStateMemoryOffset(0x09, Channel2.saveStateSlot), Channel2.lengthCounter);\n    store<i32>(getSaveStateMemoryOffset(0x0E, Channel2.saveStateSlot), Channel2.volume);\n\n    store<u8>(getSaveStateMemoryOffset(0x13, Channel2.saveStateSlot), Channel2.dutyCycle);\n    store<u8>(getSaveStateMemoryOffset(0x14, Channel2.saveStateSlot), Channel2.waveFormPositionOnDuty);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    Channel2.isEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x00, Channel2.saveStateSlot));\n    Channel2.frequencyTimer = load<i32>(getSaveStateMemoryOffset(0x01, Channel2.saveStateSlot));\n    Channel2.envelopeCounter = load<i32>(getSaveStateMemoryOffset(0x05, Channel2.saveStateSlot));\n    Channel2.lengthCounter = load<i32>(getSaveStateMemoryOffset(0x09, Channel2.saveStateSlot));\n    Channel2.volume = load<i32>(getSaveStateMemoryOffset(0x0E, Channel2.saveStateSlot));\n\n    Channel2.dutyCycle = load<u8>(getSaveStateMemoryOffset(0x13, Channel2.saveStateSlot));\n    Channel2.waveFormPositionOnDuty = load<u8>(getSaveStateMemoryOffset(0x14, Channel2.saveStateSlot));\n  }\n\n  static initialize(): void {\n    eightBitStoreIntoGBMemorySkipTraps(Channel2.memoryLocationNRx1 - 1, 0xFF);\n    eightBitStoreIntoGBMemorySkipTraps(Channel2.memoryLocationNRx1, 0x3F);\n    eightBitStoreIntoGBMemorySkipTraps(Channel2.memoryLocationNRx2, 0x00);\n    eightBitStoreIntoGBMemorySkipTraps(Channel2.memoryLocationNRx3, 0x00);\n    eightBitStoreIntoGBMemorySkipTraps(Channel2.memoryLocationNRx4, 0xB8);\n  }\n\n  // Function to get a sample using the cycle counter on the channel\n  static getSampleFromCycleCounter(): i32 {\n    let accumulatedCycles: i32 = Channel2.cycleCounter;\n    Channel2.cycleCounter =  0;\n    return Channel2.getSample(accumulatedCycles);\n  }\n\n  // Function to reset our timer, useful for GBC double speed mode\n  static resetTimer(): void {\n    Channel2.frequencyTimer = (2048 - getChannelFrequency(Channel2.channelNumber)) * 4;\n\n    // TODO: Ensure this is correct for GBC Double Speed Mode\n    if (Cpu.GBCDoubleSpeed) {\n      Channel2.frequencyTimer = Channel2.frequencyTimer * 2;\n    }\n  }\n\n  static getSample(numberOfCycles: i32): i32 {\n\n    // Decrement our channel timer\n    Channel2.frequencyTimer -= numberOfCycles;\n    if(Channel2.frequencyTimer <= 0) {\n\n      // Get the amount that overflowed so we don't drop cycles\n      let overflowAmount: i32 = abs(Channel2.frequencyTimer);\n\n      // Reset our timer\n      // A square channel's frequency timer period is set to (2048-frequency)*4.\n      // Four duty cycles are available, each waveform taking 8 frequency timer clocks to cycle through:\n      Channel2.resetTimer();\n      Channel2.frequencyTimer -= overflowAmount;\n\n      // Also increment our duty cycle\n      // What is duty? https://en.wikipedia.org/wiki/Duty_cycle\n      // Duty cycle for square wave: http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Square_Wave\n      Channel2.waveFormPositionOnDuty += 1;\n      if (Channel2.waveFormPositionOnDuty >= 8) {\n        Channel2.waveFormPositionOnDuty = 0;\n      }\n    }\n\n    // Get our ourput volume\n    let outputVolume: i32 = 0;\n\n    // Finally to set our output volume, the channel must be enabled,\n    // Our channel DAC must be enabled, and we must be in an active state\n    // Of our duty cycle\n    if(Channel2.isEnabled &&\n    isChannelDacEnabled(Channel2.channelNumber)) {\n      outputVolume = Channel2.volume;\n    } else {\n      // Return silence\n      // Since range from -15 - 15, or 0 to 30 for our unsigned\n      return 15;\n    }\n\n    // Get the current sampleValue\n    let sample: i32 = 1;\n    if (!isDutyCycleClockPositiveOrNegativeForWaveform(1, Channel2.waveFormPositionOnDuty)) {\n      sample = sample * -1;\n    }\n\n    sample = sample * outputVolume;\n\n    // Square Waves Can range from -15 - 15. Therefore simply add 15\n    sample = sample + 15;\n    return <i32>sample;\n  }\n\n  //http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Trigger_Event\n  static trigger(): void {\n    Channel2.isEnabled = true;\n    if(Channel2.lengthCounter === 0) {\n      Channel2.lengthCounter = 64;\n    }\n\n    // Reset our timer\n    // A square channel's frequency timer period is set to (2048-frequency)*4.\n    // Four duty cycles are available, each waveform taking 8 frequency timer clocks to cycle through:\n    Channel2.resetTimer();\n\n    Channel2.envelopeCounter = getChannelEnvelopePeriod(Channel2.channelNumber);\n\n    Channel2.volume = getChannelStartingVolume(Channel2.channelNumber);\n\n    // Finally if DAC is off, channel is still disabled\n    if(!isChannelDacEnabled(Channel2.channelNumber)) {\n      Channel2.isEnabled = false;\n    }\n  }\n\n  // Function to determine if the current channel would update when getting the sample\n  // This is used to accumulate samples\n  static willChannelUpdate(numberOfCycles: i32): boolean {\n\n    //Increment our cycle counter\n    Channel2.cycleCounter += numberOfCycles;\n\n    if (Channel2.frequencyTimer - Channel2.cycleCounter > 0 &&\n      isChannelDacEnabled(Channel2.channelNumber)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  static updateLength(): void {\n    if(Channel2.lengthCounter > 0 && isChannelLengthEnabled(Channel2.channelNumber)) {\n      Channel2.lengthCounter -= 1;\n    }\n\n    if(Channel2.lengthCounter === 0) {\n      Channel2.isEnabled = false;\n    }\n  }\n\n  static updateEnvelope(): void {\n\n    // Obscure behavior\n    // TODO: The volume envelope and sweep timers treat a period of 0 as 8.\n\n    Channel2.envelopeCounter -= 1;\n    if (Channel2.envelopeCounter <= 0) {\n      Channel2.envelopeCounter = getChannelEnvelopePeriod(Channel2.channelNumber);\n\n      // When the timer generates a clock and the envelope period is NOT zero, a new volume is calculated\n      // NOTE: There is some weiirrdd obscure behavior where zero can equal 8, so watch out for that\n      if(Channel2.envelopeCounter !== 0) {\n        if(getChannelEnvelopeAddMode(Channel2.channelNumber) && Channel2.volume < 15) {\n          Channel2.volume += 1;\n        } else if (!getChannelEnvelopeAddMode(Channel2.channelNumber) && Channel2.volume > 0) {\n          Channel2.volume -= 1;\n        }\n      }\n    }\n  }\n  // Done!\n}\n","// NOTE: Tons of Copy-pasta btween channels, because Classes cannot be instantiated yet in assemblyscript\n\n// Wave Channel\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Wave_Channel\n\nimport {\n  getChannelStartingVolume,\n  isChannelDacEnabled,\n  getRegister2OfChannel\n} from './registers';\nimport {\n  getChannelFrequency,\n  setChannelFrequency\n} from './frequency';\nimport {\n  isChannelLengthEnabled\n} from './length';\nimport {\n  getChannelEnvelopePeriod,\n  getChannelEnvelopeAddMode\n} from './envelope';\nimport {\n  isDutyCycleClockPositiveOrNegativeForWaveform\n} from './duty';\nimport {\n  Cpu\n} from '../cpu/cpu';\nimport {\n  eightBitLoadFromGBMemorySkipTraps,\n  eightBitStoreIntoGBMemorySkipTraps,\n  getSaveStateMemoryOffset,\n  loadBooleanDirectlyFromWasmMemory,\n  storeBooleanDirectlyToWasmMemory\n} from '../memory/index';\nimport {\n  checkBitOnByte,\n  hexLog\n} from '../helpers/index';\n\nexport class Channel3 {\n\n  // Cycle Counter for our sound accumulator\n  static cycleCounter: i32 = 0;\n\n  // Voluntary Wave channel with 32 4-bit programmable samples, played in sequence.\n  // NR30 -> Sound on/off (R/W)\n  static readonly memoryLocationNRx0: u16 = 0xFF1A;\n  // NR31 -> Sound length (R/W)\n  static readonly memoryLocationNRx1: u16 = 0xFF1B;\n  // NR32 -> Select ouput level (R/W)\n  static readonly memoryLocationNRx2: u16 = 0xFF1C;\n  // NR33 -> Frequency lower data (W)\n  static readonly memoryLocationNRx3: u16 = 0xFF1D;\n  // NR34 -> Frequency higher data (R/W)\n  static readonly memoryLocationNRx4: u16 = 0xFF1E;\n\n  // Our wave table location\n  static readonly memoryLocationWaveTable: u16 = 0xFF30;\n\n  // Channel Properties\n  static readonly channelNumber: i32 = 3;\n  static isEnabled: boolean = false;\n  static frequencyTimer: i32 = 0x00;\n  static lengthCounter: i32 = 0x00;\n  static waveTablePosition: u16 = 0x00;\n  static volumeCode: u8 = 0x00;\n  static volumeCodeChanged: boolean = false;\n\n  // Save States\n\n  static readonly saveStateSlot: u16 = 9;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x00, Channel3.saveStateSlot), Channel3.isEnabled);\n    store<i32>(getSaveStateMemoryOffset(0x01, Channel3.saveStateSlot), Channel3.frequencyTimer);\n    store<i32>(getSaveStateMemoryOffset(0x05, Channel3.saveStateSlot), Channel3.lengthCounter);\n    store<u16>(getSaveStateMemoryOffset(0x09, Channel3.saveStateSlot), Channel3.waveTablePosition);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    Channel3.isEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x00, Channel3.saveStateSlot));\n    Channel3.frequencyTimer = load<i32>(getSaveStateMemoryOffset(0x01, Channel3.saveStateSlot));\n    Channel3.lengthCounter = load<i32>(getSaveStateMemoryOffset(0x05, Channel3.saveStateSlot));\n    Channel3.waveTablePosition = load<u16>(getSaveStateMemoryOffset(0x09, Channel3.saveStateSlot));\n  }\n\n  static initialize(): void {\n    eightBitStoreIntoGBMemorySkipTraps(Channel3.memoryLocationNRx0, 0x7F);\n    eightBitStoreIntoGBMemorySkipTraps(Channel3.memoryLocationNRx1, 0xFF);\n    eightBitStoreIntoGBMemorySkipTraps(Channel3.memoryLocationNRx2, 0x9F);\n    eightBitStoreIntoGBMemorySkipTraps(Channel3.memoryLocationNRx3, 0x00);\n    eightBitStoreIntoGBMemorySkipTraps(Channel3.memoryLocationNRx4, 0xB8);\n\n    // The volume code changed\n    Channel3.volumeCodeChanged = true;\n  }\n\n  // Function to get a sample using the cycle counter on the channel\n  static getSampleFromCycleCounter(): i32 {\n    let accumulatedCycles: i32 = Channel3.cycleCounter;\n    Channel3.cycleCounter = 0;\n    return Channel3.getSample(accumulatedCycles);\n  }\n\n  // Function to reset our timer, useful for GBC double speed mode\n  static resetTimer(): void {\n    Channel3.frequencyTimer = (2048 - getChannelFrequency(Channel3.channelNumber)) * 2;\n\n    // TODO: Ensure this is correct for GBC Double Speed Mode\n    if (Cpu.GBCDoubleSpeed) {\n      Channel3.frequencyTimer = Channel3.frequencyTimer * 2;\n    }\n  }\n\n  static getSample(numberOfCycles: i32): i32 {\n\n    // Decrement our channel timer\n    Channel3.frequencyTimer -= numberOfCycles;\n    if(Channel3.frequencyTimer <= 0) {\n\n      // Get the amount that overflowed so we don't drop cycles\n      let overflowAmount: i32 = abs(Channel3.frequencyTimer);\n\n      // Reset our timer\n      // A wave channel's frequency timer period is set to (2048-frequency) * 2.\n      // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Wave_Channel\n      Channel3.resetTimer();\n      Channel3.frequencyTimer -= overflowAmount;\n\n\n      // Advance the wave table position, and loop back if needed\n      Channel3.waveTablePosition += 1;\n      if(Channel3.waveTablePosition >= 32) {\n        Channel3.waveTablePosition = 0;\n      }\n    }\n\n    // Get our ourput volume\n    let outputVolume: i16 = 0;\n    let volumeCode: u8 = Channel3.volumeCode;\n\n    // Finally to set our output volume, the channel must be enabled,\n    // Our channel DAC must be enabled, and we must be in an active state\n    // Of our duty cycle\n    if(Channel3.isEnabled &&\n    isChannelDacEnabled(Channel3.channelNumber)) {\n      // Get our volume code\n      if(Channel3.volumeCodeChanged) {\n        let volumeCode: u8 = eightBitLoadFromGBMemorySkipTraps(Channel3.memoryLocationNRx2);\n        volumeCode = (volumeCode >> 5);\n        volumeCode = (volumeCode & 0x0F);\n        Channel3.volumeCode = volumeCode;\n        Channel3.volumeCodeChanged = false;\n      }\n    } else {\n      // Return silence\n      // Since range from -15 - 15, or 0 to 30 for our unsigned\n      return 15;\n    }\n\n    // Get the current sample\n    let sample: i16 = 0;\n\n    // Will Find the position, and knock off any remainder\n    let positionIndexToAdd: u16 = Channel3.waveTablePosition / 2;\n    let memoryLocationWaveSample: u16 = Channel3.memoryLocationWaveTable + positionIndexToAdd;\n\n    sample = <i16>eightBitLoadFromGBMemorySkipTraps(memoryLocationWaveSample);\n\n    // Need to grab the top or lower half for the correct sample\n    if (Channel3.waveTablePosition % 2 === 0) {\n      // First sample\n      sample = (sample >> 4);\n      sample = (sample & 0x0F);\n    } else {\n      // Second Samples\n      sample = (sample & 0x0F);\n    }\n\n    // Shift our sample and set our volume depending on the volume code\n    // Since we can't multiply by float, simply divide by 4, 2, 1\n    // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Wave_Channel\n    switch(volumeCode) {\n      case 0:\n        sample = (sample >> 4);\n        break;\n      case 1:\n        // Dont Shift sample\n        outputVolume = 1;\n        break;\n      case 2:\n        sample = (sample >> 1)\n        outputVolume = 2;\n        break;\n      default:\n        sample = (sample >> 2)\n        outputVolume = 4;\n        break;\n    }\n\n    // Spply out output volume\n    if(outputVolume > 0) {\n      sample = sample / outputVolume;\n    } else {\n      sample = 0;\n    }\n\n    // Square Waves Can range from -15 - 15. Therefore simply add 15\n    sample = sample + 15;\n    return <i32>sample;\n  }\n\n  //http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Trigger_Event\n  static trigger(): void {\n    Channel3.isEnabled = true;\n    if(Channel3.lengthCounter === 0) {\n      Channel3.lengthCounter = 256;\n    }\n\n    // Reset our timer\n    // A wave channel's frequency timer period is set to (2048-frequency)*2.\n    Channel3.resetTimer();\n\n    // Reset our wave table position\n    Channel3.waveTablePosition = 0;\n\n    // Finally if DAC is off, channel is still disabled\n    if(!isChannelDacEnabled(Channel3.channelNumber)) {\n      Channel3.isEnabled = false;\n    }\n  }\n\n  // Function to determine if the current channel would update when getting the sample\n  // This is used to accumulate samples\n  static willChannelUpdate(numberOfCycles: i32): boolean {\n\n    //Increment our cycle counter\n    Channel3.cycleCounter += numberOfCycles;\n\n    if (Channel3.frequencyTimer - Channel3.cycleCounter > 0 &&\n      isChannelDacEnabled(Channel3.channelNumber) &&\n      !Channel3.volumeCodeChanged) {\n      return false;\n    }\n\n    return true;\n  }\n\n  static updateLength(): void {\n    if(Channel3.lengthCounter > 0 && isChannelLengthEnabled(Channel3.channelNumber)) {\n      Channel3.lengthCounter -= 1;\n    }\n\n    if(Channel3.lengthCounter === 0) {\n      Channel3.isEnabled = false;\n    }\n  }\n}\n","// NOTE: Tons of Copy-pasta btween channels, because Classes cannot be instantiated yet in assemblyscript\n\n// Noise Channel\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Noise_Channel\n\nimport {\n  getChannelStartingVolume,\n  isChannelDacEnabled,\n  getRegister2OfChannel\n} from './registers';\nimport {\n  getChannelFrequency,\n  setChannelFrequency\n} from './frequency';\nimport {\n  isChannelLengthEnabled\n} from './length';\nimport {\n  getChannelEnvelopePeriod,\n  getChannelEnvelopeAddMode\n} from './envelope';\nimport {\n  isDutyCycleClockPositiveOrNegativeForWaveform\n} from './duty';\nimport {\n  Cpu\n} from '../cpu/cpu';\nimport {\n  eightBitLoadFromGBMemorySkipTraps,\n  eightBitStoreIntoGBMemory,\n  eightBitStoreIntoGBMemorySkipTraps,\n  getSaveStateMemoryOffset,\n  loadBooleanDirectlyFromWasmMemory,\n  storeBooleanDirectlyToWasmMemory\n} from '../memory/index';\nimport {\n  checkBitOnByte,\n  hexLog\n} from '../helpers/index';\n\nexport class Channel4 {\n\n  // Cycle Counter for our sound accumulator\n  static cycleCounter: i32 = 0;\n\n  // Channel 4\n  // 'white noise' channel with volume envelope functions.\n  // NR41 -> Sound length (R/W)\n  static readonly memoryLocationNRx1: u16 = 0xFF20;\n  // NR42 -> Volume Envelope (R/W)\n  static readonly memoryLocationNRx2: u16 = 0xFF21;\n  // NR43 -> Polynomial Counter (R/W)\n  static readonly memoryLocationNRx3: u16 = 0xFF22;\n  // NR43 -> Counter/consecutive; initial (R/W)\n  static readonly memoryLocationNRx4: u16 = 0xFF23;\n\n  // Channel Properties\n  static readonly channelNumber: i32 = 4;\n  static isEnabled: boolean = false;\n  static frequencyTimer: i32 = 0x00;\n  static envelopeCounter: i32 = 0x00;\n  static lengthCounter: i32 = 0x00;\n  static volume: i32 = 0x00;\n\n  // Noise properties\n  // NOTE: Is only 15 bits\n  static linearFeedbackShiftRegister: u16 = 0x00;\n\n  // Save States\n\n  static readonly saveStateSlot: u16 = 10;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x00, Channel4.saveStateSlot), Channel4.isEnabled);\n    store<i32>(getSaveStateMemoryOffset(0x01, Channel4.saveStateSlot), Channel4.frequencyTimer);\n    store<i32>(getSaveStateMemoryOffset(0x05, Channel4.saveStateSlot), Channel4.envelopeCounter);\n    store<i32>(getSaveStateMemoryOffset(0x09, Channel4.saveStateSlot), Channel4.lengthCounter);\n    store<i32>(getSaveStateMemoryOffset(0x0E, Channel4.saveStateSlot), Channel4.volume);\n    store<u16>(getSaveStateMemoryOffset(0x13, Channel4.saveStateSlot), Channel4.linearFeedbackShiftRegister);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    Channel4.isEnabled = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x00, Channel4.saveStateSlot));\n    Channel4.frequencyTimer = load<i32>(getSaveStateMemoryOffset(0x01, Channel4.saveStateSlot));\n    Channel4.envelopeCounter = load<i32>(getSaveStateMemoryOffset(0x05, Channel4.saveStateSlot));\n    Channel4.lengthCounter = load<i32>(getSaveStateMemoryOffset(0x09, Channel4.saveStateSlot));\n    Channel4.volume = load<i32>(getSaveStateMemoryOffset(0x0E, Channel4.saveStateSlot));\n    Channel4.linearFeedbackShiftRegister = load<u16>(getSaveStateMemoryOffset(0x13, Channel4.saveStateSlot));\n  }\n\n  static initialize(): void {\n    eightBitStoreIntoGBMemorySkipTraps(Channel4.memoryLocationNRx1 - 1, 0xFF);\n    eightBitStoreIntoGBMemorySkipTraps(Channel4.memoryLocationNRx1, 0xFF);\n    eightBitStoreIntoGBMemorySkipTraps(Channel4.memoryLocationNRx2, 0x00);\n    eightBitStoreIntoGBMemorySkipTraps(Channel4.memoryLocationNRx3, 0x00);\n    eightBitStoreIntoGBMemorySkipTraps(Channel4.memoryLocationNRx4, 0xBF);\n  }\n\n  // Function to get a sample using the cycle counter on the channel\n  static getSampleFromCycleCounter(): i32 {\n    let accumulatedCycles: i32 = Channel4.cycleCounter;\n    Channel4.cycleCounter = 0;\n    return Channel4.getSample(accumulatedCycles);\n  }\n\n  static getSample(numberOfCycles: i32): i32 {\n\n    // Decrement our channel timer\n    Channel4.frequencyTimer -= numberOfCycles;\n\n    if(Channel4.frequencyTimer <= 0) {\n\n      // Get the amount that overflowed so we don't drop cycles\n      let overflowAmount: i32 = abs(Channel4.frequencyTimer);\n\n      // Reset our timer\n      Channel4.frequencyTimer = Channel4.getNoiseChannelFrequencyPeriod();\n      Channel4.frequencyTimer -= overflowAmount;\n\n      // Do some cool stuff with lfsr\n      // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Noise_Channel\n\n      // First XOR bit zero and one\n      let lfsrBitZero: u16 = (Channel4.linearFeedbackShiftRegister & 0x01);\n      let lfsrBitOne: u16 = (Channel4.linearFeedbackShiftRegister >> 1);\n      lfsrBitOne = (lfsrBitOne & 0x01);\n      let xorLfsrBitZeroOne = lfsrBitZero ^ lfsrBitOne;\n\n      // Shift all lsfr bits by one\n      Channel4.linearFeedbackShiftRegister = Channel4.linearFeedbackShiftRegister >> 1;\n\n      // Place the XOR result on bit 15\n      Channel4.linearFeedbackShiftRegister = Channel4.linearFeedbackShiftRegister | (xorLfsrBitZeroOne << 14);\n\n      // If the width mode is set, set xor on bit 6, and make lfsr 7 bit\n      if(Channel4.isNoiseChannelWidthModeSet()) {\n        // Make 7 bit, by knocking off lower bits. Want to keeps bits 8 - 16, and then or on 7\n        Channel4.linearFeedbackShiftRegister = Channel4.linearFeedbackShiftRegister & (~0x40);\n        Channel4.linearFeedbackShiftRegister = Channel4.linearFeedbackShiftRegister | (xorLfsrBitZeroOne << 6);\n      }\n    }\n\n    // Get our ourput volume, set to zero for silence\n    let outputVolume: i32 = 0;\n\n    // Finally to set our output volume, the channel must be enabled,\n    // Our channel DAC must be enabled, and we must be in an active state\n    // Of our duty cycle\n    if(Channel4.isEnabled &&\n    isChannelDacEnabled(Channel4.channelNumber)) {\n      outputVolume = Channel4.volume;\n    } else {\n      // Return silence\n      // Since range from -15 - 15, or 0 to 30 for our unsigned\n      return 15;\n    }\n\n    // Declare our sample\n    let sample: i32 = 0;\n\n    // Wave form output is bit zero of lfsr, INVERTED\n    if (!checkBitOnByte(0, <u8>Channel4.linearFeedbackShiftRegister)) {\n      sample = 1;\n    } else {\n      sample = -1;\n    }\n\n    sample = sample * outputVolume;\n\n    // Noise Can range from -15 - 15. Therefore simply add 15\n    sample = sample + 15;\n    return <i32>sample;\n  }\n\n  //http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Trigger_Event\n  static trigger(): void {\n    Channel4.isEnabled = true;\n    if(Channel4.lengthCounter === 0) {\n      Channel4.lengthCounter = 64;\n    }\n\n    // Reset our timers\n    Channel4.frequencyTimer = Channel4.getNoiseChannelFrequencyPeriod();\n\n    Channel4.envelopeCounter = getChannelEnvelopePeriod(Channel4.channelNumber);\n\n    Channel4.volume = getChannelStartingVolume(Channel4.channelNumber);\n\n    // Noise channel's LFSR bits are all set to 1.\n    Channel4.linearFeedbackShiftRegister = 0x7FFF;\n\n    // Finally if DAC is off, channel is still disabled\n    if(!isChannelDacEnabled(Channel4.channelNumber)) {\n      Channel4.isEnabled = false;\n    }\n  }\n\n  // Function to determine if the current channel would update when getting the sample\n  // This is used to accumulate samples\n  static willChannelUpdate(numberOfCycles: i32): boolean {\n\n    //Increment our cycle counter\n    Channel4.cycleCounter += numberOfCycles;\n\n    if (Channel4.frequencyTimer - Channel4.cycleCounter > 0 &&\n      isChannelDacEnabled(Channel4.channelNumber)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  static getNoiseChannelFrequencyPeriod(): u16 {\n    // Get our divisor from the divisor code\n    let divisor: u16 = Channel4.getNoiseChannelDivisorFromDivisorCode();\n    let clockShift: u8 = Channel4.getNoiseChannelClockShift();\n    let response: u16 = (divisor << clockShift);\n    if (Cpu.GBCDoubleSpeed) {\n      response = response * 2;\n    }\n    return response;\n  }\n\n  static getNoiseChannelClockShift(): u8 {\n    let registerNRx3: u8 = eightBitLoadFromGBMemorySkipTraps(Channel4.memoryLocationNRx3);\n    // It is within the top 4 bits\n    let clockShift = (registerNRx3 >> 4);\n    return clockShift;\n  }\n\n  static isNoiseChannelWidthModeSet(): boolean {\n    let registerNRx3: u8 = eightBitLoadFromGBMemorySkipTraps(Channel4.memoryLocationNRx3);\n    return checkBitOnByte(3, registerNRx3);\n  }\n\n  static getNoiseChannelDivisorFromDivisorCode(): u8 {\n    // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Noise_Channel\n    // Get our divisor code\n    let registerNRx3: u8 = eightBitLoadFromGBMemorySkipTraps(Channel4.memoryLocationNRx3);\n    // Get the bottom 3 bits\n    let divisorCode: u8 = registerNRx3 & 0x07;\n    let divisor: u8 = 0;\n    if(divisorCode === 0) {\n      divisor = 8;\n    } else if (divisorCode === 1) {\n      divisor = 16;\n    } else if (divisorCode === 2) {\n      divisor = 32;\n    } else if (divisorCode === 3) {\n      divisor = 48;\n    } else if (divisorCode === 4) {\n      divisor = 64;\n    } else if (divisorCode === 5) {\n      divisor = 80;\n    } else if (divisorCode === 6) {\n      divisor = 96;\n    } else if (divisorCode === 7) {\n      divisor = 112;\n    }\n    return divisor;\n  }\n\n  static updateLength(): void {\n    if(Channel4.lengthCounter > 0 && isChannelLengthEnabled(Channel4.channelNumber)) {\n      Channel4.lengthCounter -= 1;\n    }\n\n    if(Channel4.lengthCounter === 0) {\n      Channel4.isEnabled = false;\n    }\n  }\n\n  static updateEnvelope(): void {\n\n    // Obscure behavior\n    // TODO: The volume envelope and sweep timers treat a period of 0 as 8.\n\n    Channel4.envelopeCounter -= 1;\n    if (Channel4.envelopeCounter <= 0) {\n      Channel4.envelopeCounter = getChannelEnvelopePeriod(Channel4.channelNumber);\n\n      // When the timer generates a clock and the envelope period is NOT zero, a new volume is calculated\n      // NOTE: There is some weiirrdd obscure behavior where zero can equal 8, so watch out for that\n      if(Channel4.envelopeCounter !== 0) {\n        if(getChannelEnvelopeAddMode(Channel4.channelNumber) && Channel4.volume < 15) {\n          Channel4.volume += 1;\n        } else if (!getChannelEnvelopeAddMode(Channel4.channelNumber) && Channel4.volume > 0) {\n          Channel4.volume -= 1;\n        }\n      }\n    }\n  }\n  // Done!\n}\n","export class Config {\n\n  // Batch Processing\n  static audioBatchProcessing: boolean = false;\n  static graphicsBatchProcessing: boolean = false;\n  static timersBatchProcessing: boolean = false;\n\n  // Scanline Rendering\n  static graphicsDisableScanlineRendering: boolean = false;\n\n  // Acumulate Sound Samples\n  static audioAccumulateSamples: boolean = false;\n}\n\nexport function config(audioBatchProcessing: i32 = 0,\n  graphicsBatchProcessing: i32 = 0,\n  timersBatchProcessing: i32 = 0,\n  graphicsDisableScanlineRendering: i32 = 0,\n  audioAccumulateSamples: i32 = 0): void {\n  if(audioBatchProcessing > 0) {\n    Config.audioBatchProcessing = true;\n  }\n  if(graphicsBatchProcessing > 0) {\n    Config.graphicsBatchProcessing = true;\n  }\n  if(timersBatchProcessing > 0) {\n    Config.timersBatchProcessing = true;\n  }\n  if(graphicsDisableScanlineRendering > 0) {\n    Config.graphicsDisableScanlineRendering = true\n  }\n  if(audioAccumulateSamples > 0) {\n    Config.audioAccumulateSamples = true;\n  }\n}\n","// Imports\nimport {\n  Cpu\n} from './index';\nimport {\n  handleCbOpcode\n} from './cbOpcodes';\nimport {\n  setZeroFlag,\n  getZeroFlag,\n  setSubtractFlag,\n  getSubtractFlag,\n  setHalfCarryFlag,\n  getHalfCarryFlag,\n  setCarryFlag,\n  getCarryFlag,\n  checkAndSetEightBitCarryFlag,\n  checkAndSetEightBitHalfCarryFlag,\n  checkAndSetSixteenBitFlagsAddOverflow\n} from './flags'\nimport {\n  addARegister,\n  addAThroughCarryRegister,\n  subARegister,\n  subAThroughCarryRegister,\n  andARegister,\n  xorARegister,\n  orARegister,\n  cpARegister,\n  relativeJump\n} from './instructions';\nimport {\n  Config\n} from '../config'\nimport {\n  log,\n  hexLog,\n  performanceTimestamp,\n  rotateByteLeft,\n  rotateByteLeftThroughCarry,\n  rotateByteRight,\n  rotateByteRightThroughCarry,\n  concatenateBytes,\n  splitHighByte,\n  splitLowByte,\n  checkBitOnByte,\n  resetBitOnByte,\n  setBitOnByte\n} from '../helpers/index';\nimport {\n  Memory,\n  eightBitStoreIntoGBMemory,\n  sixteenBitStoreIntoGBMemory,\n  eightBitLoadFromGBMemory,\n  sixteenBitLoadFromGBMemory\n} from '../memory/index';\nimport {\n  Timers,\n  batchProcessTimers,\n  updateTimers\n} from '../timers/index';\nimport {\n  setInterrupts,\n  checkInterrupts,\n  areInterruptsEnabled,\n  areInterruptsPending\n} from '../interrupts/index';\nimport {\n  Graphics,\n  updateGraphics,\n  batchProcessGraphics\n} from '../graphics/index';\nimport {\n  Sound,\n  updateSound\n} from '../sound/index';\n\n// Public funciton to run opcodes until an event occurs.\n// Return values:\n// -1 = error\n// 1 = render a frame\n// 2 = replace boot rom\nexport function update(): i32 {\n\n  // Get our config settings\n  let audioBatchProcessing: boolean = Config.audioBatchProcessing;\n  let graphicsBatchProcessing: boolean = Config.graphicsBatchProcessing;\n  let timersBatchProcessing: boolean = Config.timersBatchProcessing;\n\n\n  let error: boolean = false;\n  let numberOfCycles: i32 = -1;\n\n  while(!error &&\n    Cpu.currentCycles < Cpu.MAX_CYCLES_PER_FRAME()) {\n    numberOfCycles = emulationStep(audioBatchProcessing, graphicsBatchProcessing, timersBatchProcessing);\n    if (numberOfCycles >= 0) {\n      Cpu.currentCycles += numberOfCycles;\n\n      if(audioBatchProcessing) {\n        Sound.currentCycles += numberOfCycles;\n      }\n\n      if (graphicsBatchProcessing) {\n        // Need to do this, since a lot of things depend on the scanline\n        // Batch processing will simply return if the number of cycles is too low\n        Graphics.currentCycles += numberOfCycles;\n        batchProcessGraphics();\n      }\n\n      if (timersBatchProcessing) {\n        // Batch processing will simply return if the number of cycles is too low\n        Timers.currentCycles += numberOfCycles;\n        batchProcessTimers();\n      }\n    } else {\n      error = true;\n    }\n  }\n\n  // Find our exit reason\n  if (Cpu.currentCycles >= Cpu.MAX_CYCLES_PER_FRAME()) {\n    // Render a frame\n\n    // Reset our currentCycles\n    Cpu.currentCycles -= Cpu.MAX_CYCLES_PER_FRAME()\n\n    return 1;\n  }\n  // TODO: Boot ROM handling\n\n  // There was an error, return -1, and push the program counter back to grab the error opcode\n  Cpu.programCounter -= 1;\n  return -1;\n}\n\n// Function to execute an opcode, and update other gameboy hardware.\n// http://www.codeslinger.co.uk/pages/projects/gameboy/beginning.html\nexport function emulationStep(audioBatchProcessing: boolean = false,\n  graphicsBatchProcessing: boolean = false,\n  timersBatchProcessing: boolean = false): i32 {\n  // Get the opcode, and additional bytes to be handled\n  // Number of cycles defaults to 4, because while we're halted, we run 4 cycles (according to matt :))\n  let numberOfCycles: i32 = 4;\n  let opcode: u8 = 0;\n\n  // Cpu Halting best explained: https://www.reddit.com/r/EmuDev/comments/5ie3k7/infinite_loop_trying_to_pass_blarggs_interrupt/db7xnbe/\n  if(!Cpu.isHalted && !Cpu.isStopped) {\n    opcode = eightBitLoadFromGBMemory(Cpu.programCounter);\n    let dataByteOne: u8 = eightBitLoadFromGBMemory(Cpu.programCounter + 1);\n    let dataByteTwo: u8 = eightBitLoadFromGBMemory(Cpu.programCounter + 2);\n    numberOfCycles = executeOpcode(opcode, dataByteOne, dataByteTwo);\n  } else {\n    // if we were halted, and interrupts were disabled but interrupts are pending, stop waiting\n    if(Cpu.isHalted && !areInterruptsEnabled() && areInterruptsPending()) {\n      Cpu.isHalted = false;\n      Cpu.isStopped = false;\n\n      // Need to run the next opcode twice, it's a bug menitoned in\n      // The reddit comment mentioned above\n\n      // CTRL+F \"low-power\" on gameboy cpu manual\n      // http://marc.rawer.de/Gameboy/Docs/GBCPUman.pdf\n      // E.g\n      // 0x76 - halt\n      // FA 34 12 - ld a,(1234)\n      // Becomes\n      // FA FA 34 ld a,(34FA)\n      // 12 ld (de),a\n      opcode = eightBitLoadFromGBMemory(Cpu.programCounter);\n      let dataByteOne: u8 = eightBitLoadFromGBMemory(Cpu.programCounter);\n      let dataByteTwo: u8 = eightBitLoadFromGBMemory(Cpu.programCounter + 1);\n      numberOfCycles = executeOpcode(opcode, dataByteOne, dataByteTwo);\n      Cpu.programCounter -= 1;\n    }\n  }\n\n  // blarggFixes, don't allow register F to have the bottom nibble\n  Cpu.registerF = Cpu.registerF & 0xF0;\n\n  // Check if there was an error decoding the opcode\n  if(numberOfCycles <= 0) {\n    return numberOfCycles;\n  }\n\n  // Check if we did a DMA TRansfer, if we did add the cycles\n  if (Memory.DMACycles > 0) {\n    numberOfCycles += Memory.DMACycles;\n    Memory.DMACycles = 0;\n  }\n\n  // Interrupt Handling requires 20 cycles\n  // https://github.com/Gekkio/mooneye-gb/blob/master/docs/accuracy.markdown#what-is-the-exact-timing-of-cpu-servicing-an-interrupt\n  numberOfCycles += checkInterrupts();\n\n  if(!Cpu.isStopped) {\n    if(!graphicsBatchProcessing) {\n      updateGraphics(numberOfCycles);\n    }\n\n    if(!audioBatchProcessing) {\n      updateSound(numberOfCycles);\n    }\n  }\n\n  // Check other Gameboy components\n  if (!timersBatchProcessing) {\n    updateTimers(numberOfCycles);\n  }\n\n  return numberOfCycles;\n}\n\n// Take in any opcode, and decode it, and return the number of cycles\n// Program counter can be gotten from getProgramCounter();\n// Setting return value to i32 instead of u16, as we want to return a negative number on error\n// https://rednex.github.io/rgbds/gbz80.7.html\n// http://pastraiser.com/cpu/gameboy/gameboyopcodes.html\nfunction executeOpcode(opcode: u8, dataByteOne: u8, dataByteTwo: u8): i32 {\n\n  // Initialize our number of cycles\n  // Return -1 if no opcode was found, representing an error\n  let numberOfCycles: i32 = -1;\n\n  // Always implement the program counter by one\n  // Any other value can just subtract or add however much offset before reaching this line\n  Cpu.programCounter += 1;\n\n  // Get our concatenated databyte one and dataByteTwo\n  // Find and replace with : concatenatedDataByte\n  let concatenatedDataByte: u16 = concatenateBytes(dataByteTwo, dataByteOne);\n\n  // Split our opcode into a high nibble to speed up performance\n  // Running 255 if statements is slow, even in wasm haha!\n  let opcodeHighNibble = (opcode & 0xF0);\n  opcodeHighNibble = opcodeHighNibble >> 4;\n\n  // NOTE: @binji rule of thumb: it takes 4 cpu cycles to read one byte\n  // Therefore isntructions that use more than just the opcode (databyte one and two) will take at least\n  // 8 cyckles to use databyteOne, and two cycles to use the concatented\n\n  // Not using a switch statement to avoid cannot redeclare this variable errors\n  // And it would be a ton of work :p\n\n  switch(opcodeHighNibble) {\n    case 0x00:\n      return handleOpcode0x(opcode, dataByteOne, dataByteTwo, concatenatedDataByte);\n    case 0x01:\n      return handleOpcode1x(opcode, dataByteOne, dataByteTwo, concatenatedDataByte);\n    case 0x02:\n      return handleOpcode2x(opcode, dataByteOne, dataByteTwo, concatenatedDataByte);\n    case 0x03:\n      return handleOpcode3x(opcode, dataByteOne, dataByteTwo, concatenatedDataByte);\n    case 0x04:\n      return handleOpcode4x(opcode, dataByteOne, dataByteTwo, concatenatedDataByte);\n    case 0x05:\n      return handleOpcode5x(opcode, dataByteOne, dataByteTwo, concatenatedDataByte);\n    case 0x06:\n      return handleOpcode6x(opcode, dataByteOne, dataByteTwo, concatenatedDataByte);\n    case 0x07:\n      return handleOpcode7x(opcode, dataByteOne, dataByteTwo, concatenatedDataByte);\n    case 0x08:\n      return handleOpcode8x(opcode, dataByteOne, dataByteTwo, concatenatedDataByte);\n    case 0x09:\n      return handleOpcode9x(opcode, dataByteOne, dataByteTwo, concatenatedDataByte);\n    case 0x0A:\n      return handleOpcodeAx(opcode, dataByteOne, dataByteTwo, concatenatedDataByte);\n    case 0x0B:\n      return handleOpcodeBx(opcode, dataByteOne, dataByteTwo, concatenatedDataByte);\n    case 0x0C:\n      return handleOpcodeCx(opcode, dataByteOne, dataByteTwo, concatenatedDataByte);\n    case 0x0D:\n      return handleOpcodeDx(opcode, dataByteOne, dataByteTwo, concatenatedDataByte);\n    case 0x0E:\n      return handleOpcodeEx(opcode, dataByteOne, dataByteTwo, concatenatedDataByte);\n    default:\n      return handleOpcodeFx(opcode, dataByteOne, dataByteTwo, concatenatedDataByte);\n  }\n}\n\nfunction handleOpcode0x(opcode: u8, dataByteOne: u8, dataByteTwo: u8, concatenatedDataByte: u16): i8 {\n  switch(opcode) {\n    case 0x00:\n      // NOP\n      // 1  4\n      // No Operation\n      return 4;\n    case 0x01:\n      // LD BC,d16\n      // 3  12\n\n      Cpu.registerB = splitHighByte(concatenatedDataByte);\n      Cpu.registerC = splitLowByte(concatenatedDataByte);\n      Cpu.programCounter += 2;\n      return 12;\n    case 0x02:\n      // LD (BC),A\n      // 1  8\n      // () means load into address pointed by BC\n      let registerBC2: u16 = concatenateBytes(Cpu.registerB, Cpu.registerC)\n      eightBitStoreIntoGBMemory(registerBC2, Cpu.registerA);\n      return 8;\n    case 0x03:\n      // INC BC\n      // 1  8\n      let registerBC3: u16 = concatenateBytes(Cpu.registerB, Cpu.registerC);\n      registerBC3++;\n      Cpu.registerB = splitHighByte((<u16>registerBC3));\n      Cpu.registerC = splitLowByte((<u16>registerBC3));\n      return 8;\n    case 0x04:\n      // INC B\n      // 1  4\n      // Z 0 H -\n      checkAndSetEightBitHalfCarryFlag(Cpu.registerB, 1);\n      Cpu.registerB += 1;\n      if (Cpu.registerB === 0) {\n        setZeroFlag(1);\n      } else {\n        setZeroFlag(0);\n      }\n      setSubtractFlag(0);\n      return 4;\n    case 0x05:\n      // DEC B\n      // 1  4\n      // Z 1 H -\n      checkAndSetEightBitHalfCarryFlag(Cpu.registerB, -1);\n      Cpu.registerB -= 1;\n      if (Cpu.registerB === 0) {\n        setZeroFlag(1);\n      } else {\n        setZeroFlag(0);\n      }\n      setSubtractFlag(1);\n      return 4;\n    case 0x06:\n      // LD B,d8\n      // 2  8\n      Cpu.registerB = dataByteOne;\n      Cpu.programCounter += 1;\n      return 8;\n    case 0x07:\n      // RLCA\n      // 1  4\n      // 0 0 0 C\n      // Check for the carry\n      if((Cpu.registerA & 0x80) === 0x80) {\n        setCarryFlag(1);\n      } else {\n        setCarryFlag(0);\n      }\n      Cpu.registerA = rotateByteLeft(Cpu.registerA);\n      // Set all other flags to zero\n      setZeroFlag(0);\n      setSubtractFlag(0);\n      setHalfCarryFlag(0);\n      return 4;\n    case 0x08:\n      // LD (a16),SP\n      // 3  20\n      // Load the stack pointer into the 16 bit address represented by the two data bytes\n      sixteenBitStoreIntoGBMemory(concatenatedDataByte, Cpu.stackPointer);\n      Cpu.programCounter += 2;\n      return 20;\n    case 0x09:\n      // ADD HL,BC\n      // 1 8\n      // - 0 H C\n      let registerHL: u16 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n      let registerBC9: u16 = concatenateBytes(Cpu.registerB, Cpu.registerC);\n      checkAndSetSixteenBitFlagsAddOverflow(<u16>registerHL, <u16>registerBC9, false);\n      let result: u16 = <u16>(registerHL + registerBC9);\n      Cpu.registerH = splitHighByte(<u16>result);\n      Cpu.registerL = splitLowByte(<u16>result);\n      setSubtractFlag(0);\n      return 8;\n    case 0x0A:\n      // LD A,(BC)\n      // 1 8\n      let registerBCA: u16 = concatenateBytes(Cpu.registerB, Cpu.registerC)\n      Cpu.registerA = eightBitLoadFromGBMemory(registerBCA);\n      return 8;\n    case 0x0B:\n      // DEC BC\n      // 1  8\n      let registerBCB: u16 = concatenateBytes(Cpu.registerB, Cpu.registerC);\n      registerBCB -= 1;\n      Cpu.registerB = splitHighByte(registerBCB);\n      Cpu.registerC = splitLowByte(registerBCB);\n      return 8;\n    case 0x0C:\n      // INC C\n      // 1  4\n      // Z 0 H -\n      checkAndSetEightBitHalfCarryFlag(Cpu.registerC, 1);\n      Cpu.registerC += 1;\n      if (Cpu.registerC === 0) {\n        setZeroFlag(1);\n      } else {\n        setZeroFlag(0);\n      }\n      setSubtractFlag(0);\n      return 4;\n    case 0x0D:\n      // DEC C\n      // 1  4\n      // Z 1 H -\n      checkAndSetEightBitHalfCarryFlag(Cpu.registerC, -1);\n      Cpu.registerC -= 1;\n      if (Cpu.registerC === 0) {\n        setZeroFlag(1);\n      } else {\n        setZeroFlag(0);\n      }\n      setSubtractFlag(1);\n      return 4;\n    case 0x0E:\n      // LD C,d8\n      // 2 8\n      Cpu.registerC = dataByteOne;\n      Cpu.programCounter += 1;\n      return 8;\n    case 0x0F:\n      // RRCA\n      // 1 4\n      // 0 0 0 C\n      // Check for the last bit, to see if it will be carried\n      if ((Cpu.registerA & 0x01) > 0) {\n        setCarryFlag(1);\n      } else {\n        setCarryFlag(0);\n      }\n      Cpu.registerA = rotateByteRight(Cpu.registerA);\n      // Set all other flags to zero\n      setZeroFlag(0);\n      setSubtractFlag(0);\n      setHalfCarryFlag(0);\n      return 4;\n  }\n  return -1;\n}\n\nfunction handleOpcode1x(opcode: u8, dataByteOne: u8, dataByteTwo: u8, concatenatedDataByte: u16): i8 {\n\n  switch (opcode) {\n    case 0x10:\n\n      // STOP 0\n      // 2 4\n      // Enter CPU very low power mode. Also used to switch between double and normal speed CPU modes in GBC.\n      // Meaning Don't Decode anymore opcodes , or updated the LCD until joypad interrupt (or when button is pressed if I am wrong)\n      // See HALT\n\n      // If we are in gameboy color mode, set the new speed\n      if (Cpu.GBCEnabled) {\n\n        let speedSwitch: u8 = eightBitLoadFromGBMemory(Cpu.memoryLocationSpeedSwitch);\n        if(checkBitOnByte(0, speedSwitch)) {\n\n          // Reset the prepare bit\n          speedSwitch = resetBitOnByte(0, speedSwitch);\n\n          // Switch to the new mode, and set the speed switch to the OTHER speed, to represent our new speed\n          if (!checkBitOnByte(7, speedSwitch)) {\n            Cpu.GBCDoubleSpeed = true;\n            speedSwitch = setBitOnByte(7, speedSwitch);\n          } else {\n            Cpu.GBCDoubleSpeed = false;\n            speedSwitch = resetBitOnByte(7, speedSwitch);\n          }\n\n          // Store the final speed switch\n          eightBitStoreIntoGBMemory(Cpu.memoryLocationSpeedSwitch, speedSwitch);\n\n          // Cycle accurate gameboy docs says this takes 76 clocks\n          return 76;\n        }\n      }\n\n      // TODO: This breaks Blarggs CPU tests, find out what should end a STOP\n      //Cpu.isStopped = true;\n      Cpu.programCounter += 1;\n      return 4;\n    case 0x11:\n      // LD DE,d16\n      // 3  12\n      Cpu.registerD = splitHighByte(concatenatedDataByte);\n      Cpu.registerE = splitLowByte(concatenatedDataByte);\n      Cpu.programCounter += 2;\n      return 12;\n    case 0x12:\n      // LD (DE),A\n      // 1 8\n      let registerDE2: u16 = concatenateBytes(Cpu.registerD, Cpu.registerE);\n      eightBitStoreIntoGBMemory(registerDE2, Cpu.registerA);\n      return 8;\n    case 0x13:\n      // INC DE\n      // 1 8\n      let registerDE3 = concatenateBytes(Cpu.registerD, Cpu.registerE);\n      registerDE3 += 1;\n      Cpu.registerD = splitHighByte(registerDE3);\n      Cpu.registerE = splitLowByte(registerDE3);\n      return 8;\n    case 0x14:\n      // INC D\n      // 1  4\n      // Z 0 H -\n      checkAndSetEightBitHalfCarryFlag(Cpu.registerD, 1);\n      Cpu.registerD += 1;\n      if (Cpu.registerD === 0) {\n        setZeroFlag(1);\n      } else {\n        setZeroFlag(0);\n      }\n      setSubtractFlag(0);\n      return 4;\n    case 0x15:\n      // DEC D\n      // 1  4\n      // Z 1 H -\n      checkAndSetEightBitHalfCarryFlag(Cpu.registerD, -1);\n      Cpu.registerD -= 1;\n      if (Cpu.registerD === 0) {\n        setZeroFlag(1);\n      } else {\n        setZeroFlag(0);\n      }\n      setSubtractFlag(1);\n      return 4;\n    case 0x16:\n      // LD D,d8\n      // 2 8\n      Cpu.registerD = dataByteOne;\n      Cpu.programCounter += 1;\n      return 8;\n    case 0x17:\n      // RLA\n      // 1 4\n      // 0 0 0 C\n      // Check for the carry\n      // setting has first bit since we need to use carry\n      let hasHighbit = false;\n      if((Cpu.registerA & 0x80) === 0x80) {\n        hasHighbit = true;\n      }\n      Cpu.registerA = rotateByteLeftThroughCarry(Cpu.registerA);\n      // OR the carry flag to the end\n      if(hasHighbit) {\n        setCarryFlag(1);\n      } else {\n        setCarryFlag(0);\n      }\n      // Set all other flags to zero\n      setZeroFlag(0);\n      setSubtractFlag(0);\n      setHalfCarryFlag(0);\n      return 4;\n    case 0x18:\n      // JR r8\n      // 2  12\n      // NOTE: Discoved dataByte is signed\n      // However the relative Jump Function handles this\n\n      relativeJump(dataByteOne);\n      return 12;\n      // Relative Jump Function Handles program counter\n    case 0x19:\n      // ADD HL,DE\n      // 1  8\n      // - 0 H C\n      let registerHL: u16 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n      let registerDE9: u16 = concatenateBytes(Cpu.registerD, Cpu.registerE);\n      checkAndSetSixteenBitFlagsAddOverflow(<u16>registerHL, <u16>registerDE9, false);\n      let result: u16 = <u16>(registerHL + registerDE9);\n      Cpu.registerH = splitHighByte(<u16>result);\n      Cpu.registerL = splitLowByte(<u16>result);\n      setSubtractFlag(0);\n      return 8;\n    case 0x1A:\n      // LD A,(DE)\n      // 1 8\n      let registerDEA: u16 = concatenateBytes(Cpu.registerD, Cpu.registerE);\n      Cpu.registerA = eightBitLoadFromGBMemory(registerDEA);\n      return 8;\n    case 0x1B:\n      // DEC DE\n      // 1 8\n      let registerDEB: u16 = concatenateBytes(Cpu.registerD, Cpu.registerE);\n      registerDEB -= 1;\n      Cpu.registerD = splitHighByte(registerDEB);\n      Cpu.registerE = splitLowByte(registerDEB);\n      return 8;\n    case 0x1C:\n      // INC E\n      // 1  4\n      // Z 0 H -\n      checkAndSetEightBitHalfCarryFlag(Cpu.registerE, 1);\n      Cpu.registerE += 1;\n      if (Cpu.registerE === 0) {\n        setZeroFlag(1);\n      } else {\n        setZeroFlag(0);\n      }\n      setSubtractFlag(0);\n      return 4;\n    case 0x1D:\n      // DEC E\n      // 1  4\n      // Z 1 H -\n      checkAndSetEightBitHalfCarryFlag(Cpu.registerE, -1);\n      Cpu.registerE -= 1;\n      if (Cpu.registerE === 0) {\n        setZeroFlag(1);\n      } else {\n        setZeroFlag(0);\n      }\n      setSubtractFlag(1);\n      return 4;\n    case 0x1E:\n      // LD E,d8\n      // 2 8\n      Cpu.registerE = dataByteOne;\n      Cpu.programCounter += 1;\n      return 8;\n    case 0x1F:\n      // RRA\n      // 1 4\n      // 0 0 0 C\n      // Check for the carry\n      // setting has low bit since we need to use carry\n      let hasLowBit = false;\n      if((Cpu.registerA & 0x01) === 0x01) {\n        hasLowBit = true;\n      }\n      Cpu.registerA = rotateByteRightThroughCarry(Cpu.registerA);\n\n      if(hasLowBit) {\n        setCarryFlag(1);\n      } else {\n        setCarryFlag(0);\n      }\n      // Set all other flags to zero\n      setZeroFlag(0);\n      setSubtractFlag(0);\n      setHalfCarryFlag(0);\n      return 4;\n  }\n\n  return -1;\n}\n\nfunction handleOpcode2x(opcode: u8, dataByteOne: u8, dataByteTwo: u8, concatenatedDataByte: u16): i8 {\n\n  switch(opcode) {\n    case 0x20:\n\n      // JR NZ,r8\n      // 2  12/8\n      // NOTE: NZ stands for not [flag], so in this case, not zero flag\n      // Also, / means, if condition. so if met, 12 cycles, otherwise 8 cycles\n      if (getZeroFlag() === 0) {\n        relativeJump(dataByteOne);\n        return 12;\n        // Relative Jump Funciton handles program counter\n      } else {\n        Cpu.programCounter += 1;\n        return 8;\n      }\n    case 0x21:\n\n      // LD HL,d16\n      // 3  12\n      let sixteenBitDataByte = concatenatedDataByte;\n      Cpu.registerH = splitHighByte(sixteenBitDataByte);\n      Cpu.registerL = splitLowByte(sixteenBitDataByte);\n      Cpu.programCounter += 2;\n      return 12;\n    case 0x22:\n\n      // LD (HL+),A\n      // 1 8\n      let registerHL2: u16 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n      eightBitStoreIntoGBMemory(registerHL2, Cpu.registerA);\n      registerHL2 += 1;\n      Cpu.registerH = splitHighByte(registerHL2);\n      Cpu.registerL = splitLowByte(registerHL2);\n      return 8;\n    case 0x23:\n\n      // INC HL\n      // 1  8\n      let registerHL3 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n      registerHL3 += 1;\n      Cpu.registerH = splitHighByte(registerHL3);\n      Cpu.registerL = splitLowByte(registerHL3);\n      return 8;\n    case 0x24:\n\n      // INC H\n      // 1  4\n      // Z 0 H -\n      checkAndSetEightBitHalfCarryFlag(Cpu.registerH, 1);\n      Cpu.registerH += 1;\n      if (Cpu.registerH === 0) {\n        setZeroFlag(1);\n      } else {\n        setZeroFlag(0);\n      }\n      setSubtractFlag(0);\n      return 4;\n    case 0x25:\n\n      // DEC H\n      // 1  4\n      // Z 1 H -\n      checkAndSetEightBitHalfCarryFlag(Cpu.registerH, -1);\n      Cpu.registerH -= 1;\n      if (Cpu.registerH === 0) {\n        setZeroFlag(1);\n      } else {\n        setZeroFlag(0);\n      }\n      setSubtractFlag(1);\n      return 4;\n    case 0x26:\n\n      // LD H,d8\n      // 2 8\n      Cpu.registerH = dataByteOne;\n      Cpu.programCounter += 1;\n      return 8;\n    case 0x27:\n\n      // DAA\n      // 1 4\n      // Z - 0 C\n      let adjustedRegister: u8 = 0;\n      let adjustment: u8 = 0;\n\n      if(getHalfCarryFlag() > 0) {\n        adjustment = adjustment | 0x06;\n      }\n      if(getCarryFlag() > 0) {\n        adjustment = adjustment | 0x60;\n      }\n\n      if(getSubtractFlag() > 0) {\n        adjustedRegister = Cpu.registerA - <u8>adjustment;\n      } else {\n        if ((Cpu.registerA & 0x0F) > 0x09) {\n          adjustment = adjustment | 0x06;\n        }\n        if(Cpu.registerA > 0x99) {\n          adjustment = adjustment | 0x60;\n        }\n        adjustedRegister = Cpu.registerA + <u8>adjustment;\n      }\n\n      // Now set our flags to the correct values\n      if(adjustedRegister === 0) {\n        setZeroFlag(1);\n      } else {\n        setZeroFlag(0);\n      }\n      if((adjustment & 0x60) !== 0) {\n        setCarryFlag(1);\n      } else {\n        setCarryFlag(0);\n      }\n      setHalfCarryFlag(0);\n\n      Cpu.registerA = <u8>adjustedRegister;\n      return 4;\n    case 0x28:\n\n      // JR Z,r8\n      // 2  12/8\n      if(getZeroFlag() > 0) {\n        relativeJump(dataByteOne);\n        return 12;\n        // Relative Jump funciton handles pogram counter\n      } else {\n        Cpu.programCounter += 1;\n        return 8;\n      }\n    case 0x29:\n\n      // ADD HL,HL\n      // 1  8\n      // - 0 H C\n      let registerHL9: u16 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n      checkAndSetSixteenBitFlagsAddOverflow(registerHL9, registerHL9, false);\n      registerHL9 = registerHL9 * 2;\n      Cpu.registerH = splitHighByte(registerHL9);\n      Cpu.registerL = splitLowByte(registerHL9);\n      setSubtractFlag(0);\n      return 8;\n    case 0x2A:\n\n      // LD A,(HL+)\n      // 1  8\n      let registerHLA: u16 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n      Cpu.registerA = eightBitLoadFromGBMemory(registerHLA);\n      registerHLA += 1;\n      Cpu.registerH = splitHighByte(registerHLA);\n      Cpu.registerL = splitLowByte(registerHLA);\n      return 8;\n    case 0x2B:\n\n      // DEC HL\n      // 1 8\n      let registerHLB = concatenateBytes(Cpu.registerH, Cpu.registerL);\n      registerHLB -= 1;\n      Cpu.registerH = splitHighByte(registerHLB);\n      Cpu.registerL = splitLowByte(registerHLB);\n      return 8;\n    case 0x2C:\n\n      // INC L\n      // 1  4\n      // Z 0 H -\n      checkAndSetEightBitHalfCarryFlag(Cpu.registerL, 1);\n      Cpu.registerL += 1;\n      if (Cpu.registerL === 0) {\n        setZeroFlag(1);\n      } else {\n        setZeroFlag(0);\n      }\n      setSubtractFlag(0);\n      return 4;\n    case 0x2D:\n\n      // DEC L\n      // 1  4\n      // Z 1 H -\n      checkAndSetEightBitHalfCarryFlag(Cpu.registerL, -1);\n      Cpu.registerL -= 1;\n      if (Cpu.registerL === 0) {\n        setZeroFlag(1);\n      } else {\n        setZeroFlag(0);\n      }\n      setSubtractFlag(1);\n      return 4;\n    case 0x2E:\n      // LD L,d8\n      // 2  8\n      Cpu.registerL = dataByteOne;\n      Cpu.programCounter += 1;\n      return 8;\n    case 0x2F:\n\n      // CPL\n      // 1 4\n      // - 1 1 -\n      Cpu.registerA = ~Cpu.registerA;\n      setSubtractFlag(1);\n      setHalfCarryFlag(1);\n      return 4;\n  }\n  return -1;\n}\n\nfunction handleOpcode3x(opcode: u8, dataByteOne: u8, dataByteTwo: u8, concatenatedDataByte: u16): i8 {\n  switch (opcode) {\n    case 0x30:\n\n      // JR NC,r8\n      // 2 12 / 8\n      if (getCarryFlag() === 0) {\n        relativeJump(dataByteOne);\n        return 12;\n        // Relative Jump function handles program counter\n      } else {\n        Cpu.programCounter += 1;\n        return 8;\n      }\n    case 0x31:\n      // LD SP,d16\n      // 3 12\n      Cpu.stackPointer = concatenatedDataByte;\n      Cpu.programCounter += 2;\n      return 12;\n    case 0x32:\n      // LD (HL-),A\n      // 1 8\n      let registerHL2: u16 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n      eightBitStoreIntoGBMemory(registerHL2, Cpu.registerA);\n      registerHL2 -= 1;\n      Cpu.registerH = splitHighByte(registerHL2);\n      Cpu.registerL = splitLowByte(registerHL2);\n      return 8;\n    case 0x33:\n      // INC SP\n      // 1 8\n      Cpu.stackPointer += 1;\n      return 8;\n    case 0x34:\n\n      // INC (HL)\n      // 1  12\n      // Z 0 H -\n      let registerHL4: u16 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n      let valueAtHL4: u8 = <u8>eightBitLoadFromGBMemory(registerHL4);\n      // Creating a varible for this to fix assemblyscript overflow bug\n      // Requires explicit casting\n      // https://github.com/AssemblyScript/assemblyscript/issues/26\n      let incrementer: u8 = 1;\n      checkAndSetEightBitHalfCarryFlag(<u8>valueAtHL4, <i16>incrementer);\n      valueAtHL4 = <u8>valueAtHL4 + <u8>incrementer;\n\n      if (valueAtHL4 === 0) {\n        setZeroFlag(1);\n      } else {\n        setZeroFlag(0);\n      }\n      setSubtractFlag(0);\n      eightBitStoreIntoGBMemory(registerHL4, <u8>valueAtHL4);\n      return 12;\n    case 0x35:\n\n      // DEC (HL)\n      // 1  12\n      // Z 1 H -\n      let registerHL5: u16 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n      let valueAtHL5: u8 = eightBitLoadFromGBMemory(registerHL5);\n      // NOTE: This opcode may not overflow correctly,\n      // Please see previous opcode\n      checkAndSetEightBitHalfCarryFlag(<u8>valueAtHL5, -1);\n      valueAtHL5 -= <u8>1;\n      if (valueAtHL5 === 0) {\n        setZeroFlag(1);\n      } else {\n        setZeroFlag(0);\n      }\n      setSubtractFlag(1);\n      eightBitStoreIntoGBMemory(registerHL5, <u8>valueAtHL5);\n      return 12;\n    case 0x36:\n      // LD (HL),d8\n      // 2  12\n      eightBitStoreIntoGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL), dataByteOne);\n      Cpu.programCounter += 1;\n      return 12;\n    case 0x37:\n      // SCF\n      // 1  4\n      // - 0 0 1\n      // Simply set the carry flag\n      setSubtractFlag(0);\n      setHalfCarryFlag(0);\n      setCarryFlag(1);\n      return 4;\n    case 0x38:\n\n      // JR C,r8\n      // 2 12/8\n      if (getCarryFlag() === 1) {\n        relativeJump(dataByteOne);\n        return 12;\n        // Relative Jump Funciton handles program counter\n      } else {\n        Cpu.programCounter += 1;\n        return 8;\n      }\n    case 0x39:\n\n      // ADD HL,SP\n      // 1 8\n      // - 0 H C\n      let registerHL9: u16 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n      checkAndSetSixteenBitFlagsAddOverflow(<u16>registerHL9, Cpu.stackPointer, false);\n      let result: u16 = <u16>(registerHL9 + Cpu.stackPointer);\n      Cpu.registerH = splitHighByte(<u16>result);\n      Cpu.registerL = splitLowByte(<u16>result);\n      setSubtractFlag(0);\n      return 8;\n    case 0x3A:\n\n      // LD A,(HL-)\n      // 1 8\n      let registerHLA: u16 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n      Cpu.registerA = eightBitLoadFromGBMemory(registerHLA);\n      registerHLA -= 1;\n      Cpu.registerH = splitHighByte(registerHLA);\n      Cpu.registerL = splitLowByte(registerHLA);\n      return 8;\n    case 0x3B:\n      // DEC SP\n      // 1 8\n      Cpu.stackPointer -= 1;\n      return 8;\n    case 0x3C:\n\n      // INC A\n      // 1  4\n      // Z 0 H -\n      checkAndSetEightBitHalfCarryFlag(Cpu.registerA, 1);\n      Cpu.registerA += 1;\n      if (Cpu.registerA === 0) {\n        setZeroFlag(1);\n      } else {\n        setZeroFlag(0);\n      }\n      setSubtractFlag(0);\n      return 4;\n    case 0x3D:\n\n      // DEC A\n      // 1  4\n      // Z 1 H -\n      checkAndSetEightBitHalfCarryFlag(Cpu.registerA, -1);\n      Cpu.registerA -= 1;\n      if (Cpu.registerA === 0) {\n        setZeroFlag(1);\n      } else {\n        setZeroFlag(0);\n      }\n      setSubtractFlag(1);\n      return 4;\n    case 0x3E:\n\n      // LD A,d8\n      // 2 8\n      Cpu.registerA = dataByteOne;\n      Cpu.programCounter += 1;\n      return 8;\n    case 0x3F:\n\n      // CCF\n      // 1 4\n      // - 0 0 C\n      setSubtractFlag(0);\n      setHalfCarryFlag(0);\n      if(getCarryFlag() > 0) {\n        setCarryFlag(0);\n      } else {\n        setCarryFlag(1);\n      }\n      return 4;\n  }\n  return -1;\n}\n\nfunction handleOpcode4x(opcode: u8, dataByteOne: u8, dataByteTwo: u8, concatenatedDataByte: u16): i8 {\n  switch (opcode) {\n    case 0x40:\n      // LD B,B\n      // 1 4\n      // Load B into B, Do nothing\n      return 4;\n    case 0x41:\n\n      // LD B,C\n      // 1 4\n      Cpu.registerB = Cpu.registerC;\n      return 4;\n    case 0x42:\n\n      // LD B,D\n      // 1 4\n      Cpu.registerB = Cpu.registerD;\n      return 4;\n    case 0x43:\n\n      // LD B,E\n      // 1 4\n      Cpu.registerB = Cpu.registerE;\n      return 4;\n    case 0x44:\n\n      // LD B,H\n      // 1 4\n      Cpu.registerB = Cpu.registerH;\n      return 4;\n    case 0x45:\n\n      // LD B,L\n      // 1 4\n      Cpu.registerB = Cpu.registerL;\n      return 4;\n    case 0x46:\n\n      // LD B,(HL)\n      // 1 8\n      Cpu.registerB = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n      return 8;\n    case 0x47:\n\n      // LD B,A\n      // 1 4\n      Cpu.registerB = Cpu.registerA;\n      return 4;\n    case 0x48:\n\n      // LD C,B\n      // 1 4\n      Cpu.registerC = Cpu.registerB;\n      return 4;\n    case 0x49:\n\n      // LD C,C\n      // 1 4\n      // Do nothing\n      return 4;\n    case 0x4A:\n\n      // LD C,D\n      // 1 4\n      Cpu.registerC = Cpu.registerD;\n      return 4;\n    case 0x4B:\n\n      // LD C,E\n      // 1 4\n      Cpu.registerC = Cpu.registerE;\n      return 4;\n    case 0x4C:\n\n      // LD C,H\n      // 1 4\n      Cpu.registerC = Cpu.registerH;\n      return 4;\n    case 0x4D:\n\n      // LD C,L\n      // 1 4\n      Cpu.registerC = Cpu.registerL;\n      return 4;\n    case 0x4E:\n\n      // LD C,(HL)\n      // 1 8\n      Cpu.registerC = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n      return 8;\n    case 0x4F:\n\n      // LD C,A\n      // 1 4\n      Cpu.registerC = Cpu.registerA;\n      return 4;\n  }\n  return -1;\n}\n\nfunction handleOpcode5x(opcode: u8, dataByteOne: u8, dataByteTwo: u8, concatenatedDataByte: u16): i8 {\n  switch (opcode) {\n    case 0x50:\n\n      // LD D,B\n      // 1 4\n      Cpu.registerD = Cpu.registerB;\n      return 4;\n    case 0x51:\n\n      // LD D,C\n      // 1 4\n      Cpu.registerD = Cpu.registerC;\n      return 4;\n    case 0x52:\n\n      // LD D,D\n      // 1 4\n      // Do Nothing\n      return 4;\n    case 0x53:\n\n      // LD D,E\n      // 1 4\n      Cpu.registerD = Cpu.registerE;\n      return 4;\n    case 0x54:\n\n      // LD D,H\n      // 1 4\n      Cpu.registerD = Cpu.registerH;\n      return 4;\n    case 0x55:\n\n      // LD D,L\n      // 1 4\n      Cpu.registerD = Cpu.registerL;\n      return 4;\n    case 0x56:\n\n      // LD D,(HL)\n      // 1 8\n      Cpu.registerD = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n      return 8;\n    case 0x57:\n\n      // LD D,A\n      // 1 4\n      Cpu.registerD = Cpu.registerA;\n      return 4;\n    case 0x58:\n\n      // LD E,B\n      // 1 4\n      Cpu.registerE = Cpu.registerB;\n      return 4;\n    case 0x59:\n\n      // LD E,C\n      // 1 4\n      Cpu.registerE = Cpu.registerC;\n      return 4;\n    case 0x5A:\n\n      // LD E,D\n      // 1 4\n      Cpu.registerE = Cpu.registerD;\n      return 4;\n    case 0x5B:\n\n      // LD E,E\n      // 1 4\n      // Do Nothing\n      return 4;\n    case 0x5C:\n\n      // LD E,H\n      // 1 4\n      Cpu.registerE = Cpu.registerH;\n      return 4;\n    case 0x5D:\n\n      // LD E,L\n      // 1 4\n      Cpu.registerE = Cpu.registerL;\n      return 4;\n    case 0x5E:\n\n      // LD E,(HL)\n      // 1 4\n      Cpu.registerE = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n      return 4;\n    case 0x5F:\n\n      // LD E,A\n      // 1 4\n      Cpu.registerE = Cpu.registerA;\n      return 4;\n  }\n  return -1;\n}\n\nfunction handleOpcode6x(opcode: u8, dataByteOne: u8, dataByteTwo: u8, concatenatedDataByte: u16): i8 {\n  switch (opcode) {\n    case 0x60:\n\n      // LD H,B\n      // 1 8\n      // NOTE: Thanks to @binji for catching that this should be 8 cycles, not 4\n      Cpu.registerH = Cpu.registerB;\n      return 8;\n    case 0x61:\n\n      // LD H,C\n      // 1 4\n      Cpu.registerH = Cpu.registerC;\n      return 4;\n    case 0x62:\n\n      // LD H,D\n      // 1 4\n      Cpu.registerH = Cpu.registerD;\n      return 4;\n    case 0x63:\n\n      // LD H,E\n      // 1 4\n      Cpu.registerH = Cpu.registerE;\n      return 4;\n    case 0x64:\n\n      // LD H,H\n      // 1 4\n      Cpu.registerH = Cpu.registerH;\n      return 4;\n    case 0x65:\n\n      // LD H,L\n      // 1 4\n      Cpu.registerH = Cpu.registerL;\n      return 4;\n    case 0x66:\n\n      // LD H,(HL)\n      // 1 8\n      Cpu.registerH = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n      return 8;\n    case 0x67:\n\n      // LD H,A\n      // 1 4\n      Cpu.registerH = Cpu.registerA;\n      return 4;\n    case 0x68:\n\n      // LD L,B\n      // 1 4\n      Cpu.registerL = Cpu.registerB;\n      return 4;\n    case 0x69:\n\n      // LD L,C\n      // 1 4\n      Cpu.registerL = Cpu.registerC;\n      return 4;\n    case 0x6A:\n\n      // LD L,D\n      // 1 4\n      Cpu.registerL = Cpu.registerD;\n      return 4;\n    case 0x6B:\n\n      // LD L,E\n      // 1 4\n      Cpu.registerL = Cpu.registerE;\n      return 4;\n    case 0x6C:\n\n      // LD L,H\n      // 1 4\n      Cpu.registerL = Cpu.registerH;\n      return 4;\n    case 0x6D:\n\n      // LD L,L\n      // 1 4\n      Cpu.registerL = Cpu.registerL;\n      return 4;\n    case 0x6E:\n\n      // LD L,(HL)\n      // 1 8\n      Cpu.registerL = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n      return 8;\n    case 0x6F:\n\n      // LD L,A\n      // 1 4\n      Cpu.registerL = Cpu.registerA;\n      return 4;\n  }\n  return -1;\n}\n\nfunction handleOpcode7x(opcode: u8, dataByteOne: u8, dataByteTwo: u8, concatenatedDataByte: u16): i8 {\n  switch (opcode) {\n    case 0x70:\n\n      // LD (HL),B\n      // 1 8\n      eightBitStoreIntoGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerB);\n      return 8;\n    case 0x71:\n\n      // LD (HL),C\n      // 1 8\n      eightBitStoreIntoGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerC);\n      return 8;\n    case 0x72:\n\n      // LD (HL),D\n      // 1 8\n      eightBitStoreIntoGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerD);\n      return 8;\n    case 0x73:\n\n      // LD (HL),E\n      // 1 8\n      eightBitStoreIntoGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerE);\n      return 8;\n    case 0x74:\n\n      // LD (HL),H\n      // 1 8\n      eightBitStoreIntoGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerH);\n      return 8;\n    case 0x75:\n\n      // LD (HL),L\n      // 1 8\n      eightBitStoreIntoGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerL);\n      return 8;\n    case 0x76:\n\n      // HALT\n      // 1 4\n      // Enter CPU very low power mode\n      // Meaning Don't Decode anymore opcodes until an interrupt occurs\n      // Still need to do timers and things\n\n      // Can't Halt during an HDMA\n      // https://gist.github.com/drhelius/3394856\n      if(!Memory.isHblankHdmaActive) {\n        Cpu.isHalted = true;\n      }\n      return 4;\n    case 0x77:\n\n      // LD (HL),A\n      // 1 8\n      eightBitStoreIntoGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL), Cpu.registerA);\n      return 8;\n    case 0x78:\n\n      // LD A,B\n      // 1 4\n      Cpu.registerA = Cpu.registerB;\n      return 4;\n    case 0x79:\n\n      // LD A,C\n      // 1 4\n      Cpu.registerA = Cpu.registerC;\n      return 4;\n    case 0x7A:\n\n      // LD A,D\n      // 1 4\n      Cpu.registerA = Cpu.registerD;\n      return 4;\n    case 0x7B:\n\n      // LD A,E\n      // 1 4\n      Cpu.registerA = Cpu.registerE;\n      return 4;\n    case 0x7C:\n\n      // LD A,H\n      // 1 4\n      Cpu.registerA = Cpu.registerH;\n      return 4;\n    case 0x7D:\n\n      // LD A,L\n      // 1 4\n      Cpu.registerA = Cpu.registerL;\n      return 4;\n    case 0x7E:\n\n      // LD A,(HL)\n      // 1 8\n      // NOTE: Thanks to @binji for catching that this should be 8 cycles, not 4\n      Cpu.registerA = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n      return 8;\n    case 0x7F:\n\n      // LD A,A\n      // 1 4\n      // Do Nothing\n      return 4;\n  }\n  return -1;\n}\n\nfunction handleOpcode8x(opcode: u8, dataByteOne: u8, dataByteTwo: u8, concatenatedDataByte: u16): i8 {\n  switch (opcode) {\n    case 0x80:\n      // ADD A,B\n      // 1 4\n      // Z 0 H C\n      addARegister(Cpu.registerB);\n      return 4;\n    case 0x81:\n      // ADD A,C\n      // 1 4\n      // Z 0 H C\n      addARegister(Cpu.registerC);\n      return 4;\n    case 0x82:\n      // ADD A,D\n      // 1 4\n      // Z 0 H C\n      addARegister(Cpu.registerD);\n      return 4;\n    case 0x83:\n      // ADD A,E\n      // 1 4\n      // Z 0 H C\n      addARegister(Cpu.registerE);\n      return 4;\n    case 0x84:\n      // ADD A,H\n      // 1 4\n      // Z 0 H C\n      addARegister(Cpu.registerH);\n      return 4;\n    case 0x85:\n      // ADD A,L\n      // 1 4\n      // Z 0 H C\n      addARegister(Cpu.registerL);\n      return 4;\n    case 0x86:\n      // ADD A,(HL)\n      // 1 8\n      // Z 0 H C\n      let valueAtHL6: u8 = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n      addARegister(<u8>valueAtHL6);\n      return 8;\n    case 0x87:\n      // ADD A,A\n      // 1 4\n      // Z 0 H C\n      addARegister(Cpu.registerA);\n      return 4;\n    case 0x88:\n      // ADC A,B\n      // 1 4\n      // Z 0 H C\n      addAThroughCarryRegister(Cpu.registerB);\n      return 4;\n    case 0x89:\n      // ADC A,C\n      // 1 4\n      // Z 0 H C\n      addAThroughCarryRegister(Cpu.registerC);\n      return 4;\n    case 0x8A:\n      // ADC A,D\n      // 1 4\n      // Z 0 H C\n      addAThroughCarryRegister(Cpu.registerD);\n      return 4;\n    case 0x8B:\n      // ADC A,E\n      // 1 4\n      // Z 0 H C\n      addAThroughCarryRegister(Cpu.registerE);\n      return 4;\n    case 0x8C:\n      // ADC A,H\n      // 1 4\n      // Z 0 H C\n      addAThroughCarryRegister(Cpu.registerH);\n      return 4;\n    case 0x8D:\n      // ADC A,L\n      // 1 4\n      // Z 0 H C\n      addAThroughCarryRegister(Cpu.registerL);\n      return 4;\n    case 0x8E:\n      // ADC A,(HL)\n      // 1 8\n      // Z 0 H C\n      let valueAtHLE: u8 = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n      addAThroughCarryRegister(<u8>valueAtHLE);\n      return 8;\n    case 0x8F:\n      // ADC A,A\n      // 1 4\n      // Z 0 H C\n      addAThroughCarryRegister(Cpu.registerA);\n      return 4;\n  }\n  return -1;\n}\n\nfunction handleOpcode9x(opcode: u8, dataByteOne: u8, dataByteTwo: u8, concatenatedDataByte: u16): i8 {\n  switch (opcode) {\n    case 0x90:\n\n      // SUB B\n      // 1  4\n      // Z 1 H C\n      subARegister(Cpu.registerB);\n      return 4;\n    case 0x91:\n\n      // SUB C\n      // 1  4\n      // Z 1 H C\n      subARegister(Cpu.registerC);\n      return 4;\n    case 0x92:\n\n      // SUB D\n      // 1  4\n      // Z 1 H C\n      subARegister(Cpu.registerD);\n      return 4;\n    case 0x93:\n\n      // SUB E\n      // 1  4\n      // Z 1 H C\n      subARegister(Cpu.registerE);\n      return 4;\n    case 0x94:\n\n      // SUB H\n      // 1  4\n      // Z 1 H C\n      subARegister(Cpu.registerH);\n      return 4;\n    case 0x95:\n\n      // SUB L\n      // 1  4\n      // Z 1 H C\n      subARegister(Cpu.registerL);\n      return 4;\n    case 0x96:\n\n      // SUB (HL)\n      // 1  8\n      // Z 1 H C\n      let valueAtHL6: u8 = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n      subARegister(<u8>valueAtHL6);\n      return 8;\n    case 0x97:\n\n      // SUB A\n      // 1  4\n      // Z 1 H C\n      subARegister(Cpu.registerA);\n      return 4;\n    case 0x98:\n\n      // SBC A,B\n      // 1  4\n      // Z 1 H C\n      subAThroughCarryRegister(Cpu.registerB);\n      return 4;\n    case 0x99:\n\n      // SBC A,C\n      // 1  4\n      // Z 1 H C\n      subAThroughCarryRegister(Cpu.registerC);\n      return 4;\n    case 0x9A:\n\n      // SBC A,D\n      // 1  4\n      // Z 1 H C\n      subAThroughCarryRegister(Cpu.registerD);\n      return 4;\n    case 0x9B:\n\n      // SBC A,E\n      // 1  4\n      // Z 1 H C\n      subAThroughCarryRegister(Cpu.registerE);\n      return 4;\n    case 0x9C:\n\n      // SBC A,H\n      // 1  4\n      // Z 1 H C\n      subAThroughCarryRegister(Cpu.registerH);\n      return 4;\n    case 0x9D:\n\n      // SBC A,L\n      // 1  4\n      // Z 1 H C\n      subAThroughCarryRegister(Cpu.registerL);\n      return 4;\n    case 0x9E:\n\n      // SBC A,(HL)\n      // 1  8\n      // Z 1 H C\n      let valueAtHLE: u8 = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n      subAThroughCarryRegister(<u8>valueAtHLE);\n      return 8;\n    case 0x9F:\n\n      // SBC A,A\n      // 1  4\n      // Z 1 H C\n      subAThroughCarryRegister(Cpu.registerA);\n      return 4;\n  }\n  return -1;\n}\n\nfunction handleOpcodeAx(opcode: u8, dataByteOne: u8, dataByteTwo: u8, concatenatedDataByte: u16): i8 {\n  switch (opcode) {\n    case 0xA0:\n\n      // AND B\n      // 1  4\n      // Z 0 1 0\n      andARegister(Cpu.registerB);\n      return 4;\n    case 0xA1:\n\n      // AND C\n      // 1  4\n      // Z 0 1 0\n      andARegister(Cpu.registerC);\n      return 4;\n    case 0xA2:\n\n      // AND D\n      // 1  4\n      // Z 0 1 0\n      andARegister(Cpu.registerD);\n      return 4;\n    case 0xA3:\n\n      // AND E\n      // 1  4\n      // Z 0 1 0\n      andARegister(Cpu.registerE);\n      return 4;\n    case 0xA4:\n\n      // AND H\n      // 1  4\n      // Z 0 1 0\n      andARegister(Cpu.registerH);\n      return 4;\n    case 0xA5:\n\n      // AND L\n      // 1  4\n      // Z 0 1 0\n      andARegister(Cpu.registerL);\n      return 4;\n    case 0xA6:\n\n      // AND (HL)\n      // 1  8\n      // Z 0 1 0\n      let valueAtHL6: u8 = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n      andARegister(<u8>valueAtHL6);\n      return 8;\n    case 0xA7:\n\n      // AND A\n      // 1  4\n      // Z 0 1 0\n      // NOTE: & Yourself, does nothing\n      andARegister(Cpu.registerA);\n      return 4;\n    case 0xA8:\n\n      // XOR B\n      // 1  4\n      // Z 0 0 0\n      xorARegister(Cpu.registerB);\n      return 4;\n    case 0xA9:\n\n      // XOR C\n      // 1  4\n      // Z 0 0 0\n      xorARegister(Cpu.registerC);\n      return 4;\n    case 0xAA:\n\n      // XOR D\n      // 1  4\n      // Z 0 0 0\n      xorARegister(Cpu.registerD);\n      return 4;\n    case 0xAB:\n\n      // XOR E\n      // 1  4\n      // Z 0 0 0\n      xorARegister(Cpu.registerE);\n      return 4;\n    case 0xAC:\n\n      // XOR H\n      // 1  4\n      // Z 0 0 0\n      xorARegister(Cpu.registerH);\n      return 4;\n    case 0xAD:\n\n      // XOR L\n      // 1  4\n      // Z 0 0 0\n      xorARegister(Cpu.registerL);\n      return 4;\n    case 0xAE:\n\n      // XOR (HL)\n      // 1  8\n      // Z 0 0 0\n      let valueAtHLE: u8 = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n      xorARegister(<u8>valueAtHLE);\n      return 8;\n    case 0xAF:\n\n      // XOR A\n      // 1  4\n      // Z 0 0 0\n      xorARegister(Cpu.registerA);\n      return 4;\n  }\n  return -1;\n}\n\nfunction handleOpcodeBx(opcode: u8, dataByteOne: u8, dataByteTwo: u8, concatenatedDataByte: u16): i8 {\n  switch (opcode) {\n    case 0xB0:\n\n      // OR B\n      // 1  4\n      // Z 0 0 0\n      orARegister(Cpu.registerB);\n      return 4;\n    case 0xB1:\n\n      // OR C\n      // 1  4\n      // Z 0 0 0\n      orARegister(Cpu.registerC);\n      return 4;\n    case 0xB2:\n\n      // OR D\n      // 1  4\n      // Z 0 0 0\n      orARegister(Cpu.registerD);\n      return 4;\n    case 0xB3:\n\n      // OR E\n      // 1  4\n      // Z 0 0 0\n      orARegister(Cpu.registerE);\n      return 4;\n    case 0xB4:\n\n      // OR H\n      // 1  4\n      // Z 0 0 0\n      orARegister(Cpu.registerH);\n      return 4;\n    case 0xB5:\n\n      // OR L\n      // 1  4\n      // Z 0 0 0\n      orARegister(Cpu.registerL);\n      return 4;\n    case 0xB6:\n\n      // OR (HL)\n      // 1  8\n      // Z 0 0 0\n      let valueAtHL6: u8 = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n      orARegister(<u8>valueAtHL6);\n      return 8;\n    case 0xB7:\n\n      // OR A\n      // 1  4\n      // Z 0 0 0\n      orARegister(Cpu.registerA);\n      return 4;\n    case 0xB8:\n\n      // CP B\n      // 1  4\n      // Z 1 H C\n      cpARegister(Cpu.registerB);\n      return 4;\n    case 0xB9:\n\n      // CP C\n      // 1  4\n      // Z 1 H C\n      cpARegister(Cpu.registerC);\n      return 4;\n    case 0xBA:\n\n      // CP D\n      // 1  4\n      // Z 1 H C\n      cpARegister(Cpu.registerD);\n      return 4;\n    case 0xBB:\n\n      // CP E\n      // 1  4\n      // Z 1 H C\n      cpARegister(Cpu.registerE);\n      return 4;\n    case 0xBC:\n\n      // CP H\n      // 1  4\n      // Z 1 H C\n      cpARegister(Cpu.registerH);\n      return 4;\n    case 0xBD:\n\n      // CP L\n      // 1  4\n      // Z 1 H C\n      cpARegister(Cpu.registerL);\n      return 4;\n    case 0xBE:\n\n      // CP (HL)\n      // 1  8\n      // Z 1 H C\n      let valueAtHLE: u8 = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n      cpARegister(<u8>valueAtHLE);\n      return 8;\n    case 0xBF:\n\n      // CP A\n      // 1  4\n      // Z 1 H C\n      cpARegister(Cpu.registerA);\n      return 4;\n  }\n  return -1;\n}\n\nfunction handleOpcodeCx(opcode: u8, dataByteOne: u8, dataByteTwo: u8, concatenatedDataByte: u16): i8 {\n  switch (opcode) {\n    case 0xC0:\n\n      // RET NZ\n      // 1  20/8\n      if (getZeroFlag() === 0) {\n        Cpu.programCounter = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n        Cpu.stackPointer += 2;\n        return 20;\n      } else {\n        return 8;\n      }\n    case 0xC1:\n\n      // POP BC\n      // 1  12\n      let registerBC1 = concatenateBytes(Cpu.registerB, Cpu.registerC);\n      registerBC1 = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n      Cpu.stackPointer += 2;\n      Cpu.registerB = splitHighByte(registerBC1);\n      Cpu.registerC = splitLowByte(registerBC1);\n      return 12;\n    case 0xC2:\n\n      // JP NZ,a16\n      // 3  16/12\n      if (getZeroFlag() === 0) {\n        Cpu.programCounter = concatenatedDataByte;\n        return 16;\n      } else {\n        Cpu.programCounter += 2;\n        return 12;\n      }\n    case 0xC3:\n\n      // JP a16\n      // 3  16\n      Cpu.programCounter = concatenatedDataByte;\n      return 16;\n    case 0xC4:\n\n      // CALL NZ,a16\n      // 3  24/12\n      if (getZeroFlag() === 0) {\n        Cpu.stackPointer -= 2;\n        sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter + 2);\n        Cpu.programCounter = concatenatedDataByte;\n        return 24;\n      } else {\n        Cpu.programCounter += 2;\n        return 12;\n      }\n    case 0xC5:\n\n      // PUSH BC\n      // 1  16\n      let registerBC5 = concatenateBytes(Cpu.registerB, Cpu.registerC);\n      Cpu.stackPointer -= 2;\n      sixteenBitStoreIntoGBMemory(Cpu.stackPointer, registerBC5);\n      return 16;\n    case 0xC6:\n\n      // ADD A,d8\n      // 2 8\n      // Z 0 H C\n      addARegister(dataByteOne);\n      Cpu.programCounter += 1;\n      return 8;\n    case 0xC7:\n\n      // RST 00H\n      // 1 16\n      Cpu.stackPointer -= 2;\n      sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter);\n      Cpu.programCounter = 0x00;\n      return 16;\n    case 0xC8:\n\n      // RET Z\n      // 1  20/8\n      if (getZeroFlag() === 1) {\n        Cpu.programCounter = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n        Cpu.stackPointer += 2;\n        return 20;\n      } else {\n        return 8;\n      }\n    case 0xC9:\n\n      // RET\n      // 1 16\n      Cpu.programCounter = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n      Cpu.stackPointer += 2;\n      return 16;\n    case 0xCA:\n\n      // JP Z,a16\n      // 3 16/12\n      if (getZeroFlag() === 1) {\n        Cpu.programCounter = concatenatedDataByte;\n        return 16;\n      } else {\n        Cpu.programCounter += 2;\n        return 12;\n      }\n    case 0xCB:\n      // PREFIX CB\n      // 1  4\n      let cbCycles = handleCbOpcode(dataByteOne)\n      if(cbCycles > 0) {\n        cbCycles += 4;\n      }\n      return cbCycles;\n    case 0xCC:\n\n      // CALL Z,a16\n      // 3  24/12\n      if (getZeroFlag() === 1) {\n        Cpu.stackPointer -= 2;\n        sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter + 2);\n        Cpu.programCounter = concatenatedDataByte;\n        return 24;\n      } else {\n        Cpu.programCounter += 2;\n        return 12;\n      }\n    case 0xCD:\n\n      // CALL a16\n      // 3  24\n      Cpu.stackPointer -= 2;\n      sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter + 2);\n      Cpu.programCounter = concatenatedDataByte;\n      return 24;\n    case 0xCE:\n\n      // ADC A,d8\n      // 2  8\n      // Z 0 H C\n      addAThroughCarryRegister(dataByteOne);\n      Cpu.programCounter += 1;\n      return 8;\n    case 0xCF:\n\n      // RST 08H\n      // 1 16\n      Cpu.stackPointer -= 2;\n      sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter);\n      Cpu.programCounter = 0x08;\n      return 16;\n  }\n  return -1;\n}\n\nfunction handleOpcodeDx(opcode: u8, dataByteOne: u8, dataByteTwo: u8, concatenatedDataByte: u16): i8 {\n  switch (opcode) {\n    case 0xD0:\n\n      // RET NC\n      // 1  20/8\n      if (getCarryFlag() === 0) {\n        Cpu.programCounter = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n        Cpu.stackPointer += 2;\n        return 20;\n      } else {\n        return 8;\n      }\n    case 0xD1:\n\n      // POP DE\n      // 1  12\n      let registerDE1 = concatenateBytes(Cpu.registerD, Cpu.registerE);\n      registerDE1 = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n      Cpu.stackPointer += 2;\n      Cpu.registerD = splitHighByte(registerDE1);\n      Cpu.registerE = splitLowByte(registerDE1);\n      return 12;\n    case 0xD2:\n\n      // JP NC,a16\n      // 3  16/12\n      if (getCarryFlag() === 0) {\n        Cpu.programCounter = concatenatedDataByte;\n        return 16;\n      } else {\n        Cpu.programCounter += 2;\n        return 12;\n      }\n    /* No Opcode for: 0xD3 */\n    case 0xD4:\n\n      // CALL NC,a16\n      // 3  24/12\n      if (getCarryFlag() === 0) {\n        Cpu.stackPointer -= 2;\n        sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter + 2);\n        Cpu.programCounter = concatenatedDataByte;\n        return 24;\n      } else {\n        Cpu.programCounter += 2;\n        return 12;\n      }\n    case 0xD5:\n\n      // PUSH DE\n      // 1 16\n      let registerDE5 = concatenateBytes(Cpu.registerD, Cpu.registerE);\n      Cpu.stackPointer -= 2;\n      sixteenBitStoreIntoGBMemory(Cpu.stackPointer, registerDE5);\n      return 16;\n    case 0xD6:\n\n      // SUB d8\n      // 2  8\n      // Z 1 H C\n      subARegister(dataByteOne);\n      Cpu.programCounter += 1;\n      return 8;\n    case 0xD7:\n\n      // RST 10H\n      // 1 16\n      Cpu.stackPointer -= 2;\n      sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter);\n      Cpu.programCounter = 0x10;\n      return 16;\n    case 0xD8:\n\n      // RET C\n      // 1  20/8\n      if (getCarryFlag() === 1) {\n        Cpu.programCounter = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n        Cpu.stackPointer += 2;\n        return 20;\n      } else {\n        return 8;\n      }\n    case 0xD9:\n\n      // RETI\n      // 1  16\n      Cpu.programCounter = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n      // Enable interrupts\n      setInterrupts(true);\n      Cpu.stackPointer += 2;\n      return 16;\n    case 0xDA:\n\n      // JP C,a16\n      // 3 16/12\n      if (getCarryFlag() === 1) {\n        Cpu.programCounter = concatenatedDataByte;\n        return 16;\n      } else {\n        Cpu.programCounter += 2;\n        return 12;\n      }\n    /* No Opcode for: 0xDB */\n    case 0xDC:\n\n      // CALL C,a16\n      // 3  24/12\n      if (getCarryFlag() === 1) {\n        Cpu.stackPointer -= 2;\n        sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter + 2);\n        Cpu.programCounter = concatenatedDataByte;\n        return 24;\n      } else {\n        Cpu.programCounter += 2;\n        return 12;\n      }\n    /* No Opcode for: 0xDD */\n    case 0xDE:\n\n      // SBC A,d8\n      // 2 8\n      // Z 1 H C\n      subAThroughCarryRegister(dataByteOne);\n      Cpu.programCounter += 1;\n      return 8;\n    case 0xDF:\n      // RST 18H\n      // 1 16\n      Cpu.stackPointer -= 2;\n      sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter);\n      Cpu.programCounter = 0x18;\n      return 16;\n  }\n  return -1;\n}\n\nfunction handleOpcodeEx(opcode: u8, dataByteOne: u8, dataByteTwo: u8, concatenatedDataByte: u16): i8 {\n  switch (opcode) {\n    case 0xE0:\n\n      // LDH (a8),A\n      // 2  12\n\n      // Store value in high RAM ($FF00 + a8)\n      let largeDataByteOne: u16 = dataByteOne;\n      eightBitStoreIntoGBMemory(0xFF00 + largeDataByteOne, Cpu.registerA);\n      Cpu.programCounter += 1;\n      return 12;\n    case 0xE1:\n\n      // POP HL\n      // 1  12\n      let registerHL1 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n      registerHL1 = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n      Cpu.stackPointer += 2;\n      Cpu.registerH = splitHighByte(registerHL1);\n      Cpu.registerL = splitLowByte(registerHL1);\n      return 12;\n    case 0xE2:\n\n      // LD (C),A\n      // 1  8\n      // NOTE: Table says 2 Program counter,\n      // But stepping through the boot rom, should be one\n      // Also should change 0xF2\n\n      // Store value in high RAM ($FF00 + register c)\n      eightBitStoreIntoGBMemory(0xFF00 + Cpu.registerC, Cpu.registerA);\n      return 8;\n    /* No Opcode for: 0xE3, 0xE4 */\n    case 0xE5:\n\n      // PUSH HL\n      // 1 16\n      let registerHL5 = concatenateBytes(Cpu.registerH, Cpu.registerL);\n      Cpu.stackPointer -= 2;\n      sixteenBitStoreIntoGBMemory(Cpu.stackPointer, registerHL5);\n      return 16;\n    case 0xE6:\n\n      // AND d8\n      // 2  8\n      // Z 0 1 0\n      andARegister(dataByteOne);\n      Cpu.programCounter += 1;\n      return 8;\n    case 0xE7:\n\n      // RST 20H\n      // 1 16\n      Cpu.stackPointer -= 2;\n      sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter);\n      Cpu.programCounter = 0x20;\n      return 16;\n    case 0xE8:\n\n      // ADD SP, r8\n      // 2 16\n      // 0 0 H C\n      // NOTE: Discoved dataByte is signed\n      let signedDataByteOne: i8 = <i8>dataByteOne;\n\n      checkAndSetSixteenBitFlagsAddOverflow(Cpu.stackPointer, signedDataByteOne, true);\n      Cpu.stackPointer += signedDataByteOne;\n      setZeroFlag(0);\n      setSubtractFlag(0);\n      Cpu.programCounter += 1;\n      return 16;\n    case 0xE9:\n\n      // JP HL\n      // 1 4\n      Cpu.programCounter = concatenateBytes(Cpu.registerH, Cpu.registerL);\n      return 4;\n    case 0xEA:\n\n      // LD (a16),A\n      // 3 16\n      eightBitStoreIntoGBMemory(concatenatedDataByte, Cpu.registerA);\n      Cpu.programCounter += 2;\n      return 16;\n    /* No Opcode for: 0xEB, 0xEC, 0xED */\n    case 0xEE:\n\n      // XOR d8\n      // 2 8\n      // Z 0 0 0\n      xorARegister(dataByteOne);\n      Cpu.programCounter += 1;\n      return 8;\n    case 0xEF:\n\n      // RST 28H\n      // 1 16\n      Cpu.stackPointer -= 2;\n      sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter);\n      Cpu.programCounter = 0x28;\n      return 16;\n  }\n  return -1;\n}\n\nfunction handleOpcodeFx(opcode: u8, dataByteOne: u8, dataByteTwo: u8, concatenatedDataByte: u16): i8 {\n  switch (opcode) {\n    case 0xF0:\n\n      // LDH A,(a8)\n      // 2 12\n      let largeDataByteOne: u16 = dataByteOne;\n      Cpu.registerA = eightBitLoadFromGBMemory(0xFF00 + largeDataByteOne);\n      Cpu.programCounter += 1;\n      return 12;\n    case 0xF1:\n\n      // POP AF\n      // 1 12\n      // Z N H C (But No work require, flags are already set)\n      let registerAF1 = concatenateBytes(Cpu.registerA, Cpu.registerF);\n      registerAF1 = sixteenBitLoadFromGBMemory(Cpu.stackPointer);\n      Cpu.stackPointer += 2;\n      Cpu.registerA = splitHighByte(registerAF1);\n      Cpu.registerF = splitLowByte(registerAF1);\n      return 12;\n    case 0xF2:\n\n      // LD A,(C)\n      // 1 8\n      Cpu.registerA = eightBitLoadFromGBMemory(0xFF00 + Cpu.registerC);\n      return 8;\n    case 0xF3:\n\n      // DI\n      // 1 4\n      setInterrupts(false);\n      return 4;\n    /* No Opcode for: 0xF4 */\n    case 0xF5:\n\n      // PUSH AF\n      // 1 16\n      let registerAF5 = concatenateBytes(Cpu.registerA, Cpu.registerF);\n      Cpu.stackPointer -= 2;\n      sixteenBitStoreIntoGBMemory(Cpu.stackPointer, registerAF5);\n      return 16;\n    case 0xF6:\n\n      // OR d8\n      // 2 8\n      // Z 0 0 0\n      orARegister(dataByteOne);\n      Cpu.programCounter += 1;\n      return 8;\n    case 0xF7:\n\n      // RST 30H\n      // 1 16\n      Cpu.stackPointer -= 2;\n      sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter);\n      Cpu.programCounter = 0x30;\n      return 16;\n    case 0xF8:\n\n      // LD HL,SP+r8\n      // 2 12\n      // 0 0 H C\n      // NOTE: Discoved dataByte is signed\n      let signedDataByteOne: i8 = <i8>dataByteOne;\n\n      // First, let's handle flags\n      setZeroFlag(0);\n      setSubtractFlag(0);\n      checkAndSetSixteenBitFlagsAddOverflow(Cpu.stackPointer, signedDataByteOne, true);\n      let registerHL = Cpu.stackPointer + signedDataByteOne;\n      Cpu.registerH = splitHighByte(registerHL);\n      Cpu.registerL = splitLowByte(registerHL);\n      Cpu.programCounter += 1;\n      return 12;\n    case 0xF9:\n\n      // LD SP,HL\n      // 1 8\n      Cpu.stackPointer = concatenateBytes(Cpu.registerH, Cpu.registerL);\n      return 8;\n    case 0xFA:\n\n      // LD A,(a16)\n      // 3 16\n      Cpu.registerA = eightBitLoadFromGBMemory(concatenatedDataByte);\n      Cpu.programCounter += 2;\n      return 16;\n    case 0xFB:\n\n      // EI\n      // 1 4\n      setInterrupts(true);\n      return 4;\n    /* No Opcode for: 0xFC, 0xFD */\n    case 0xFE:\n\n      // CP d8\n      // 2 8\n      // Z 1 H C\n      cpARegister(dataByteOne);\n      Cpu.programCounter += 1;\n      return 8;\n    case 0xFF:\n\n      // RST 38H\n      // 1 16\n      Cpu.stackPointer -= 2;\n      sixteenBitStoreIntoGBMemory(Cpu.stackPointer, Cpu.programCounter);\n      Cpu.programCounter = 0x38;\n      return 16;\n  }\n  return -1;\n}\n","import {\n  Memory\n} from './memory';\nimport {\n  Graphics,\n  batchProcessGraphics\n} from '../graphics/graphics';\nimport {\n  Palette\n} from '../graphics/index';\nimport {\n  batchProcessAudio,\n  handleReadToSoundRegister\n} from '../sound/index';\nimport {\n  eightBitStoreIntoGBMemorySkipTraps\n} from './store';\nimport {\n  eightBitLoadFromGBMemorySkipTraps\n} from './load';\nimport {\n  Joypad,\n  getJoypadState\n} from '../joypad/index'\nimport {\n  hexLog\n} from '../helpers/index';\n\n// Returns -1 if no trap found, otherwise returns a value that should be fed for the address\nexport function checkReadTraps(offset: u16): i32 {\n\n  // Cache globals used multiple times for performance\n  let videoRamLocation: u16 = Memory.videoRamLocation;\n\n  // Try to break early for most common scenario\n  if (offset < videoRamLocation) {\n    return -1;\n  }\n\n  // Check the graphics mode to see if we can read VRAM\n  // http://gbdev.gg8.se/wiki/articles/Video_Display#Accessing_VRAM_and_OAM\n  if(offset >= videoRamLocation && offset < Memory.cartridgeRamLocation) {\n    // Can only read/write from VRAM During Modes 0 - 2\n    // See graphics/lcd.ts\n    // TODO: This can do more harm than good in a beta emulator,\n    // requres precise timing, disabling for now\n    // if (Graphics.currentLcdMode > 2) {\n    //   return 0xFF;\n    // }\n\n    // Not batch processing here for performance\n    // batchProcessGraphics();\n  }\n\n  // ECHO Ram, E000\tFDFF\tMirror of C000~DDFF (ECHO RAM)\n  // http://gbdev.gg8.se/wiki/articles/Memory_Map\n  if(offset >= Memory.echoRamLocation && offset < Memory.spriteInformationTableLocation) {\n    // Simply return the mirror'd value\n    return eightBitLoadFromGBMemorySkipTraps(offset - 0x2000);\n  }\n\n  // Check for individal writes\n  // Can only read/write from OAM During Modes 0 - 1\n  // See graphics/lcd.ts\n  if(offset >= Memory.spriteInformationTableLocation && offset <= Memory.spriteInformationTableLocationEnd) {\n    // Can only read/write from OAM During Mode 2\n    // See graphics/lcd.ts\n    if (Graphics.currentLcdMode < 2) {\n      return 0xFF;\n    }\n\n    // Not batch processing here for performance\n    // batchProcessGraphics();\n  }\n\n  if(offset === Joypad.memoryLocationJoypadRegister) {\n    return getJoypadState();\n  }\n\n  // Sound\n  // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Registers\n  // TODO: Put these bounds on the Sound Class\n  if(offset >= 0xFF10 && offset <= 0xFF26) {\n    batchProcessAudio();\n    let soundReadResponse: i32 = handleReadToSoundRegister(offset);\n    if(soundReadResponse < 0) {\n      return -1;\n    }\n    return <u8>soundReadResponse;\n  }\n  // FF27 - FF2F not used\n  // Final Wave Table for Channel 3\n  if(offset >= 0xFF30 && offset <= 0xFF3F) {\n    batchProcessAudio();\n  }\n\n  // Batch Process Graphics\n  // http://gameboy.mongenel.com/dmg/asmmemmap.html and http://gbdev.gg8.se/wiki/articles/Video_Display\n  // if (offset >= Graphics.memoryLocationLcdControl && offset <= Graphics.memoryLocationWindowX) {\n  //   // Not batch processing here for performance\n  //   // batchProcessGraphics();\n  // }\n\n  return -1;\n}\n","// Main Class and funcitons for rendering the gameboy display\nimport {\n  setLcdStatus,\n  isLcdEnabled\n} from './lcd';\nimport {\n  renderBackground,\n  renderWindow\n} from './backgroundWindow';\nimport {\n  renderSprites\n} from './sprites';\nimport {\n  Cpu\n} from '../cpu/cpu'\nimport {\n  Config\n} from '../config';\nimport {\n  eightBitLoadFromGBMemorySkipTraps,\n  eightBitStoreIntoGBMemorySkipTraps,\n  updateHblankHdma,\n  storeFrameToBeRendered,\n  getSaveStateMemoryOffset,\n  loadBooleanDirectlyFromWasmMemory,\n  storeBooleanDirectlyToWasmMemory\n} from '../memory/index';\nimport {\n  requestVBlankInterrupt\n} from '../interrupts/index';\nimport {\n  checkBitOnByte,\n  setBitOnByte,\n  resetBitOnByte,\n  performanceTimestamp,\n  hexLog\n} from '../helpers/index';\n\nexport class Graphics {\n\n  // Current cycles\n  // This will be used for batch processing\n  static currentCycles: i32 = 0;\n\n  // Number of cycles to run in each batch process\n  // This number should be in sync so that graphics doesn't run too many cyles at once\n  // and does not exceed the minimum number of cyles for either scanlines, or\n  // How often we change the frame, or a channel's update process\n  static batchProcessCycles(): i32 {\n      return Graphics.MAX_CYCLES_PER_SCANLINE();\n  }\n\n  // Count the number of cycles to keep synced with cpu cycles\n  // Found GBC cycles by finding clock speed from Gb Cycles\n  // See TCAGBD For cycles\n  static scanlineCycleCounter: i32 = 0x00;\n\n  static MAX_CYCLES_PER_SCANLINE(): i32 {\n    if (Cpu.GBCDoubleSpeed) {\n      return 912;\n    }\n\n    return 456;\n  }\n\n  static MIN_CYCLES_SPRITES_LCD_MODE(): i32 {\n    if (Cpu.GBCDoubleSpeed) {\n      // TODO: Confirm these clock cyles, double similar to scanline, which TCAGBD did\n      return 752;\n    }\n\n    return 376;\n  }\n  static MIN_CYCLES_TRANSFER_DATA_LCD_MODE(): i32 {\n    if (Cpu.GBCDoubleSpeed) {\n      // TODO: Confirm these clock cyles, double similar to scanline, which TCAGBD did\n      return 498;\n    }\n\n    return 249;\n  }\n\n  // LCD\n  // scanlineRegister also known as LY\n  // See: http://bgb.bircd.org/pandocs.txt , and search \" LY \"\n  static readonly memoryLocationScanlineRegister: u16 = 0xFF44;\n  static readonly memoryLocationCoincidenceCompare: u16 = 0xFF45;\n  static readonly memoryLocationDmaTransfer: u16 = 0xFF46;\n\n  // Also known at STAT\n  static readonly memoryLocationLcdStatus: u16 = 0xFF41;\n  // Also known as LCDC\n  static readonly memoryLocationLcdControl: u16 = 0xFF40;\n  static currentLcdMode: u8 = 0;\n\n  // Scroll and Window\n  static readonly memoryLocationScrollX: u16 = 0xFF43;\n  static readonly memoryLocationScrollY: u16 = 0xFF42;\n  static readonly memoryLocationWindowX: u16 = 0xFF4B;\n  static readonly memoryLocationWindowY: u16 = 0xFF4A;\n\n  // Tile Maps And Data\n  static readonly memoryLocationTileMapSelectZeroStart: u16 = 0x9800;\n  static readonly memoryLocationTileMapSelectOneStart: u16 = 0x9C00;\n  static readonly memoryLocationTileDataSelectZeroStart: u16 = 0x8800;\n  static readonly memoryLocationTileDataSelectOneStart: u16 = 0x8000;\n\n  // Sprites\n  static readonly memoryLocationSpriteAttributesTable: u16 = 0xFE00;\n\n  // Palettes\n  static readonly memoryLocationBackgroundPalette: u16 = 0xFF47;\n  static readonly memoryLocationSpritePaletteOne: u16 = 0xFF48;\n  static readonly memoryLocationSpritePaletteTwo: u16 = 0xFF49;\n\n  // Screen data needs to be stored in wasm memory\n\n  // Save States\n\n  static readonly saveStateSlot: u16 = 1;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    store<i32>(getSaveStateMemoryOffset(0x00, Graphics.saveStateSlot), Graphics.scanlineCycleCounter);\n    store<u8>(getSaveStateMemoryOffset(0x04, Graphics.saveStateSlot), Graphics.currentLcdMode);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    Graphics.scanlineCycleCounter = load<i32>(getSaveStateMemoryOffset(0x00, Graphics.saveStateSlot));\n    Graphics.currentLcdMode = load<u8>(getSaveStateMemoryOffset(0x04, Graphics.saveStateSlot));\n  }\n}\n\n// Batch Process Graphics\n// http://gameboy.mongenel.com/dmg/asmmemmap.html and http://gbdev.gg8.se/wiki/articles/Video_Display\n// Function to batch process our graphics after we skipped so many cycles\n// This is not currently checked in memory read/write\nexport function batchProcessGraphics(): void {\n\n  if (Graphics.currentCycles < Graphics.batchProcessCycles()) {\n    return;\n  }\n\n  while (Graphics.currentCycles >= Graphics.batchProcessCycles()) {\n    updateGraphics(Graphics.batchProcessCycles());\n    Graphics.currentCycles = Graphics.currentCycles - Graphics.batchProcessCycles();\n  }\n}\n\nexport function updateGraphics(numberOfCycles: i32): void {\n\n  // Get if the LCD is currently enabled\n  // Doing this for performance\n  let lcdEnabledStatus: boolean = isLcdEnabled();\n\n  setLcdStatus(lcdEnabledStatus);\n\n  if(lcdEnabledStatus) {\n\n    Graphics.scanlineCycleCounter += numberOfCycles;\n\n    if (Graphics.scanlineCycleCounter >= Graphics.MAX_CYCLES_PER_SCANLINE()) {\n\n      // Reset the scanlineCycleCounter\n      // Don't set to zero to catch extra cycles\n      Graphics.scanlineCycleCounter -= Graphics.MAX_CYCLES_PER_SCANLINE();\n\n      // Move to next scanline\n      let scanlineRegister: u8 = eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationScanlineRegister);\n\n      // Check if we've reached the last scanline\n      if(scanlineRegister === 144) {\n        // Draw the scanline\n        if (!Config.graphicsDisableScanlineRendering) {\n          _drawScanline(scanlineRegister);\n        } else {\n          _renderEntireFrame();\n        }\n        // Store the frame to be rendered\n        storeFrameToBeRendered();\n        // Request a VBlank interrupt\n        requestVBlankInterrupt();\n      } else if (scanlineRegister < 144) {\n        // Draw the scanline\n        if (!Config.graphicsDisableScanlineRendering) {\n          _drawScanline(scanlineRegister);\n        }\n        \n        // Update the Hblank DMA, will return if not active\n        updateHblankHdma();\n      }\n\n      // Store our scanline\n      if (scanlineRegister > 153) {\n        // Check if we overflowed scanlines\n        // if so, reset our scanline number\n        scanlineRegister = 0;\n      } else {\n        scanlineRegister += 1;\n      }\n      eightBitStoreIntoGBMemorySkipTraps(Graphics.memoryLocationScanlineRegister, scanlineRegister);\n    }\n  }\n}\n\n// TODO: Make this a _drawPixelOnScanline, as values can be updated while drawing a scanline\nfunction _drawScanline(scanlineRegister: u8): void {\n  // http://www.codeslinger.co.uk/pages/projects/gameboy/graphics.html\n  // Bit 7 - LCD Display Enable (0=Off, 1=On)\n  // Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)\n  // Bit 5 - Window Display Enable (0=Off, 1=On)\n  // Bit 4 - BG & Window Tile Data Select (0=8800-97FF, 1=8000-8FFF)\n  // Bit 3 - BG Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)\n  // Bit 2 - OBJ (Sprite) Size (0=8x8, 1=8x16)\n  // Bit 1 - OBJ (Sprite) Display Enable (0=Off, 1=On)\n  // Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)\n\n  // Get our lcd control, see above for usage\n  let lcdControl: u8 = eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationLcdControl);\n\n  // Get our seleted tile data memory location\n  let tileDataMemoryLocation = Graphics.memoryLocationTileDataSelectZeroStart;\n  if(checkBitOnByte(4, lcdControl)) {\n    tileDataMemoryLocation = Graphics.memoryLocationTileDataSelectOneStart;\n  }\n\n\n  // Check if the background is enabled\n  if (checkBitOnByte(0, lcdControl)) {\n\n    // Get our map memory location\n    let tileMapMemoryLocation = Graphics.memoryLocationTileMapSelectZeroStart;\n    if (checkBitOnByte(3, lcdControl)) {\n      tileMapMemoryLocation = Graphics.memoryLocationTileMapSelectOneStart;\n    }\n\n    // Finally, pass everything to draw the background\n    renderBackground(scanlineRegister, tileDataMemoryLocation, tileMapMemoryLocation);\n  }\n\n  // Check if the window is enabled, and we are currently\n  // Drawing lines on the window\n  if(checkBitOnByte(5, lcdControl)) {\n\n    // Get our map memory location\n    let tileMapMemoryLocation = Graphics.memoryLocationTileMapSelectZeroStart;\n    if (checkBitOnByte(6, lcdControl)) {\n      tileMapMemoryLocation = Graphics.memoryLocationTileMapSelectOneStart;\n    }\n\n    // Finally, pass everything to draw the background\n    renderWindow(scanlineRegister, tileDataMemoryLocation, tileMapMemoryLocation);\n  }\n\n  if (checkBitOnByte(1, lcdControl)) {\n    // Sprites are enabled, render them!\n    renderSprites(scanlineRegister, checkBitOnByte(2, lcdControl));\n  }\n}\n\n// Function to render everything for a frame at once\n// This is to improve performance\n// See above for comments on how things are donw\nfunction _renderEntireFrame(): void {\n  // Scanline needs to be in sync while we draw, thus, we can't shortcut anymore than here\n  for(let i: u8 = 0; i <= 144; i++) {\n    _drawScanline(i);\n  }\n}\n","import {\n  Cpu\n} from '../cpu/index';\nimport {\n  eightBitStoreIntoGBMemorySkipTraps\n} from '../memory/store';\nimport {\n  eightBitLoadFromGBMemorySkipTraps\n} from '../memory/load';\nimport {\n  requestJoypadInterrupt\n} from '../interrupts/index';\nimport {\n  checkBitOnByte,\n  setBitOnByte,\n  resetBitOnByte\n} from '../helpers/index';\n\n// http://www.codeslinger.co.uk/pages/projects/gameboy/joypad.html\n// Joypad Register\n// Taken from pandocs\n// Bit 7 - Not used\n// Bit 6 - Not used\n// Bit 5 - P15 Select Button Keys (0=Select)\n// Bit 4 - P14 Select Direction Keys (0=Select)\n// Bit 3 - P13 Input Down or Start (0=Pressed) (Read Only)\n// Bit 2 - P12 Input Up or Select (0=Pressed) (Read Only)\n// Bit 1 - P11 Input Left or Button B (0=Pressed) (Read Only)\n// Bit 0 - P10 Input Right or Button A (0=Pressed) (Read Only)\n\n// Button Ids will be the following:\n// UP - 0\n// RIGHT - 1\n// DOWN - 2\n// LEFT - 3\n// A - 4\n// B - 5\n// SELECT - 6\n// START - 7\n\nexport class Joypad {\n  static up: boolean = false;\n  static down: boolean = false;\n  static left: boolean = false;\n  static right: boolean = false;\n  static a: boolean = false;\n  static b: boolean = false;\n  static select: boolean = false;\n  static start: boolean = false;\n\n  static readonly memoryLocationJoypadRegister: u16 = 0xFF00;\n\n  // Save States\n  // Not doing anything for Joypad for now\n\n  static readonly saveStateSlot: u16 = 3;\n\n  // Function to save the state of the class\n  static saveState(): void {\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n  }\n}\n\nexport function getJoypadState(): u8 {\n\n  // Get the joypad register\n  let joypadRegister: u8 = eightBitLoadFromGBMemorySkipTraps(Joypad.memoryLocationJoypadRegister);\n\n  // Flip all the bits\n  joypadRegister = joypadRegister ^ 0xFF;\n\n  // Check the button type buttons\n  if(!checkBitOnByte(4, joypadRegister)) {\n\n    // Set the top 4 bits to on\n    joypadRegister = joypadRegister | 0xF0;\n\n    // A\n    if (Joypad.a) {\n      joypadRegister = resetBitOnByte(0, joypadRegister);\n    } else {\n      joypadRegister = setBitOnByte(0, joypadRegister);\n    }\n\n    // B\n    if (Joypad.b) {\n      joypadRegister = resetBitOnByte(1, joypadRegister);\n    } else {\n      joypadRegister = setBitOnByte(1, joypadRegister);\n    }\n\n    // Select\n    if (Joypad.select) {\n      joypadRegister = resetBitOnByte(2, joypadRegister);\n    } else {\n      joypadRegister = setBitOnByte(2, joypadRegister);\n    }\n\n    // Start\n    if (Joypad.start) {\n      joypadRegister = resetBitOnByte(3, joypadRegister);\n    } else {\n      joypadRegister = setBitOnByte(3, joypadRegister);\n    }\n  } else if (!checkBitOnByte(5, joypadRegister)) {\n    // D-pad buttons\n\n    // Set the top 4 bits to on\n    joypadRegister = joypadRegister | 0xF0;\n\n    // Up\n    if (Joypad.up) {\n      joypadRegister = resetBitOnByte(2, joypadRegister);\n    } else {\n      joypadRegister = setBitOnByte(2, joypadRegister);\n    }\n\n    // Right\n    if (Joypad.right) {\n      joypadRegister = resetBitOnByte(0, joypadRegister);\n    } else {\n      joypadRegister = setBitOnByte(0, joypadRegister);\n    }\n\n    // Down\n    if (Joypad.down) {\n      joypadRegister = resetBitOnByte(3, joypadRegister);\n    } else {\n      joypadRegister = setBitOnByte(3, joypadRegister);\n    }\n\n    // Left\n    if (Joypad.left) {\n      joypadRegister = resetBitOnByte(1, joypadRegister);\n    } else {\n      joypadRegister = setBitOnByte(1, joypadRegister);\n    }\n  }\n\n  return joypadRegister;\n}\n\nexport function setJoypadState(up: i8, right: i8, down: i8, left: i8, a: i8, b: i8, select: i8, start: i8): void {\n\n  if (up > 0) {\n    _pressJoypadButton(0);\n  } else {\n    _releaseJoypadButton(0);\n  }\n\n  if (right > 0) {\n    _pressJoypadButton(1);\n  } else {\n    _releaseJoypadButton(1);\n  }\n\n  if (down > 0) {\n    _pressJoypadButton(2);\n  } else {\n    _releaseJoypadButton(2);\n  }\n\n  if (left > 0) {\n    _pressJoypadButton(3);\n  } else {\n    _releaseJoypadButton(3);\n  }\n\n  if (a > 0) {\n    _pressJoypadButton(4);\n  } else {\n    _releaseJoypadButton(4);\n  }\n\n  if (b > 0) {\n    _pressJoypadButton(5);\n  } else {\n    _releaseJoypadButton(5);\n  }\n\n  if (select > 0) {\n    _pressJoypadButton(6);\n  } else {\n    _releaseJoypadButton(6);\n  }\n\n  if (start > 0) {\n    _pressJoypadButton(7);\n  } else {\n    _releaseJoypadButton(7);\n  }\n}\n\nfunction _pressJoypadButton(buttonId: u8): void {\n\n  // Un stop the CPU\n  Cpu.isStopped = false;\n\n  // Check if the button state changed from not pressed\n  let isButtonStateChanging: boolean = false;\n  if(!_getJoypadButtonStateFromButtonId(buttonId)) {\n    isButtonStateChanging = true;\n  }\n\n  // Set our joypad state\n  _setJoypadButtonStateFromButtonId(buttonId, true);\n\n  // If the button state is changing, check for an interrupt\n  if (isButtonStateChanging) {\n    // Determine if it is a button or a dpad button\n    let isDpadTypeButton = false;\n    if (buttonId <= 3) {\n      isDpadTypeButton = true;\n    }\n\n    // Determine if we should request an interrupt\n    let joypadRegister: u8 = eightBitLoadFromGBMemorySkipTraps(Joypad.memoryLocationJoypadRegister);\n    let shouldRequestInterrupt = false;\n\n    // Check if the game is looking for a dpad type button press\n    if(checkBitOnByte(4, joypadRegister) && isDpadTypeButton) {\n      shouldRequestInterrupt = true;\n    }\n\n    // Check if the game is looking for a button type button press\n    if(checkBitOnByte(5, joypadRegister) && !isDpadTypeButton) {\n      shouldRequestInterrupt = true;\n    }\n\n    // Finally, request the interrupt, if the button state actually changed\n    if (shouldRequestInterrupt) {\n      requestJoypadInterrupt();\n    }\n  }\n}\n\nfunction _releaseJoypadButton(buttonId: u8): void {\n  // Set our joypad state\n  _setJoypadButtonStateFromButtonId(buttonId, false);\n}\n\nfunction _getBitNumberForButtonId(buttonId: u8): u8 {\n  if (buttonId === 1 || buttonId === 4) {\n    return 0;\n  } else if (buttonId === 3 || buttonId === 5) {\n    return 1;\n  } else if (buttonId === 0 || buttonId === 6) {\n    return 2;\n  } else if (buttonId === 2 || buttonId === 7) {\n    return 3;\n  }\n\n  return 0;\n}\n\nfunction _getJoypadButtonStateFromButtonId(buttonId: u8): boolean {\n  switch(buttonId) {\n    case 0:\n      return Joypad.up;\n    case 1:\n      return Joypad.right;\n    case 2:\n      return Joypad.down;\n    case 3:\n      return Joypad.left;\n    case 4:\n      return Joypad.a;\n    case 5:\n      return Joypad.b;\n    case 6:\n      return Joypad.select;\n    case 7:\n      return Joypad.start;\n    default:\n      return false;\n  }\n}\n\nfunction _setJoypadButtonStateFromButtonId(buttonId: u8, isPressed: boolean):  void {\n  switch(buttonId) {\n    case 0:\n      Joypad.up = isPressed;\n      break;\n    case 1:\n      Joypad.right = isPressed;\n      break;\n    case 2:\n      Joypad.down = isPressed;\n      break;\n    case 3:\n      Joypad.left = isPressed;\n      break;\n    case 4:\n      Joypad.a = isPressed;\n      break;\n    case 5:\n      Joypad.b = isPressed;\n      break;\n    case 6:\n      Joypad.select = isPressed;\n      break;\n    case 7:\n      Joypad.start = isPressed;\n      break;\n  }\n}\n","// Functions to update Length Counters on Channels\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Length_Counter\n\nimport {\n    Channel1\n} from './channel1';\nimport {\n    Channel2\n} from './channel2';\nimport {\n    Channel3\n} from './channel3';\nimport {\n    Channel4\n} from './channel4';\nimport {\n  getRegister1OfChannel,\n  getRegister4OfChannel\n} from './registers';\nimport {\n  checkBitOnByte,\n  hexLog\n} from '../helpers/index';\n\nexport function setChannelLengthCounter(channelNumber: i32): void {\n\n  let lengthLoad = getRegister1OfChannel(channelNumber);\n\n  // Clear the top 2 bits\n  lengthLoad = (lengthLoad & 0x3F);\n  // Channel length is determined by 64 (or 256 if channel 3), - the length load\n  // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Registers\n  let length: u8 = 64;\n  let result: u8 = 0;\n  if (channelNumber === 3) {\n    length = 255;\n    // Supposed to be 256, so subtracting 255 and then adding 1 if that makes sense\n    result = length - lengthLoad;\n    result += 1;\n  } else {\n    result = length - lengthLoad;\n  }\n\n  // Set the Channel Length Counter\n  switch(channelNumber) {\n    case Channel1.channelNumber:\n      Channel1.lengthCounter = result;\n      break;\n    case Channel2.channelNumber:\n      Channel2.lengthCounter = result;\n      break;\n    case Channel3.channelNumber:\n      Channel3.lengthCounter = result;\n      break;\n    case Channel4.channelNumber:\n      Channel4.lengthCounter = result;\n      break;\n  }\n}\n\nexport function isChannelLengthEnabled(channelNumber: i32): boolean {\n  return checkBitOnByte(6, getRegister4OfChannel(channelNumber))\n}\n","// Functions involved in R/W of sound registers\n// Information of bits on every register can be found at: https://gist.github.com/drhelius/3652407\n// Passing channel number to make things simpler than passing around memory addresses, to avoid bugs in choosing the wrong address\n\nimport {\n  Sound,\n  SoundAccumulator\n} from './sound';\nimport {\n    Channel1\n} from './channel1';\nimport {\n    Channel2\n} from './channel2';\nimport {\n    Channel3\n} from './channel3';\nimport {\n    Channel4\n} from './channel4';\nimport {\n  setChannelLengthCounter\n} from '../sound/length';\nimport {\n  eightBitLoadFromGBMemorySkipTraps,\n  eightBitStoreIntoGBMemorySkipTraps\n} from '../memory/index';\nimport {\n  checkBitOnByte,\n  setBitOnByte,\n  resetBitOnByte,\n  hexLog\n} from '../helpers/index';\n\n// Function to check and handle writes to sound registers\nexport function handledWriteToSoundRegister(offset: u16, value: u16): boolean {\n\n  // Get our registerNR52\n  let registerNR52: u8 = eightBitLoadFromGBMemorySkipTraps(Sound.memoryLocationNR52);\n\n  if(offset !== Sound.memoryLocationNR52 && !checkBitOnByte(7, registerNR52)) {\n    // Block all writes to any sound register EXCEPT NR52!\n    // This is under the assumption that the check for\n    // offset >= 0xFF10 && offset <= 0xFF26\n    // is done in writeTraps.ts (which it is)\n    // NOTE: Except on DMG, length can still be written (whatever that means)\n    return true;\n  }\n\n  switch(offset) {\n    // Set length counter on channels\n    case Channel1.memoryLocationNRx1:\n      eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n      setChannelLengthCounter(Channel1.channelNumber);\n      return true;\n    case Channel2.memoryLocationNRx1:\n      eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n      setChannelLengthCounter(Channel2.channelNumber);\n      return true;\n    case Channel3.memoryLocationNRx1:\n      eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n      setChannelLengthCounter(Channel3.channelNumber);\n      return true;\n    case Channel4.memoryLocationNRx1:\n      eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n      setChannelLengthCounter(Channel4.channelNumber);\n      return true;\n  }\n\n  // Check if channel 3's volume code was written too\n  // This is handcy to know for accumulation of samples\n  if (offset === Channel3.memoryLocationNRx2) {\n    Channel3.volumeCodeChanged = true;\n  }\n\n  // Check our NRx4 registers to trap our trigger bits\n  if(offset === Channel1.memoryLocationNRx4 && checkBitOnByte(7, <u8>value)) {\n    // Write the value skipping traps, and then trigger\n    eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n    Channel1.trigger();\n    return true;\n  } else if(offset === Channel2.memoryLocationNRx4 && checkBitOnByte(7, <u8>value)) {\n    eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n    Channel2.trigger();\n    return true;\n  } else if(offset === Channel3.memoryLocationNRx4 && checkBitOnByte(7, <u8>value)) {\n    eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n    Channel3.trigger();\n    return true;\n  } else if(offset === Channel4.memoryLocationNRx4 && checkBitOnByte(7, <u8>value)) {\n    eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n    Channel4.trigger();\n    return true;\n  }\n\n  // Tell the sound accumulator if volumes changes\n  if(offset === Sound.memoryLocationNR50) {\n    SoundAccumulator.mixerVolumeChanged = true;\n  }\n\n  // Tell the sound accumulator if the Mixer Enabled changes\n  if(offset === Sound.memoryLocationNR50) {\n    SoundAccumulator.mixerEnabledChanged = true;\n  }\n\n  // Write 0 to the 7th bit of NR52, resets all sound registers, and stops them from receiving writes\n  if(offset === Sound.memoryLocationNR52) {\n\n    // Reset all registers except NR52\n    if(!checkBitOnByte(7, <u8>value)) {\n      for (let i: u16 = 0xFF10; i < 0xFF26; i++) {\n        eightBitStoreIntoGBMemorySkipTraps(i, 0x00);\n      }\n    }\n\n    // Write our final value to NR52\n    eightBitStoreIntoGBMemorySkipTraps(offset, <u8>value);\n\n    return true;\n  }\n\n  // We did not handle the write, return false\n  return false;\n}\n\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Registers\nexport function handleReadToSoundRegister(offset: u16): i32  {\n\n  // TODO: OR All Registers\n\n  // This will fix bugs in orcale of ages :)\n  if (offset === Sound.memoryLocationNR52) {\n    // Get our registerNR52\n    let registerNR52: u8 = eightBitLoadFromGBMemorySkipTraps(Sound.memoryLocationNR52);\n\n    // Knock off lower 7 bits\n    registerNR52 = (registerNR52 & 0x80);\n\n    // Set our lower 4 bits to our channel isEnabled statuses\n    if(Channel1.isEnabled) {\n      setBitOnByte(0, registerNR52);\n    } else {\n      resetBitOnByte(0, registerNR52);\n    }\n\n    if(Channel2.isEnabled) {\n      setBitOnByte(1, registerNR52);\n    } else {\n      resetBitOnByte(1, registerNR52);\n    }\n\n    if(Channel3.isEnabled) {\n      setBitOnByte(2, registerNR52);\n    } else {\n      resetBitOnByte(2, registerNR52);\n    }\n\n    if(Channel4.isEnabled) {\n      setBitOnByte(3, registerNR52);\n    } else {\n      resetBitOnByte(3, registerNR52);\n    }\n\n    // Or from the table\n    registerNR52 = (registerNR52 | 0x70);\n\n    return registerNR52;\n  }\n\n  return -1;\n}\n\nexport function getChannelStartingVolume(channelNumber: i32): u8 {\n  // Simply need to get the top 4 bits of register 2\n  let startingVolume: u8 = getRegister2OfChannel(channelNumber);\n  startingVolume = (startingVolume >> 4);\n  return (startingVolume & 0x0F);\n}\n\nexport function isChannelDacEnabled(channelNumber: i32): boolean {\n  // DAC power is controlled by the upper 5 bits of NRx2 (top bit of NR30 for wave channel).\n  // If these bits are not all clear, the DAC is on, otherwise it's off and outputs 0 volts.\n  if(channelNumber !== 3) {\n    let register2 = getRegister2OfChannel(channelNumber);\n    // Clear bottom 3 bits\n    let dacStatus = (register2 & 0xF8);\n    if (dacStatus > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    let register3 = eightBitLoadFromGBMemorySkipTraps(Channel3.memoryLocationNRx0);\n    return checkBitOnByte(7, register3);\n  }\n}\n\nexport function isChannelEnabledOnLeftOutput(channelNumber: i32): boolean {\n  let registerNR51: u8 = eightBitLoadFromGBMemorySkipTraps(Sound.memoryLocationNR51);\n  // Left channel in the higher bits\n  let bitNumberOfChannel: u8 = (<u8>channelNumber - 1) + 4;\n  return checkBitOnByte(bitNumberOfChannel, registerNR51);\n}\n\nexport function isChannelEnabledOnRightOutput(channelNumber: i32): boolean {\n  let registerNR51: u8 = eightBitLoadFromGBMemorySkipTraps(Sound.memoryLocationNR51);\n  // Left channel in the higher bits\n  let bitNumberOfChannel: u8 = (<u8>channelNumber - 1);\n  return checkBitOnByte(bitNumberOfChannel, registerNR51);\n}\n\n// Function to get 1st register of a channel\n// Contains Duty and Length\nexport function getRegister1OfChannel(channelNumber: i32): u8 {\n\n  switch(channelNumber) {\n    case Channel1.channelNumber:\n      return eightBitLoadFromGBMemorySkipTraps(Channel1.memoryLocationNRx1);\n    case Channel2.channelNumber:\n      return eightBitLoadFromGBMemorySkipTraps(Channel2.memoryLocationNRx1);\n    case Channel3.channelNumber:\n      return eightBitLoadFromGBMemorySkipTraps(Channel3.memoryLocationNRx1);\n    default:\n      return eightBitLoadFromGBMemorySkipTraps(Channel4.memoryLocationNRx1);\n  }\n}\n\n// Function to get 2nd register of a channel\n// Contains Envelope Information\nexport function getRegister2OfChannel(channelNumber: i32): u8 {\n\n  switch(channelNumber) {\n    case Channel1.channelNumber:\n      return eightBitLoadFromGBMemorySkipTraps(Channel1.memoryLocationNRx2);\n    case Channel2.channelNumber:\n      return eightBitLoadFromGBMemorySkipTraps(Channel2.memoryLocationNRx2);\n    case Channel3.channelNumber:\n      return eightBitLoadFromGBMemorySkipTraps(Channel3.memoryLocationNRx2);\n    default:\n      return eightBitLoadFromGBMemorySkipTraps(Channel4.memoryLocationNRx2);\n  }\n}\n\n// Function to get 3rd register of a channel\n// Contains Fequency LSB (lower 8 bits)\nexport function getRegister3OfChannel(channelNumber: i32): u8 {\n\n  switch(channelNumber) {\n    case Channel1.channelNumber:\n      return eightBitLoadFromGBMemorySkipTraps(Channel1.memoryLocationNRx3);\n    case Channel2.channelNumber:\n      return eightBitLoadFromGBMemorySkipTraps(Channel2.memoryLocationNRx3);\n    case Channel3.channelNumber:\n      return eightBitLoadFromGBMemorySkipTraps(Channel3.memoryLocationNRx3);\n    default:\n      return eightBitLoadFromGBMemorySkipTraps(Channel4.memoryLocationNRx3);\n  }\n}\n\nexport function setRegister3OfChannel(channelNumber: i32, value: u8): void {\n\n  switch(channelNumber) {\n    case Channel1.channelNumber:\n      eightBitStoreIntoGBMemorySkipTraps(Channel1.memoryLocationNRx3, value);\n      break;\n    case Channel2.channelNumber:\n      eightBitStoreIntoGBMemorySkipTraps(Channel2.memoryLocationNRx3, value);\n      break;\n    case Channel3.channelNumber:\n      eightBitStoreIntoGBMemorySkipTraps(Channel3.memoryLocationNRx3, value);\n      break;\n    default:\n      eightBitStoreIntoGBMemorySkipTraps(Channel4.memoryLocationNRx3, value);\n      break;\n  }\n}\n\n// Function to get 4th register of a channel\n// Contains Fequency MSB (higher 3 bits), and Length Information\nexport function getRegister4OfChannel(channelNumber: i32): u8 {\n\n  switch(channelNumber) {\n    case Channel1.channelNumber:\n      return eightBitLoadFromGBMemorySkipTraps(Channel1.memoryLocationNRx4);\n    case Channel2.channelNumber:\n      return eightBitLoadFromGBMemorySkipTraps(Channel2.memoryLocationNRx4);\n    case Channel3.channelNumber:\n      return eightBitLoadFromGBMemorySkipTraps(Channel3.memoryLocationNRx4);\n    default:\n      return eightBitLoadFromGBMemorySkipTraps(Channel4.memoryLocationNRx4);\n  }\n}\n\nexport function setRegister4OfChannel(channelNumber: i32, value: u8): void {\n\n  switch(channelNumber) {\n    case Channel1.channelNumber:\n      eightBitStoreIntoGBMemorySkipTraps(Channel1.memoryLocationNRx4, value);\n      break;\n    case Channel2.channelNumber:\n      eightBitStoreIntoGBMemorySkipTraps(Channel2.memoryLocationNRx4, value);\n      break;\n    case Channel3.channelNumber:\n      eightBitStoreIntoGBMemorySkipTraps(Channel3.memoryLocationNRx4, value);\n      break;\n    default:\n      eightBitStoreIntoGBMemorySkipTraps(Channel4.memoryLocationNRx4, value);\n      break;\n  }\n}\n","// Functions to update frequency on channels\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Square_Wave\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Noise_Channel\n\nimport {\n  getRegister3OfChannel,\n  getRegister4OfChannel,\n  setRegister3OfChannel,\n  setRegister4OfChannel\n} from './registers';\nimport {\n  checkBitOnByte\n} from '../helpers/index';\n\nexport function getChannelFrequency(channelNumber: i32): u16 {\n  // Need to get the 3rd and 4th register.\n  // 3rd register is the bottom 8 bits.\n  // 4th register contains bits 9-11.\n  let frequencyHighBits: u16 = getRegister4OfChannel(channelNumber) & 0x07;\n  frequencyHighBits = (frequencyHighBits << 8);\n  let frequencyLowBits: u16 = getRegister3OfChannel(channelNumber);\n  let frequency = frequencyHighBits | frequencyLowBits;\n  return frequency;\n}\n\nexport function setChannelFrequency(channelNumber: i32, frequency: u16): void {\n  // Get the high and low bits\n  let passedFrequencyHighBits: u8 = <u8>(frequency >> 8);\n  let passedFrequencyLowBits: u8 = <u8>(frequency & 0xFF);\n\n  // Get the new register 4\n  let register4: u8 = getRegister4OfChannel(channelNumber);\n  // Knock off lower 3 bits, and Or on our high bits\n  let newRegister4: u8 = (register4 & 0xF8);\n  newRegister4 = newRegister4 | passedFrequencyHighBits;\n\n  // Finally set the registers\n  setRegister3OfChannel(channelNumber, passedFrequencyLowBits);\n  setRegister4OfChannel(channelNumber, newRegister4);\n}\n","// Functions to update envelopes on Channels\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Volume_Envelope\n\nimport {\n  getRegister2OfChannel\n} from './registers';\nimport {\n  checkBitOnByte\n} from '../helpers/index';\n\nexport function getChannelEnvelopePeriod(channelNumber: i32): u8 {\n  // Get the bottom 3 bits for the period\n  return getRegister2OfChannel(channelNumber) & 0x07;\n}\n\nexport function getChannelEnvelopeAddMode(channelNumber: i32): boolean {\n  return checkBitOnByte(3, getRegister2OfChannel(channelNumber))\n}\n","// Functions to help with Handling Duty on Square Channels\n// http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Square_Wave\n\nimport {\n  getRegister1OfChannel\n} from './registers';\nimport {\n  checkBitOnByte\n} from '../helpers/index';\n\nexport function getChannelDuty(channelNumber: i32): u8 {\n  let duty = getRegister1OfChannel(channelNumber);\n  duty = (duty >> 6);\n  return (duty & 0x03);\n}\n\n// Since there are no 2d arrays, we will use a byte to represent duty cycles (wave form from percentages)\nexport function isDutyCycleClockPositiveOrNegativeForWaveform(channelNumber: i32, waveFormPositionOnDuty: u8): boolean {\n  // Get our current Duty\n  let duty: u8 = getChannelDuty(channelNumber);\n\n  // Get our Wave Form According to the Duty\n  // Default to a duty of 1\n  // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Square_Wave\n  switch(getChannelDuty(channelNumber)) {\n    case 0x01:\n      // 1000 0001\n      return checkBitOnByte(waveFormPositionOnDuty, 0x81);\n    case 0x02:\n      // 1000 0111\n      return checkBitOnByte(waveFormPositionOnDuty, 0x87);\n    case 0x03:\n      // 0111 1110\n      return checkBitOnByte(waveFormPositionOnDuty, 0x7E);\n    default:\n      // 0000 0001\n      return checkBitOnByte(waveFormPositionOnDuty, 0x01);\n  }\n}\n","import {\n  Memory\n} from './memory';\nimport {\n  Graphics,\n  batchProcessGraphics\n} from '../graphics/graphics';\nimport {\n  Palette,\n  writeColorPaletteToMemory\n} from '../graphics/index';\nimport {\n  batchProcessAudio,\n  handledWriteToSoundRegister\n} from '../sound/index';\nimport {\n  Timers,\n  batchProcessTimers,\n  handleTIMCWrite\n} from '../timers/index'\nimport {\n  handleBanking\n} from './banking';\nimport {\n  eightBitStoreIntoGBMemorySkipTraps,\n  sixteenBitStoreIntoGBMemorySkipTraps\n} from './store';\nimport {\n  eightBitLoadFromGBMemory,\n  eightBitLoadFromGBMemorySkipTraps,\n  sixteenBitLoadFromGBMemory\n} from './load';\nimport {\n  startDmaTransfer,\n  startHdmaTransfer\n} from './dma';\nimport {\n  checkBitOnByte,\n  hexLog\n} from '../helpers/index';\n\n// Internal function to trap any modify data trying to be written to Gameboy memory\n// Follows the Gameboy memory map\nexport function checkWriteTraps(offset: u16, value: u16, isEightBitStore: boolean): boolean {\n\n  // Cache globals used multiple times for performance\n  let videoRamLocation: u16 = Memory.videoRamLocation;\n  let spriteInformationTableLocation: u16 = Memory.spriteInformationTableLocation;\n\n  // Handle banking\n  if(offset < videoRamLocation) {\n\n    handleBanking(offset, value);\n    return false;\n  }\n\n  // Check the graphics mode to see if we can write to VRAM\n  // http://gbdev.gg8.se/wiki/articles/Video_Display#Accessing_VRAM_and_OAM\n  if(offset >= videoRamLocation && offset < Memory.cartridgeRamLocation) {\n    // Can only read/write from VRAM During Modes 0 - 2\n    // See graphics/lcd.ts\n    // TODO: This can do more harm than good in a beta emulator,\n    // requires precise timing disabling for now\n    // if (Graphics.currentLcdMode > 2) {\n    //   return false;\n    // }\n\n    // Not batch processing here for performance\n    // batchProcessGraphics();\n\n    // Allow the original write, and return since we dont need to look anymore\n    return true;\n  }\n\n  // Be sure to copy everything in EchoRam to Work Ram\n  // Codeslinger: The ECHO memory region (0xE000-0xFDFF) is quite different because any data written here is also written in the equivelent ram memory region 0xC000-0xDDFF.\n  // Hence why it is called echo\n  if(offset >= Memory.echoRamLocation && offset < spriteInformationTableLocation) {\n    let wramOffset: u16 = offset - 0x2000;\n    if(isEightBitStore) {\n      eightBitStoreIntoGBMemorySkipTraps(wramOffset, <u8>value);\n    } else {\n      sixteenBitStoreIntoGBMemorySkipTraps(wramOffset, value);\n    }\n\n    // Allow the original write, and return since we dont need to look anymore\n    return true;\n  }\n\n  // Also check for individal writes\n  // Can only read/write from OAM During Modes 0 - 1\n  // See graphics/lcd.ts\n  if(offset >= spriteInformationTableLocation && offset <= Memory.spriteInformationTableLocationEnd) {\n    // Can only read/write from OAM During Mode 2\n    // See graphics/lcd.ts\n    if (Graphics.currentLcdMode < 2) {\n      return false;\n    }\n    // Not batch processing here for performance\n    // batchProcessGraphics();\n\n    // Allow the original write, and return since we dont need to look anymore\n    return true;\n  }\n\n  if(offset >= Memory.unusableMemoryLocation && offset <= Memory.unusableMemoryEndLocation) {\n    return false;\n  }\n\n  // Timers\n  if (offset >= Timers.memoryLocationDividerRegister && offset <= Timers.memoryLocationTIMC) {\n\n    // Batch Process\n    batchProcessTimers();\n\n    // Trap our divider register from our timers\n    if(offset === Timers.memoryLocationDividerRegister) {\n      eightBitStoreIntoGBMemorySkipTraps(offset, 0);\n      return false;\n    }\n\n    // Trap our TIMC writes\n    if(offset === Timers.memoryLocationTIMC) {\n      handleTIMCWrite(<u8>value);\n      return true;\n    }\n\n    // Allow the original Write\n    return true;\n  }\n\n  // Sound\n  // http://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware#Registers\n  if(offset >= 0xFF10 && offset <= 0xFF26) {\n    batchProcessAudio();\n    if(handledWriteToSoundRegister(offset, value)) {\n      return false;\n    }\n  }\n  // FF27 - FF2F not used\n  // Final Wave Table for Channel 3\n  if(offset >= 0xFF30 && offset <= 0xFF3F) {\n    batchProcessAudio();\n  }\n\n  // Other Memory effects fomr read/write to GraphicsGraphics\n  if (offset >= Graphics.memoryLocationLcdControl && offset <= Graphics.memoryLocationWindowX) {\n\n    // Not batch processing here for performance\n    // batchProcessGraphics();\n\n    // reset the current scanline if the game tries to write to it\n    if (offset === Graphics.memoryLocationScanlineRegister) {\n      eightBitStoreIntoGBMemorySkipTraps(offset, 0);\n      return false;\n    }\n\n    // Do the direct memory access transfer for spriteInformationTable\n    // Check the graphics mode to see if we can write to VRAM\n    // http://gbdev.gg8.se/wiki/articles/Video_Display#Accessing_VRAM_and_OAM\n    if (offset === Graphics.memoryLocationDmaTransfer) {\n      // otherwise, perform a DMA transfer\n      // And allow the original write\n      startDmaTransfer(<u8>value);\n      return true;\n    }\n\n\n    // Allow the original write, and return since we dont need to look anymore\n    return true;\n  }\n\n  // Do an HDMA\n  if(offset === Memory.memoryLocationHdmaTrigger) {\n    startHdmaTransfer(<u8>value);\n    return false;\n  }\n\n  // Don't allow banking if we are doing an Hblank HDM transfer\n  // https://gist.github.com/drhelius/3394856\n  if(offset === Memory.memoryLocationGBCWRAMBank || offset === Memory.memoryLocationGBCVRAMBAnk) {\n    if (Memory.isHblankHdmaActive) {\n      if((Memory.hblankHdmaSource >= 0x4000 && Memory.hblankHdmaSource <= 0x7FFF) ||\n        (Memory.hblankHdmaSource >= 0xD000 && Memory.hblankHdmaSource <= 0xDFFF)) {\n          return false;\n        }\n    }\n  }\n\n  // Handle GBC Pallete Write\n  if (offset >= Palette.memoryLocationBackgroundPaletteIndex && offset <= Palette.memoryLocationSpritePaletteData) {\n    // Incremeenting the palette handled by the write\n    writeColorPaletteToMemory(offset, value);\n    return true;\n  }\n\n  // Allow the original write\n  return true;\n}\n","import {\n  Cpu\n} from '../cpu/index';\nimport {\n  eightBitLoadFromGBMemorySkipTraps,\n  eightBitStoreIntoGBMemorySkipTraps,\n  getSaveStateMemoryOffset,\n  loadBooleanDirectlyFromWasmMemory,\n  storeBooleanDirectlyToWasmMemory\n} from '../memory/index';\nimport {\n  requestTimerInterrupt\n} from '../interrupts/index';\nimport {\n  checkBitOnByte,\n  hexLog\n} from '../helpers/index';\n\nexport class Timers {\n\n  // Current cycles\n  // This will be used for batch processing\n  static currentCycles: i32 = 0;\n\n  // Number of cycles to run in each batch process\n  static batchProcessCycles(): i32 {\n  if (Cpu.GBCDoubleSpeed) {\n    return 140448;\n  }\n\n    return 255;\n  }\n\n  static readonly memoryLocationTIMA: u16 = 0xFF05; // Timer Modulator\n  static readonly memoryLocationTMA: u16 = 0xFF06; // Timer Counter (Actual Time Value)\n  static readonly memoryLocationTIMC: u16 = 0xFF07; // Timer Controller (A.K.A TAC)\n  static readonly memoryLocationDividerRegister: u16 = 0xFF04; // DividerRegister likes to count\n\n  // Check if the timer is currently enabled\n  static isEnabled: boolean = false;\n\n  // Cycle counter. This is used to determine if we should increment the REAL timer\n  // I know this is weird, but it's all to make sure the emulation is in sync :p\n  static cycleCounter: i32 = 0x00;\n  static currentMaxCycleCount: i32 = 256;\n\n  // Another timer, that doesn't fire intterupts, but jsut counts to 255, and back to zero :p\n  static dividerRegisterCycleCounter: i32 = 0x00;\n  static dividerRegisterMaxCycleCount(): i32 {\n    if (Cpu.GBCDoubleSpeed) {\n      return 140448;\n    }\n\n    return 255;\n  }\n\n  // Save States\n\n  static readonly saveStateSlot: u16 = 5;\n\n  // Function to save the state of the class\n  // TODO: Save state for new properties on Timers\n  static saveState(): void {\n    store<i32>(getSaveStateMemoryOffset(0x00, Timers.saveStateSlot), Timers.cycleCounter);\n    store<i32>(getSaveStateMemoryOffset(0x04, Timers.saveStateSlot), Timers.currentMaxCycleCount);\n    store<i32>(getSaveStateMemoryOffset(0x08, Timers.saveStateSlot), Timers.dividerRegisterCycleCounter);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    Timers.cycleCounter = load<i32>(getSaveStateMemoryOffset(0x00, Timers.saveStateSlot));\n    Timers.currentMaxCycleCount = load<i32>(getSaveStateMemoryOffset(0x04, Timers.saveStateSlot));\n    Timers.dividerRegisterCycleCounter = load<i32>(getSaveStateMemoryOffset(0x08, Timers.saveStateSlot));\n  }\n}\n\n// Batch Process Timers\n// Only checked on writes\n// Function to batch process our Timers after we skipped so many cycles\nexport function batchProcessTimers(): void {\n\n  // Get our current batch process cycles\n  // This will depend on the least amount of cycles we need to update\n  // Something\n  let batchProcessCycles: i32 = Timers.batchProcessCycles();\n  if (Timers.isEnabled && Timers.currentMaxCycleCount < batchProcessCycles) {\n    batchProcessCycles = Timers.currentMaxCycleCount;\n  }\n\n  if (Timers.currentCycles < batchProcessCycles) {\n    return;\n  }\n\n  while (Timers.currentCycles >= batchProcessCycles) {\n    updateTimers(batchProcessCycles);\n    Timers.currentCycles = Timers.currentCycles - batchProcessCycles;\n  }\n}\n\nexport function updateTimers(numberOfCycles: i32): void {\n\n  _checkDividerRegister(numberOfCycles);\n\n  if(!Timers.isEnabled) {\n    return;\n  }\n\n  // Add our cycles our cycle counter\n  Timers.cycleCounter += numberOfCycles;\n\n  while (Timers.cycleCounter >= Timers.currentMaxCycleCount) {\n\n    // Update the actual timer counter\n    let tima: u8 = eightBitLoadFromGBMemorySkipTraps(Timers.memoryLocationTIMA);\n\n    // Reset our cycle counters\n    // Not setting to zero as we do not want to drop cycles\n    Timers.cycleCounter -= Timers.currentMaxCycleCount;\n\n    if(tima >= 255) {\n      // Store Timer Modulator inside of TIMA\n      eightBitStoreIntoGBMemorySkipTraps(Timers.memoryLocationTIMA, eightBitLoadFromGBMemorySkipTraps(Timers.memoryLocationTMA));\n\n      // Fire off timer interrupt\n      requestTimerInterrupt();\n    } else {\n      eightBitStoreIntoGBMemorySkipTraps(Timers.memoryLocationTIMA, tima + 1);\n    }\n  }\n}\n\n// Function called on write to TIMC\nexport function handleTIMCWrite(timc: u8): void {\n\n  // Set if the timer is enabled\n  Timers.isEnabled = checkBitOnByte(2, timc);\n\n  if(!Timers.isEnabled) {\n    return;\n  }\n\n  // Clear the top byte\n  timc = timc & 0x03;\n\n  // Returns value equivalent to\n  // Cpu.CLOCK_SPEED / timc frequency\n  // TIMC -> 16382\n  let cycleCount: i32 = 256;\n  if (Cpu.GBCDoubleSpeed) {\n    cycleCount = 512;\n  }\n  switch(timc) {\n    case 0x00:\n      // TIMC -> 4096\n      cycleCount = 1024;\n      if (Cpu.GBCDoubleSpeed) {\n        cycleCount = 2048;\n      }\n      break;\n    case 0x01:\n      // TIMC -> 262144\n      cycleCount = 16;\n      if (Cpu.GBCDoubleSpeed) {\n        cycleCount = 32;\n      }\n      break;\n    case 0x02:\n      // TIMC -> 65536\n      cycleCount = 64;\n      if (Cpu.GBCDoubleSpeed) {\n        cycleCount = 126;\n      }\n      break;\n  }\n\n  // Set our new current max, and reset the cycle counter\n  Timers.cycleCounter = 0;\n  Timers.currentMaxCycleCount = cycleCount;\n}\n\n// Function to update our divider register\nfunction _checkDividerRegister(numberOfCycles: i32): void {\n\n  // Every 256 clock cycles need to increment\n  Timers.dividerRegisterCycleCounter += numberOfCycles;\n\n  if(Timers.dividerRegisterCycleCounter >= Timers.dividerRegisterMaxCycleCount()) {\n\n    // Reset the cycle counter\n    // - 255 to catch any overflow with the cycles\n    Timers.dividerRegisterCycleCounter -= Timers.dividerRegisterMaxCycleCount();\n\n    let dividerRegister: u8 = eightBitLoadFromGBMemorySkipTraps(Timers.memoryLocationDividerRegister);\n    dividerRegister += 1;\n    eightBitStoreIntoGBMemorySkipTraps(Timers.memoryLocationDividerRegister, dividerRegister);\n  }\n}\n","import {\n  Cpu\n} from '../cpu/index';\nimport {\n  eightBitLoadFromGBMemorySkipTraps,\n  eightBitStoreIntoGBMemorySkipTraps,\n  sixteenBitStoreIntoGBMemorySkipTraps,\n  getSaveStateMemoryOffset,\n  loadBooleanDirectlyFromWasmMemory,\n  storeBooleanDirectlyToWasmMemory\n} from '../memory/index';\nimport {\n  setBitOnByte,\n  resetBitOnByte,\n  checkBitOnByte,\n  hexLog\n} from '../helpers/index';\n\nexport class Interrupts {\n  static readonly memoryLocationInterruptEnabled: u16 = 0xFFFF;\n  static readonly memoryLocationInterruptRequest: u16 = 0xFF0F; // A.K.A interrupt Flag (IF)\n\n  static masterInterruptSwitch: boolean = false;\n  // According to mooneye, interrupts are not handled until AFTER\n  // Next instruction\n  // https://github.com/Gekkio/mooneye-gb/blob/master/docs/accuracy.markdown\n  static masterInterruptSwitchDelay: boolean = false;\n\n  static readonly bitPositionVBlankInterrupt: u8 = 0;\n  static readonly bitPositionLcdInterrupt: u8 = 1;\n  static readonly bitPositionTimerInterrupt: u8 = 2;\n  static readonly bitPositionJoypadInterrupt: u8 = 4;\n\n  // Save States\n  static readonly saveStateSlot: u16 = 2;\n\n  // Function to save the state of the class\n  static saveState(): void {\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x00, Interrupts.saveStateSlot), Interrupts.masterInterruptSwitch);\n    storeBooleanDirectlyToWasmMemory(getSaveStateMemoryOffset(0x01, Interrupts.saveStateSlot), Interrupts.masterInterruptSwitchDelay);\n  }\n\n  // Function to load the save state from memory\n  static loadState(): void {\n    Interrupts.masterInterruptSwitch = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x00, Interrupts.saveStateSlot));\n    Interrupts.masterInterruptSwitchDelay = loadBooleanDirectlyFromWasmMemory(getSaveStateMemoryOffset(0x01, Interrupts.saveStateSlot));\n  }\n}\n\nexport function checkInterrupts(): i32 {\n\n  if(Interrupts.masterInterruptSwitch) {\n\n    // Boolean to track if interrupts were handled\n    // Interrupt handling requires 20 cycles\n    // https://github.com/Gekkio/mooneye-gb/blob/master/docs/accuracy.markdown#what-is-the-exact-timing-of-cpu-servicing-an-interrupt\n    let wasInterruptHandled: boolean = false;\n\n    let interruptRequest = eightBitLoadFromGBMemorySkipTraps(Interrupts.memoryLocationInterruptRequest);\n    let interruptEnabled = eightBitLoadFromGBMemorySkipTraps(Interrupts.memoryLocationInterruptEnabled);\n\n    if(interruptRequest > 0) {\n\n      // Check our interrupts\n      if (checkBitOnByte(Interrupts.bitPositionVBlankInterrupt, interruptRequest) &&\n        checkBitOnByte(Interrupts.bitPositionVBlankInterrupt, interruptEnabled)) {\n\n        _handleInterrupt(Interrupts.bitPositionVBlankInterrupt);\n        wasInterruptHandled = true;\n      } else if (checkBitOnByte(Interrupts.bitPositionLcdInterrupt, interruptRequest) &&\n        checkBitOnByte(Interrupts.bitPositionLcdInterrupt, interruptEnabled)) {\n          _handleInterrupt(Interrupts.bitPositionLcdInterrupt);\n          wasInterruptHandled = true;\n      } else if (checkBitOnByte(Interrupts.bitPositionTimerInterrupt, interruptRequest) &&\n        checkBitOnByte(Interrupts.bitPositionTimerInterrupt, interruptEnabled)) {\n\n          _handleInterrupt(Interrupts.bitPositionTimerInterrupt);\n          wasInterruptHandled = true;\n      } else if (checkBitOnByte(Interrupts.bitPositionJoypadInterrupt, interruptRequest) &&\n        checkBitOnByte(Interrupts.bitPositionJoypadInterrupt, interruptEnabled)) {\n\n          _handleInterrupt(Interrupts.bitPositionJoypadInterrupt);\n          wasInterruptHandled = true;\n      }\n    }\n\n    // Interrupt handling requires 20 cycles, TCAGBD\n    if(wasInterruptHandled) {\n      let intteruptHandlerCycles: i32 = 20;\n      if(Cpu.isHalted) {\n        // If the CPU was halted, now is the time to un-halt\n        // Should be done here when the jump occurs according to:\n        // https://www.reddit.com/r/EmuDev/comments/6fmjch/gb_glitches_in_links_awakening_and_pok%C3%A9mon_gold/\n        Cpu.isHalted = false;\n        intteruptHandlerCycles += 4;\n      }\n      return intteruptHandlerCycles;\n    }\n  }\n\n  return 0;\n}\n\nfunction _handleInterrupt(bitPosition: u8): void {\n\n  // Disable the master switch\n  setInterrupts(false);\n\n  // Disable the bit on the interruptRequest\n  let interruptRequest = eightBitLoadFromGBMemorySkipTraps(Interrupts.memoryLocationInterruptRequest);\n  interruptRequest = resetBitOnByte(bitPosition, interruptRequest);\n  eightBitStoreIntoGBMemorySkipTraps(Interrupts.memoryLocationInterruptRequest, interruptRequest);\n\n  // Push the programCounter onto the stacks\n  Cpu.stackPointer = Cpu.stackPointer - 2;\n  sixteenBitStoreIntoGBMemorySkipTraps(Cpu.stackPointer, Cpu.programCounter);\n\n  // Jump to the correct interrupt location\n  // http://www.codeslinger.co.uk/pages/projects/gameboy/interupts.html\n  switch(bitPosition) {\n    case Interrupts.bitPositionVBlankInterrupt:\n      Cpu.programCounter = 0x40;\n      break;\n    case Interrupts.bitPositionLcdInterrupt:\n      Cpu.programCounter = 0x48;\n      break;\n    case Interrupts.bitPositionTimerInterrupt:\n      Cpu.programCounter = 0x50;\n      break;\n    case Interrupts.bitPositionJoypadInterrupt:\n      Cpu.programCounter = 0x60;\n      break;\n  }\n}\n\nfunction _requestInterrupt(bitPosition: u8): void {\n\n  let interruptRequest = eightBitLoadFromGBMemorySkipTraps(Interrupts.memoryLocationInterruptRequest);\n\n  // Pass to set the correct interrupt bit on interruptRequest\n  interruptRequest = setBitOnByte(bitPosition, interruptRequest);\n\n  eightBitStoreIntoGBMemorySkipTraps(Interrupts.memoryLocationInterruptRequest, interruptRequest);\n}\n\nexport function setInterrupts(value: boolean): void {\n  Interrupts.masterInterruptSwitch = value;\n}\n\n// Helper function to check if interrupts are enabled\nexport function areInterruptsEnabled(): boolean {\n  return Interrupts.masterInterruptSwitch;\n}\n\n// Useful fo determining the HALT bug\nexport function areInterruptsPending(): boolean {\n  let interruptRequest = eightBitLoadFromGBMemorySkipTraps(Interrupts.memoryLocationInterruptRequest);\n  let interruptEnabled = eightBitLoadFromGBMemorySkipTraps(Interrupts.memoryLocationInterruptEnabled);\n\n  if((interruptRequest & interruptEnabled) !== 0) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function requestVBlankInterrupt(): void {\n  _requestInterrupt(Interrupts.bitPositionVBlankInterrupt);\n}\n\nexport function requestLcdInterrupt(): void {\n  _requestInterrupt(Interrupts.bitPositionLcdInterrupt);\n}\n\nexport function requestTimerInterrupt(): void {\n  _requestInterrupt(Interrupts.bitPositionTimerInterrupt);\n}\n\nexport function requestJoypadInterrupt(): void {\n  _requestInterrupt(Interrupts.bitPositionJoypadInterrupt);\n}\n","import {\n  Cpu\n} from '../cpu/cpu';\nimport {\n  Memory\n} from './memory';\nimport {\n  eightBitLoadFromGBMemory,\n  eightBitLoadFromGBMemorySkipTraps\n} from './load';\nimport {\n  eightBitStoreIntoGBMemory,\n  eightBitStoreIntoGBMemorySkipTraps\n} from './store';\nimport {\n  concatenateBytes,\n  checkBitOnByte,\n  setBitOnByte,\n  resetBitOnByte,\n  hexLog\n} from '../helpers/index';\n\nexport function startDmaTransfer(sourceAddressOffset: u8): void {\n\n  let sourceAddress: u16 = <u16>sourceAddressOffset;\n  sourceAddress = (sourceAddress << 8);\n\n  for(let i: u16 = 0; i < 0xA0; i++) {\n    let spriteInformationByte: u8 = eightBitLoadFromGBMemorySkipTraps(sourceAddress + i);\n    let spriteInformationAddress: u16 = Memory.spriteInformationTableLocation + i;\n    eightBitStoreIntoGBMemorySkipTraps(spriteInformationAddress, spriteInformationByte);\n  }\n\n  // TCAGBD:  This copy (DMA) needs 160 × 4 + 4 clocks to complete in both double speed and single speeds modes\n  // Increment all of our Cycle coiunters in ../cpu/opcodes\n  Memory.DMACycles += 644;\n}\n\n\n// https://gist.github.com/drhelius/3394856\n// http://bgb.bircd.org/pandocs.htm\nexport function startHdmaTransfer(hdmaTriggerByteToBeWritten: u8): void {\n\n  // Check if we are Gbc\n  if(!Cpu.GBCEnabled) {\n    return;\n  }\n\n  // Check if we are trying to terminate an already active HBLANK HDMA\n  // TODO: Pokemon crystal is cancelling it's HDMAs, investigate\n  if (Memory.isHblankHdmaActive && !checkBitOnByte(7, hdmaTriggerByteToBeWritten)) {\n    Memory.isHblankHdmaActive = false;\n    Memory.hblankHdmaIndex = 0x00;\n    Memory.hblankHdmaTotalBytes = 0x00;\n    Memory.hblankHdmaSource = 0x00;\n    Memory.hblankHdmaDestination = 0x00;\n    eightBitStoreIntoGBMemorySkipTraps(Memory.memoryLocationHdmaTrigger, 0xFF);\n    return;\n  }\n\n  // Get our source and destination for the HDMA\n  let hdmaSource: u16 = getHdmaSource();\n  let hdmaDestination: u16 = getHdmaDestination();\n\n  // Get the length from the trigger\n  // Lower 7 bits, Add 1, times 16\n  // https://gist.github.com/drhelius/3394856\n  let transferLength: i32 = resetBitOnByte(7, hdmaTriggerByteToBeWritten);\n  transferLength = (transferLength + 1) * 16;\n\n  // Get bit 7 of the trigger for the HDMA type\n  if (checkBitOnByte(7, hdmaTriggerByteToBeWritten)) {\n\n    // H-Blank DMA\n    Memory.isHblankHdmaActive = true;\n    Memory.hblankHdmaIndex = 0x00;\n    Memory.hblankHdmaTotalBytes = transferLength;\n    Memory.hblankHdmaSource = hdmaSource;\n    Memory.hblankHdmaDestination = hdmaDestination;\n\n    // This will be handled in updateHblankHdma()\n\n    // Since we return false in write traps, we need to now write the byte\n    eightBitStoreIntoGBMemorySkipTraps(Memory.memoryLocationHdmaTrigger, hdmaTriggerByteToBeWritten);\n  } else {\n\n    // General DMA\n    hdmaTransfer(hdmaSource, hdmaDestination, transferLength);\n\n    // Stop the DMA\n    eightBitStoreIntoGBMemorySkipTraps(Memory.memoryLocationHdmaTrigger, 0xFF);\n\n    // Set our Cycles used for the HDMA\n    // Since DMA in GBC Double Speed Mode takes 80 micro seconds,\n    // And HDMA takes 8 micro seconds in GBC Double Speed mode (and GBC Normal Mode)\n    // Will assume (644 / 10) cycles for GBC Double Speed Mode,\n    // and (644 / 10 / 2) for GBC Normal Mode\n    if(Cpu.GBCDoubleSpeed) {\n      Memory.DMACycles += 64;\n    } else {\n      Memory.DMACycles += 32;\n    }\n  }\n}\n\nexport function updateHblankHdma(): void {\n\n  if(!Memory.isHblankHdmaActive) {\n    return;\n  }\n\n  // Get our source and destination for the HDMA\n  let hdmaSource: u16 = getHdmaSource();\n  let hdmaDestination: u16 = getHdmaDestination();\n\n  // Get our amount of bytes to transfer (Only 0x10 bytes at a time)\n  let bytesToTransfer: i32 = 0x10;\n  if (Memory.hblankHdmaIndex + bytesToTransfer > Memory.hblankHdmaTotalBytes) {\n    // Set to the difference\n    bytesToTransfer = Memory.hblankHdmaTotalBytes - Memory.hblankHdmaIndex;\n  }\n\n  // Do the transfer (Only 0x10 bytes at a time)\n  hdmaTransfer(hdmaSource + <u16>Memory.hblankHdmaIndex, hdmaDestination + <u16>Memory.hblankHdmaIndex, bytesToTransfer);\n\n  // Increase our transfer index\n  Memory.hblankHdmaIndex += bytesToTransfer;\n\n  if(Memory.hblankHdmaIndex >= Memory.hblankHdmaTotalBytes) {\n\n    //hexLog(hdmaSource, hdmaDestination, Memory.hblankHdmaIndex, Memory.hblankHdmaTotalBytes);\n\n    // End the transfer\n    Memory.isHblankHdmaActive = false;\n    Memory.hblankHdmaIndex = 0x00;\n    Memory.hblankHdmaTotalBytes = 0x00;\n    Memory.hblankHdmaSource = 0x00;\n    Memory.hblankHdmaDestination = 0x00;\n\n    eightBitStoreIntoGBMemorySkipTraps(Memory.memoryLocationHdmaTrigger, 0xFF);\n  } else {\n    // Set our new transfer length, make sure it is in the weird format, and make sure bit 7 is still 1\n    let remainingTransferLength: i32 = Memory.hblankHdmaTotalBytes - Memory.hblankHdmaIndex;\n    let transferLengthAsByte: u8 = <u8>((remainingTransferLength / 16) - 1);\n    eightBitStoreIntoGBMemorySkipTraps(Memory.memoryLocationHdmaTrigger, setBitOnByte(7, transferLengthAsByte));\n  }\n}\n\n// Simple Function to transfer the bytes from a destination to a source for a general pourpose or Hblank HDMA\nfunction hdmaTransfer(hdmaSource: u16, hdmaDestination: u16, transferLength: i32): void {\n  for(let i: u16 = 0; i < <u16>transferLength; i++) {\n    let sourceByte: u8 = eightBitLoadFromGBMemory(hdmaSource + i);\n    eightBitStoreIntoGBMemory(hdmaDestination + i, sourceByte);\n  }\n}\n\n// Function to get our HDMA Source\n// Follows the poan docs\nfunction getHdmaSource(): u16 {\n  // Get our source for the HDMA\n  let hdmaSourceHigh: u8 = eightBitLoadFromGBMemorySkipTraps(Memory.memoryLocationHdmaSourceHigh);\n  let hdmaSourceLow: u8 = eightBitLoadFromGBMemorySkipTraps(Memory.memoryLocationHdmaSourceLow);\n\n  let hdmaSource: u16 = concatenateBytes(hdmaSourceHigh, hdmaSourceLow);\n\n  // And off the appopriate bits for the source and destination\n  // And off the bottom 4 bits\n  hdmaSource = (hdmaSource & 0xFFF0);\n\n  // Also cache the result\n  Memory.hblankHdmaSource = hdmaSource;\n\n  return hdmaSource;\n}\n\n// Function to get our HDMA Destination\n// Follows the poan docs\nfunction getHdmaDestination(): u16 {\n  let hdmaDestinationHigh: u8 = eightBitLoadFromGBMemorySkipTraps(Memory.memoryLocationHdmaDestinationHigh);\n  let hdmaDestinationLow: u8 = eightBitLoadFromGBMemorySkipTraps(Memory.memoryLocationHdmaDestinationLow);\n\n  let hdmaDestination: u16 = concatenateBytes(hdmaDestinationHigh, hdmaDestinationLow);\n\n  // Can only be in VRAM, 0x8000 -> 0x9FF0\n  // Pan docs says to knock off upper 3 bits, and lower 4 bits\n  // Which gives us: 0001111111110000 or 0x1FF0\n  // Meaning we must add 0x8000\n  hdmaDestination = (hdmaDestination & 0x1FF0);\n  hdmaDestination += Memory.videoRamLocation;\n\n  // Also cache the result\n  Memory.hblankHdmaDestination = hdmaDestination;\n\n  return hdmaDestination;\n}\n","import {\n  Cpu\n} from '../cpu/cpu';\nimport {\n  Memory,\n  eightBitLoadFromGBMemorySkipTraps,\n  eightBitStoreIntoGBMemorySkipTraps,\n  storePaletteByteInWasmMemory,\n  loadPaletteByteFromWasmMemory\n} from '../memory/index';\nimport {\n  checkBitOnByte,\n  resetBitOnByte,\n  setBitOnByte,\n  concatenateBytes,\n  hexLog\n} from '../helpers/index';\n\n// Class for GBC Color palletes\n// http://gbdev.gg8.se/wiki/articles/Video_Display#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index\nexport class Palette {\n  static memoryLocationBackgroundPaletteIndex: u16 = 0xFF68;\n  static memoryLocationBackgroundPaletteData: u16 = 0xFF69;\n  static memoryLocationSpritePaletteIndex: u16 = 0xFF6A;\n  static memoryLocationSpritePaletteData: u16 = 0xFF6B;\n}\n\n// Simple get pallete color or monochroime GB\nexport function getMonochromeColorFromPalette(colorId: u8, paletteMemoryLocation: u16): u8 {\n  // Shift our paletteByte, 2 times for each color ID\n  // And off any extra bytes\n  // Return our Color (00 - white, 01 - light grey, 10 Dark grey, or 11 - Black)\n  let color: u8 = (eightBitLoadFromGBMemorySkipTraps(paletteMemoryLocation) >> (colorId * 2)) & 0x03;\n\n\n  // Since our max is 254, and max is 3.\n  // monochrome color palette is modified from bgb\n  // TODO: Make these colors into a constant\n  let rgbColor: u8 = 242;\n\n  switch (color) {\n    case 0:\n      break;\n    case 1:\n      rgbColor = 160;\n      break;\n    case 2:\n      rgbColor = 88;\n      break;\n    case 3:\n      rgbColor = 8;\n      break;\n  }\n\n  return rgbColor;\n}\n\nexport function writeColorPaletteToMemory(offset: u16, value: u16): void {\n  // FF68\n  //  Bit 0-5   Index (00-3F)\n  if (offset === Palette.memoryLocationBackgroundPaletteData || offset === Palette.memoryLocationSpritePaletteData) {\n    // Get the palette index\n    let paletteIndex: u8 = eightBitLoadFromGBMemorySkipTraps(offset - 1);\n\n    // Clear the 6th bit, as it does nothing\n    paletteIndex = resetBitOnByte(6, paletteIndex);\n\n    // Check if we are changing the sprite pallete data\n    let isSprite: boolean = false;\n    if (offset === Palette.memoryLocationSpritePaletteData) {\n      isSprite = true;\n    }\n\n    storePaletteByteInWasmMemory(paletteIndex, <u8>value, isSprite);\n\n    incrementPaletteIndexIfSet(paletteIndex, offset - 1);\n  }\n}\n\n// Functions to Handle Write to pallete data registers\n// http://gbdev.gg8.se/wiki/articles/Video_Display#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index\n// Function to handle incrementing the pallete index if required\nfunction incrementPaletteIndexIfSet(paletteIndex: u8, offset: u16): void {\n\n  // Check ther auto increment box\n  if (checkBitOnByte(7, paletteIndex)) {\n    // Increment the index, and return the value before the increment\n    // Ensure we don't ouverflow our auto increment bit\n    paletteIndex += 1;\n    paletteIndex = setBitOnByte(7, paletteIndex);\n\n    eightBitStoreIntoGBMemorySkipTraps(offset, paletteIndex);\n  }\n}\n\n// FF68\n// Bit 0-5   Index (00-3F)\n// Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)\n// Index is 00-0x3F because the means 0 - 63 (64),\n// and apparently there are 8 bytes per pallete to describe Color 0-3 (4 colors),\n// and 0-7 (8 palltetes). Therefore, 64!\nexport function getRgbColorFromPalette(paletteId: u8, colorId: u8, isSprite: boolean): u16 {\n\n  // Each Pallete takes 8 bytes, so multiply by 8 to get the pallete\n  // And Each color takes 2 bytes, therefore, multiple by 2 for the correct color bytes in the palette\n  let paletteIndex: u8 = (paletteId * 8) + (colorId * 2);\n\n  // Load the Color that is seperated into two bytes\n  let paletteHighByte: u8 = loadPaletteByteFromWasmMemory(paletteIndex + 1, isSprite);\n  let paletteLowByte: u8 = loadPaletteByteFromWasmMemory(paletteIndex, isSprite);\n\n  // Return the concatenated color byte\n  return concatenateBytes(paletteHighByte, paletteLowByte);\n}\n\n\n// Function to return the color from a passed 16 bit color pallette\nexport function getColorComponentFromRgb(colorId: u8, colorRgb: u16): u8 {\n\n  // Get our bitmask for the color ID\n  // bit mask tested good :)\n  let bitMask: u16 = (0x1F << (colorId * 5));\n  let colorValue: u16 = ((colorRgb & bitMask) >> (colorId * 5));\n\n  // Goal is to reach 254 for each color, so 255 / 31 (0x1F) ~8 TODO: Make exact\n  // Want 5 bits for each\n  return <u8>(colorValue * 8);\n}\n","import {\n  Cpu\n} from './index';\n\n\n// Set flag bit on on register F. For instance set zero flag to zero -> (7, 0)\nfunction setFlagBit(flagBit: u8, flagValue: u8): u8 {\n\n  let bitwiseOperand: u8 = 0x01 << flagBit;\n  if(flagValue > 0) {\n    Cpu.registerF = Cpu.registerF | bitwiseOperand;\n  } else {\n    // XOR out the two ones\n    bitwiseOperand = 0xFF ^ bitwiseOperand;\n    Cpu.registerF = Cpu.registerF & bitwiseOperand;\n  }\n\n  return Cpu.registerF;\n}\n\n// Overload the set flag bit for ease of use\nexport function setZeroFlag(value: u8): void {\n  setFlagBit(7, value);\n}\n\nexport function setSubtractFlag(value: u8): void {\n  setFlagBit(6, value)\n}\n\nexport function setHalfCarryFlag(value: u8): void {\n  setFlagBit(5, value);\n}\n\nexport function setCarryFlag(value: u8): void {\n  setFlagBit(4, value)\n}\n\n// Getters for flags\nexport function getZeroFlag(): u8 {\n  return (Cpu.registerF >> 7) & 0x01;\n}\n\nexport function getSubtractFlag(): u8 {\n  return (Cpu.registerF >> 6) & 0x01;\n}\n\nexport function getHalfCarryFlag(): u8 {\n  return (Cpu.registerF >> 5) & 0x01;\n}\n\nexport function getCarryFlag(): u8 {\n  return (Cpu.registerF >> 4) & 0x01;\n}\n\n// Must be run before the register actually performs the add\n// amountToAdd i16, since max number can be an u8\nexport function checkAndSetEightBitHalfCarryFlag(value: u8, amountToAdd: i16): void {\n  if(amountToAdd >= 0) {\n    // https://robdor.com/2016/08/10/gameboy-emulator-half-carry-flag/\n    let result: u8 = (((<u8>value & 0x0F) + (<u8>amountToAdd & 0x0F)) & 0x10)\n    if(result !== 0x00) {\n      setHalfCarryFlag(1);\n    } else {\n      setHalfCarryFlag(0);\n    }\n  } else {\n    // From: https://github.com/djhworld/gomeboycolor/blob/master/src/cpu/cpu.go\n    // CTRL+F \"subBytes(a, b byte)\"\n    if(<u8>(abs(amountToAdd) & 0x0F) > (value & 0x0F)) {\n      setHalfCarryFlag(1);\n    } else {\n      setHalfCarryFlag(0);\n    }\n  }\n}\n\nexport function checkAndSetEightBitCarryFlag(value: u8, amountToAdd: i16): void {\n  if (amountToAdd >= 0) {\n    let result: u8 = value + <u8>amountToAdd;\n    if (value > result) {\n      setCarryFlag(1);\n    } else {\n      setCarryFlag(0);\n    }\n  } else {\n    if(abs(amountToAdd) > value) {\n      setCarryFlag(1);\n    } else {\n      setCarryFlag(0);\n    }\n  }\n}\n\n// Function to handle 16 bit addition overflow, and set the carry flags accordingly\n// i32 on valueTwo to support passing signed immedaite values\nexport function checkAndSetSixteenBitFlagsAddOverflow(valueOne: u16, valueTwo: i32, useStackPointerBits: boolean): void {\n  // need to differentiate between HL and SP\n  // HL carries are at 11 and 15, SP carries are at 3 and 7 :p\n  if(useStackPointerBits) {\n    // Logic from : https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n    // CTRL+F add_sp_n\n    // using the stack pointer bits means we can safely assume the value is signed\n    let signedValueOne: i32 = <i32>valueOne;\n    let result: i32 = signedValueOne + <i32>valueTwo;\n\n    let flagXor: i32 = signedValueOne ^ valueTwo ^ result;\n\n    if((flagXor & 0x10) !== 0) {\n      setHalfCarryFlag(1);\n    } else {\n      setHalfCarryFlag(0);\n    }\n\n    if((flagXor & 0x100) !== 0) {\n      setCarryFlag(1);\n    } else {\n      setCarryFlag(0);\n    }\n  } else {\n    // Logic from: https://github.com/djhworld/gomeboycolor/blob/master/src/cpu/cpu.go\n    // CTRL+F addWords\n    // Value two is not signed\n    let result: u16 = valueOne + <u16>valueTwo;\n\n    // Check the carry flag by allowing the overflow\n    if(result < valueOne) {\n      setCarryFlag(1);\n    } else {\n      setCarryFlag(0);\n    }\n\n    // To check for half carry flag (bit 15), by XOR'ing valyes, and and'ing the bit in question\n    if ( ((valueOne ^ <u16>valueTwo ^ <u16>result) & 0x1000) !== 0x00 ) {\n      setHalfCarryFlag(1);\n    } else {\n      setHalfCarryFlag(0);\n    }\n  }\n}\n","// Imports\nimport {\n  Cpu\n} from './index';\nimport {\n  setZeroFlag,\n  getZeroFlag,\n  setSubtractFlag,\n  getSubtractFlag,\n  setHalfCarryFlag,\n  getHalfCarryFlag,\n  setCarryFlag,\n  getCarryFlag,\n  checkAndSetEightBitCarryFlag,\n  checkAndSetEightBitHalfCarryFlag,\n  checkAndSetSixteenBitFlagsAddOverflow\n} from './flags';\nimport {\n  rotateByteLeft,\n  rotateByteLeftThroughCarry,\n  rotateByteRight,\n  rotateByteRightThroughCarry,\n  concatenateBytes,\n  hexLog\n} from '../helpers/index';\n\n// General Logic Instructions\n// Such as the ones found on the CB table and 0x40 - 0xBF\n// NOTE: Only CB table uses these for now, was mostly me realizing that I messed up, trying to be all cute and verbose :p\n// NOTE: TODO: Refactor honestly shouldn't take that long, and may happen once assembly script is improved\nexport function addARegister(register: u8): void {\n  checkAndSetEightBitHalfCarryFlag(Cpu.registerA, register);\n  checkAndSetEightBitCarryFlag(Cpu.registerA, register);\n  Cpu.registerA += register;\n  if (Cpu.registerA === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n  setSubtractFlag(0);\n}\n\nexport function addAThroughCarryRegister(register: u8): void {\n  // Handling flags manually as they require some special overflow\n  // From: https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n  // CTRL+F adc\n  let result: u8 = Cpu.registerA + register + getCarryFlag();\n  if (((Cpu.registerA ^ register ^ result) & 0x10) != 0) {\n    setHalfCarryFlag(1);\n  } else {\n    setHalfCarryFlag(0);\n  }\n\n  let overflowedResult: u16 = <u16>Cpu.registerA + <u16>register + <u16>getCarryFlag();\n  if((overflowedResult & 0x100) > 0) {\n    setCarryFlag(1);\n  } else {\n    setCarryFlag(0);\n  }\n\n  Cpu.registerA = result;\n  if (Cpu.registerA === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n  setSubtractFlag(0);\n}\n\nexport function subARegister(register: u8): void {\n  // Need to convert the register on one line, and flip the sign on another\n  let negativeRegister: i16 = <i16>register;\n  negativeRegister = negativeRegister * -1;\n\n  checkAndSetEightBitHalfCarryFlag(Cpu.registerA, <i16>negativeRegister);\n  checkAndSetEightBitCarryFlag(Cpu.registerA, <i16>negativeRegister);\n  Cpu.registerA -= register;\n  if (Cpu.registerA === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n  setSubtractFlag(1);\n}\n\nexport function subAThroughCarryRegister(register: u8): void {\n\n  // Handling flags manually as they require some special overflow\n  // From: https://github.com/nakardo/node-gameboy/blob/master/lib/cpu/opcodes.js\n  // CTRL+F adc\n  let result: u8 = Cpu.registerA - register - getCarryFlag();\n\n  if (((Cpu.registerA ^ register ^ result) & 0x10) != 0) {\n    setHalfCarryFlag(1);\n  } else {\n    setHalfCarryFlag(0);\n  }\n\n  let overflowedResult: u16 = <u16>Cpu.registerA - <u16>register - <u16>getCarryFlag();\n  if((overflowedResult & 0x100) > 0) {\n    setCarryFlag(1);\n  } else {\n    setCarryFlag(0);\n  }\n\n  Cpu.registerA = result;\n  if (Cpu.registerA === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n  setSubtractFlag(1);\n}\n\nexport function andARegister(register: u8): void {\n  Cpu.registerA = (Cpu.registerA & register);\n  if (Cpu.registerA === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n  setSubtractFlag(0);\n  setHalfCarryFlag(1);\n  setCarryFlag(0);\n}\n\nexport function xorARegister(register: u8): void {\n  Cpu.registerA = Cpu.registerA ^ register;\n  if (Cpu.registerA === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n  setCarryFlag(0);\n}\n\nexport function orARegister(register: u8): void {\n  Cpu.registerA = Cpu.registerA | register;\n  if (Cpu.registerA === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n  setCarryFlag(0);\n}\n\nexport function cpARegister(register: u8): void {\n  // 0xB8 - 0xBF\n  // CP B\n  // 1  4\n  // Z 1 H C\n  let negativeRegister: i16 = <i16>register;\n  negativeRegister = negativeRegister * -1;\n  checkAndSetEightBitHalfCarryFlag(Cpu.registerA, <i16>negativeRegister);\n  checkAndSetEightBitCarryFlag(Cpu.registerA, <i16>negativeRegister);\n  let tempResult: i16 = <i16>Cpu.registerA + <i16>negativeRegister;\n  if (tempResult === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n  setSubtractFlag(1);\n}\n\nexport function rotateRegisterLeft(register: u8): u8 {\n\n  // RLC register 8-bit\n  // Z 0 0 C\n  if((register & 0x80) === 0x80) {\n    setCarryFlag(1);\n  } else {\n    setCarryFlag(0);\n  }\n  register = rotateByteLeft(register);\n  if(register === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n\n  // Set all other flags to zero\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n\n  // Return the register\n  return register;\n}\n\nexport function rotateRegisterRight(register: u8): u8 {\n\n  // RLC register 8-bit\n  // Z 0 0 C\n  // Check for the last bit, to see if it will be carried\n  if ((register & 0x01) > 0) {\n    setCarryFlag(1);\n  } else {\n    setCarryFlag(0);\n  }\n  register = rotateByteRight(register);\n\n  if (register === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n\n  // Return the register\n  return register;\n}\n\nexport function rotateRegisterLeftThroughCarry(register: u8): u8 {\n\n  // RL register 8-bit\n  // Z 0 0 C\n  // setting has first bit since we need to use carry\n  let hasHighbit = false;\n  if((register & 0x80) === 0x80) {\n    hasHighbit = true;\n  }\n  register = rotateByteLeftThroughCarry(register);\n\n  if(hasHighbit) {\n    setCarryFlag(1);\n  } else {\n    setCarryFlag(0);\n  }\n\n  if (register === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n\n  return register;\n}\n\nexport function rotateRegisterRightThroughCarry(register: u8): u8 {\n\n  // RR register 8-bit\n  // Z 0 0 C\n  let hasLowBit = false;\n  if((register & 0x01) === 0x01) {\n    hasLowBit = true;\n  }\n  register = rotateByteRightThroughCarry(register);\n\n  if(hasLowBit) {\n    setCarryFlag(1);\n  } else {\n    setCarryFlag(0);\n  }\n\n  if (register === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n\n  return register;\n}\n\nexport function shiftLeftRegister(register: u8): u8 {\n\n  // SLA register 8-bit\n  // Z 0 0 C\n  let hasHighbit = false;\n  if((register & 0x80) === 0x80) {\n    hasHighbit = true;\n  }\n\n  register = register << 1;\n\n  if(hasHighbit) {\n    setCarryFlag(1);\n  } else {\n    setCarryFlag(0);\n  }\n\n  if (register === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n\n  return register;\n}\n\nexport function shiftRightArithmeticRegister(register: u8): u8 {\n\n  // SRA register 8-bit\n  // Z 0 0 C\n  // NOTE: This C flag may need to be set to 0;\n  // This preserves the MSB (Most significant bit)\n  let hasHighbit = false;\n  if((register & 0x80) === 0x80) {\n    hasHighbit = true;\n  }\n\n  let hasLowbit = false;\n  if((register & 0x01) === 0x01) {\n    hasLowbit = true;\n  }\n\n  register = register >> 1;\n\n  if(hasHighbit) {\n    register = (register | 0x80);\n  }\n\n  if (register === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n\n  if(hasLowbit) {\n    setCarryFlag(1);\n  } else {\n    setCarryFlag(0);\n  }\n\n  return register;\n}\n\nexport function swapNibblesOnRegister(register: u8): u8 {\n  // SWAP register 8-bit\n  // Z 0 0 0\n  let highNibble = register & 0xF0;\n  let lowNibble = register & 0x0F;\n  register = (lowNibble << 4) | (highNibble >> 4)\n\n  if (register === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n  setCarryFlag(0);\n\n  return register;\n}\n\nexport function shiftRightLogicalRegister(register: u8): u8 {\n\n  // SRA register 8-bit\n  // Z 0 0 C\n  // NOTE: This C flag may need to be set to 0;\n  // This does NOT preserve MSB (most significant bit)\n\n  let hasLowbit = false;\n  if((register & 0x01) === 0x01) {\n    hasLowbit = true;\n  }\n\n  register = register >> 1;\n\n  if (register === 0) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n\n  setSubtractFlag(0);\n  setHalfCarryFlag(0);\n\n  if(hasLowbit) {\n    setCarryFlag(1);\n  } else {\n    setCarryFlag(0);\n  }\n\n  return register;\n}\n\nexport function testBitOnRegister(bitPosition: u8, register: u8): u8 {\n  // BIT bitPosition ,register 8-bit\n  // Z 0 1 -\n\n  let testByte: u8 = (0x01 << bitPosition);\n  let result = (register & testByte);\n  if(result === 0x00) {\n    setZeroFlag(1);\n  } else {\n    setZeroFlag(0);\n  }\n\n  setSubtractFlag(0);\n  setHalfCarryFlag(1);\n\n  return register;\n}\n\nexport function setBitOnRegister(bitPosition: u8, bitValue: u8, register: u8): u8 {\n\n  // RES 0,B or SET 0,B depending on bit value\n\n  if(bitValue > 0) {\n   let setByte: u8 = (0x01 << bitPosition);\n   register = register | setByte;\n  } else {\n   // NOT (byte we want)\n   // 0000 0100 becomes 1111 1011\n   let setByte: u8 = ~(0x01 << bitPosition);\n   register = register & setByte;\n  }\n\n  return register;\n}\n\n// Private function for our relative jumps\nexport function relativeJump(value: u8): void {\n  // Need to convert the value to i8, since in this case, u8 can be negative\n  let relativeJumpOffset: i8 = <i8>value;\n\n  Cpu.programCounter += relativeJumpOffset;\n  // Realtive jump, using bgb debugger\n  // and my debugger shows,\n  // on JR you need to jump to the relative jump offset,\n  // However, if the jump fails (such as conditional), only jump +2 in total\n\n  Cpu.programCounter += 1;\n}\n","// Imports\nimport {\n  Cpu\n} from './index';\nimport {\n  rotateRegisterLeft,\n  rotateRegisterRight,\n  rotateRegisterLeftThroughCarry,\n  rotateRegisterRightThroughCarry,\n  shiftLeftRegister,\n  shiftRightArithmeticRegister,\n  swapNibblesOnRegister,\n  shiftRightLogicalRegister,\n  testBitOnRegister,\n  setBitOnRegister\n} from './instructions';\nimport {\n  concatenateBytes,\n  performanceTimestamp\n} from '../helpers/index';\nimport {\n  eightBitStoreIntoGBMemory,\n  sixteenBitStoreIntoGBMemory,\n  eightBitLoadFromGBMemory,\n  sixteenBitLoadFromGBMemory\n} from '../memory/index';\n\n\n\n\n// Handle CB Opcodes\n// NOTE: Program stpes and cycles are standardized depending on the register type\n// NOTE: Doing some funny stuff to get around not having arrays or objects\nexport function handleCbOpcode(cbOpcode: u8): i8 {\n\n  let numberOfCycles: i8 = -1;\n  let handledOpcode = false;\n\n  // The result of our cb logic instruction\n  let instructionRegisterValue: u8 = 0;\n  let instructionRegisterResult: u8 = 0;\n\n  // Get our register number by modulo 0x08 (number of registers)\n  // cbOpcode % 0x08\n  let registerNumber = cbOpcode % 0x08;\n\n  // NOTE: registerNumber = register on CB table. Cpu.registerB = 0, Cpu.registerC = 1....Cpu.registerA = 7\n  switch (registerNumber) {\n    case 0:\n      instructionRegisterValue = Cpu.registerB;\n      break;\n    case 1:\n      instructionRegisterValue = Cpu.registerC;\n      break;\n    case 2:\n      instructionRegisterValue = Cpu.registerD;\n      break;\n    case 3:\n      instructionRegisterValue = Cpu.registerE;\n      break;\n    case 4:\n      instructionRegisterValue = Cpu.registerH;\n      break;\n    case 5:\n      instructionRegisterValue = Cpu.registerL;\n      break;\n    case 6:\n      // Value at register HL\n      instructionRegisterValue = eightBitLoadFromGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL));\n      break;\n    case 7:\n      instructionRegisterValue = Cpu.registerA;\n      break;\n  }\n\n  // Grab the high nibble to perform skips to speed up performance\n  let opcodeHighNibble = (cbOpcode & 0xF0);\n  opcodeHighNibble = opcodeHighNibble >> 4;\n\n  // Send to the correct function\n  switch(opcodeHighNibble) {\n    case 0x00:\n      if (cbOpcode <= 0x07) {\n        // RLC register 8-bit\n        // Z 0 0 C\n        instructionRegisterResult = rotateRegisterLeft(instructionRegisterValue);\n        handledOpcode = true;\n      } else if (cbOpcode <= 0x0F) {\n        // RRC register 8-bit\n        // Z 0 0 C\n        instructionRegisterResult = rotateRegisterRight(instructionRegisterValue);\n        handledOpcode = true;\n      }\n      break;\n    case 0x01:\n      if (cbOpcode <= 0x17) {\n        // RL register 8-bit\n        // Z 0 0 C\n        instructionRegisterResult = rotateRegisterLeftThroughCarry(instructionRegisterValue);\n        handledOpcode = true;\n      } else if (cbOpcode <= 0x1F) {\n        // RR register 8-bit\n        // Z 0 0 C\n        instructionRegisterResult = rotateRegisterRightThroughCarry(instructionRegisterValue);\n        handledOpcode = true;\n      }\n      break;\n    case 0x02:\n      if (cbOpcode <= 0x27) {\n        // SLA register 8-bit\n        // Z 0 0 C\n        instructionRegisterResult = shiftLeftRegister(instructionRegisterValue);\n        handledOpcode = true;\n      } else if (cbOpcode <= 0x2F) {\n        // SRA register 8-bit\n        // Z 0 0 0\n        instructionRegisterResult = shiftRightArithmeticRegister(instructionRegisterValue);\n        handledOpcode = true;\n      }\n      break;\n    case 0x03:\n      if (cbOpcode <= 0x37) {\n        // SWAP register 8-bit\n        // Z 0 0 0\n        instructionRegisterResult = swapNibblesOnRegister(instructionRegisterValue);\n        handledOpcode = true;\n      } else if (cbOpcode <= 0x3F) {\n        // SRL B\n        // Z 0 0 C\n        instructionRegisterResult = shiftRightLogicalRegister(instructionRegisterValue);\n        handledOpcode = true;\n      }\n      break;\n    case 0x04:\n      if (cbOpcode <= 0x47) {\n        // BIT 0,register 8-bit\n        // Z 0 1 -\n        //TODO: Optimize this not to do logic of setting register back\n        instructionRegisterResult = testBitOnRegister(0, instructionRegisterValue);\n        handledOpcode = true;\n      } else if (cbOpcode <= 0x4F) {\n        // BIT 1,register 8-bit\n        // Z 0 1 -\n        instructionRegisterResult = testBitOnRegister(1, instructionRegisterValue);\n        handledOpcode = true;\n      }\n      break;\n    case 0x05:\n      if (cbOpcode <= 0x57) {\n        // BIT 2,register 8-bit\n        // Z 0 1 -\n        instructionRegisterResult = testBitOnRegister(2, instructionRegisterValue);\n        handledOpcode = true;\n      } else if (cbOpcode <= 0x5F) {\n        // BIT 3,register 8-bit\n        // Z 0 1 -\n        instructionRegisterResult = testBitOnRegister(3, instructionRegisterValue);\n        handledOpcode = true;\n      }\n      break;\n    case 0x06:\n      if (cbOpcode <= 0x67) {\n        // BIT 4,register 8-bit\n        // Z 0 1 -\n        instructionRegisterResult = testBitOnRegister(4, instructionRegisterValue);\n        handledOpcode = true;\n      } else if (cbOpcode <= 0x6F) {\n        // BIT 5,register 8-bit\n        // Z 0 1 -\n        instructionRegisterResult = testBitOnRegister(5, instructionRegisterValue);\n        handledOpcode = true;\n      }\n      break;\n    case 0x07:\n      if (cbOpcode <= 0x77) {\n        // BIT 6,register 8-bit\n        // Z 0 1 -\n        instructionRegisterResult = testBitOnRegister(6, instructionRegisterValue);\n        handledOpcode = true;\n      } else if (cbOpcode <= 0x7F) {\n        // BIT 7,register 8-bit\n        // Z 0 1 -\n        instructionRegisterResult = testBitOnRegister(7, instructionRegisterValue);\n        handledOpcode = true;\n      }\n      break;\n    case 0x08:\n      if (cbOpcode <= 0x87) {\n        // Res 0,register 8-bit\n        // - - - -\n        instructionRegisterResult = setBitOnRegister(0, 0, instructionRegisterValue);\n        handledOpcode = true;\n      } else if (cbOpcode <= 0x8F) {\n        // Res 1,register 8-bit\n        // - - - -\n        instructionRegisterResult = setBitOnRegister(1, 0, instructionRegisterValue);\n        handledOpcode = true;\n      }\n      break;\n    case 0x09:\n      if (cbOpcode <= 0x97) {\n        // Res 2,register 8-bit\n        // - - - -\n        instructionRegisterResult = setBitOnRegister(2, 0, instructionRegisterValue);\n        handledOpcode = true;\n      } else if (cbOpcode <= 0x9F) {\n        // Res 3,register 8-bit\n        // - - - -\n        instructionRegisterResult = setBitOnRegister(3, 0, instructionRegisterValue);\n        handledOpcode = true;\n      }\n      break;\n    case 0x0A:\n      if (cbOpcode <= 0xA7) {\n        // Res 4,register 8-bit\n        // - - - -\n        instructionRegisterResult = setBitOnRegister(4, 0, instructionRegisterValue);\n        handledOpcode = true;\n      } else if (cbOpcode <= 0xAF) {\n        // Res 5,register 8-bit\n        // - - - -\n        instructionRegisterResult = setBitOnRegister(5, 0, instructionRegisterValue);\n        handledOpcode = true;\n      }\n      break;\n    case 0x0B:\n      if (cbOpcode <= 0xB7) {\n        // Res 6,register 8-bit\n        // - - - -\n        instructionRegisterResult = setBitOnRegister(6, 0, instructionRegisterValue);\n        handledOpcode = true;\n      } else if (cbOpcode <= 0xBF) {\n        // Res 7,register 8-bit\n        // - - - -\n        instructionRegisterResult = setBitOnRegister(7, 0, instructionRegisterValue);\n        handledOpcode = true;\n      }\n      break;\n    case 0x0C:\n      if (cbOpcode <= 0xC7) {\n        // SET 0,register 8-bit\n        // - - - -\n        instructionRegisterResult = setBitOnRegister(0, 1, instructionRegisterValue);\n        handledOpcode = true;\n      } else if (cbOpcode <= 0xCF) {\n        // SET 1,register 8-bit\n        // - - - -\n        instructionRegisterResult = setBitOnRegister(1, 1, instructionRegisterValue);\n        handledOpcode = true;\n      }\n      break;\n    case 0x0D:\n      if (cbOpcode <= 0xD7) {\n        // SET 2,register 8-bit\n        // - - - -\n        instructionRegisterResult = setBitOnRegister(2, 1, instructionRegisterValue);\n        handledOpcode = true;\n      } else if (cbOpcode <= 0xDF) {\n        // SET 3,register 8-bit\n        // - - - -\n        instructionRegisterResult = setBitOnRegister(3, 1, instructionRegisterValue);\n        handledOpcode = true;\n      }\n      break;\n    case 0x0E:\n      if (cbOpcode <= 0xE7) {\n        // SET 4,register 8-bit\n        // - - - -\n        instructionRegisterResult = setBitOnRegister(4, 1, instructionRegisterValue);\n        handledOpcode = true;\n      } else if (cbOpcode <= 0xEF) {\n        // SET 5,register 8-bit\n        // - - - -\n        instructionRegisterResult = setBitOnRegister(5, 1, instructionRegisterValue);\n        handledOpcode = true;\n      }\n      break;\n    case 0x0F:\n      if (cbOpcode <= 0xF7) {\n        // SET 6,register 8-bit\n        // - - - -\n        instructionRegisterResult = setBitOnRegister(6, 1, instructionRegisterValue);\n        handledOpcode = true;\n      } else if (cbOpcode <= 0xFF) {\n        // SET 7,register 8-bit\n        // - - - -\n        instructionRegisterResult = setBitOnRegister(7, 1, instructionRegisterValue);\n        handledOpcode = true;\n      }\n      break;\n  }\n\n  // Finally Pass back into the correct register\n  switch(registerNumber) {\n    case 0:\n      Cpu.registerB = instructionRegisterResult;\n      break;\n    case 1:\n      Cpu.registerC = instructionRegisterResult;\n      break;\n    case 2:\n      Cpu.registerD = instructionRegisterResult;\n      break;\n    case 3:\n      Cpu.registerE = instructionRegisterResult;\n      break;\n    case 4:\n      Cpu.registerH = instructionRegisterResult;\n      break;\n    case 5:\n      Cpu.registerL = instructionRegisterResult;\n      break;\n    case 6:\n      // Value at register HL\n      eightBitStoreIntoGBMemory(concatenateBytes(Cpu.registerH, Cpu.registerL), instructionRegisterResult);\n      break;\n    case 7:\n      Cpu.registerA = instructionRegisterResult;\n      break;\n  }\n\n  // Increase program counter, as all CB codes take two bytes\n  // Program counter will really increase by two since opcodes handles the other\n  Cpu.programCounter += 1;\n\n  // Finally our number of cycles\n  // Set if we handled the opcode\n  if (handledOpcode) {\n    // Next if register number was 6 (HL), number of cycles is 16\n    numberOfCycles = 8;\n    if(registerNumber === 6) {\n      numberOfCycles = 16\n    }\n  }\n\n  // Return our number of cycles\n  return numberOfCycles;\n}\n","// Funcitons for setting and checking the LCD\nimport {\n  Graphics\n} from './graphics';\n// Assembly script really not feeling the reexport\nimport {\n  eightBitLoadFromGBMemorySkipTraps\n} from '../memory/load';\nimport {\n  eightBitStoreIntoGBMemorySkipTraps\n} from '../memory/store';\nimport {\n  requestLcdInterrupt\n} from '../interrupts/index';\nimport {\n  checkBitOnByte,\n  setBitOnByte,\n  resetBitOnByte,\n  hexLog\n} from '../helpers/index';\n\nexport function isLcdEnabled(): boolean {\n  return checkBitOnByte(7, eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationLcdControl));\n}\n\n// Pass in the lcd status for performance\nexport function setLcdStatus(lcdEnabledStatus: boolean): void {\n  // LCD Status (0xFF41) bits Explanation\n  // 0                0                    000                    0             00\n  //       |Coicedence Interrupt|     |Mode Interrupts|  |coincidence flag|    | Mode |\n  // Modes:\n  // 0 or 00: H-Blank\n  // 1 or 01: V-Blank\n  // 2 or 10: Searching Sprites Atts\n  // 3 or 11: Transfering Data to LCD Driver\n\n  let lcdStatus: u8 = eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationLcdStatus);\n  if(!lcdEnabledStatus) {\n    // Reset scanline cycle counter\n    Graphics.scanlineCycleCounter = 0;\n    eightBitStoreIntoGBMemorySkipTraps(Graphics.memoryLocationScanlineRegister, 0);\n\n    // Set to mode 0\n    // https://www.reddit.com/r/EmuDev/comments/4w6479/gb_dr_mario_level_generation_issues/\n    lcdStatus = resetBitOnByte(1, lcdStatus);\n    lcdStatus = resetBitOnByte(0, lcdStatus);\n    Graphics.currentLcdMode = 0;\n\n    // Store the status in memory\n    eightBitStoreIntoGBMemorySkipTraps(Graphics.memoryLocationLcdStatus, lcdStatus);\n    return;\n  }\n\n  // Get our current scanline, and lcd mode\n  let scanlineRegister: u8 = eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationScanlineRegister);\n  let lcdMode: u8 = lcdStatus & 0x03;\n\n  let newLcdMode: u8 = 0;\n  let shouldRequestInterrupt: boolean = false;\n\n  // Find our newLcd mode\n  if(scanlineRegister >= 144) {\n    // VBlank mode\n    newLcdMode = 1;\n    lcdStatus = resetBitOnByte(1, lcdStatus);\n    lcdStatus = setBitOnByte(0, lcdStatus);\n    shouldRequestInterrupt = checkBitOnByte(4, lcdStatus);\n  } else {\n    if (Graphics.scanlineCycleCounter >= Graphics.MIN_CYCLES_SPRITES_LCD_MODE()) {\n      // Searching Sprites Atts\n      newLcdMode = 2;\n      lcdStatus = resetBitOnByte(0, lcdStatus);\n      lcdStatus = setBitOnByte(1, lcdStatus);\n      shouldRequestInterrupt = checkBitOnByte(5, lcdStatus);\n    } else if (Graphics.scanlineCycleCounter >= Graphics.MIN_CYCLES_TRANSFER_DATA_LCD_MODE()) {\n      // Transferring data to lcd\n      newLcdMode = 3;\n      lcdStatus = setBitOnByte(0, lcdStatus);\n      lcdStatus = setBitOnByte(1, lcdStatus);\n    } else {\n      // H-Blank\n      newLcdMode = 0;\n      lcdStatus = resetBitOnByte(0, lcdStatus);\n      lcdStatus = resetBitOnByte(1, lcdStatus);\n      shouldRequestInterrupt = checkBitOnByte(3, lcdStatus);\n    }\n  }\n\n  if (lcdMode !== newLcdMode) {\n    // Check if we want to request an interrupt, and we JUST changed modes\n    if(shouldRequestInterrupt) {\n      requestLcdInterrupt();\n    }\n\n    // Check for the coincidence flag\n    // Need to check on every mode, and not just HBLANK, as checking on hblank breaks shantae, which checks on vblank\n    let coincidenceCompare: u8 = eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationCoincidenceCompare);\n    if((newLcdMode === 0 || newLcdMode === 1) &&\n      scanlineRegister === coincidenceCompare) {\n      lcdStatus = setBitOnByte(2, lcdStatus);\n      if(checkBitOnByte(6, lcdStatus)) {\n        requestLcdInterrupt();\n      }\n    } else {\n      lcdStatus = resetBitOnByte(2, lcdStatus);\n    }\n  }\n\n  // Save our lcd mode\n  Graphics.currentLcdMode = newLcdMode;\n\n  // Finally, save our status\n  eightBitStoreIntoGBMemorySkipTraps(Graphics.memoryLocationLcdStatus, lcdStatus);\n}\n","// Functions for rendering the background\nimport {\n  Cpu\n} from '../cpu/cpu';\nimport {\n  Graphics\n} from './graphics';\nimport {\n  getTileDataAddress\n} from './renderUtils';\nimport {\n  getMonochromeColorFromPalette,\n  getRgbColorFromPalette,\n  getColorComponentFromRgb\n} from './palette';\n// Assembly script really not feeling the reexport\n// using Skip Traps, because LCD has unrestricted access\n// http://gbdev.gg8.se/wiki/articles/Video_Display#LCD_OAM_DMA_Transfers\nimport {\n  eightBitLoadFromGBMemorySkipTraps\n} from '../memory/load';\nimport {\n  Memory,\n  loadFromVramBank,\n  setPixelOnFrame\n} from '../memory/memory';\nimport {\n  hexLog,\n  checkBitOnByte,\n  setBitOnByte,\n  resetBitOnByte\n} from '../helpers/index';\n\nexport function renderBackground(scanlineRegister: u8, tileDataMemoryLocation: u16, tileMapMemoryLocation: u16): void {\n\n  // NOTE: Camera is reffering to what you can see inside the 160x144 viewport of the entire rendered 256x256 map.\n\n  // Get our scrollX and scrollY (u16 to play nice with assemblyscript)\n  let scrollX: u16 = <u16>eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationScrollX);\n  let scrollY: u16 = <u16>eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationScrollY);\n\n  // Get our current pixel y positon on the 160x144 camera (Row that the scanline draws across)\n  // this is done by getting the current scroll Y position,\n  // and adding it do what Y Value the scanline is drawing on the camera.\n  let pixelYPositionInMap: u16 = <u16>scanlineRegister + scrollY;\n\n  // Gameboy camera will \"wrap\" around the background map,\n  // meaning that if the pixelValue is 350, then we need to subtract 256 (decimal) to get it's actual value\n  // pixel values (scrollX and scrollY) range from 0x00 - 0xFF\n  if(pixelYPositionInMap >= 0x100) {\n    pixelYPositionInMap -= 0x100;\n  }\n\n\n  // Draw the Background scanline\n  drawBackgroundWindowScanline(scanlineRegister, tileDataMemoryLocation, tileMapMemoryLocation, pixelYPositionInMap, 0, scrollX);\n}\n\nexport function renderWindow(scanlineRegister: u8, tileDataMemoryLocation: u16, tileMapMemoryLocation: u16): void {\n\n  // Get our windowX and windowY\n  let windowX: u16 = <u16>eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationWindowX);\n  let windowY: u16 = <u16>eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationWindowY);\n\n  // NOTE: Camera is reffering to what you can see inside the 160x144 viewport of the entire rendered 256x256 map.\n\n  // First ensure that the scanline is greater than our window\n  if(scanlineRegister < <u8>windowY) {\n    // Window is not within the current camera view\n    return;\n  }\n\n  // WindowX is offset by 7\n  windowX = windowX - 7;\n\n  // Get our current pixel y positon on the 160x144 camera (Row that the scanline draws across)\n  let pixelYPositionInMap: u16 = <u16>scanlineRegister - windowY;\n\n  // xOffset is simply a neagat5ive window x\n  let xOffset: i32 = -1 * (<i32>windowX);\n\n  // Draw the Background scanline\n  drawBackgroundWindowScanline(scanlineRegister, tileDataMemoryLocation, tileMapMemoryLocation, pixelYPositionInMap, windowX, xOffset);\n}\n\n// Function frankenstein'd together to allow background and window to share the same draw scanline function\nfunction drawBackgroundWindowScanline(scanlineRegister: u8, tileDataMemoryLocation: u16, tileMapMemoryLocation: u16, pixelYPositionInMap: u16, iStart: i32, xOffset: i32): void {\n\n  // Loop through x to draw the line like a CRT\n  for (let i: i32 = iStart; i < 160; i++) {\n\n    // Get our Current X position of our pixel on the on the 160x144 camera\n    // this is done by getting the current scroll X position,\n    // and adding it do what X Value the scanline is drawing on the camera.\n    let pixelXPositionInMap: i32 = i + xOffset;\n\n    // This is to compensate wrapping, same as pixelY\n    if(pixelXPositionInMap >= 0x100) {\n      pixelXPositionInMap -= 0x100;\n    }\n\n    // Divide our pixel position by 8 to get our tile.\n    // Since, there are 256x256 pixels, and 32x32 tiles.\n    // 256 / 8 = 32.\n    // Also, bitshifting by 3, do do a division by 8\n    // Need to use u16s, as they will be used to compute an address, which will cause weird errors and overflows\n    let tileXPositionInMap: i32 = pixelXPositionInMap >> 3;\n    let tileYPositionInMap: i32 = pixelYPositionInMap >> 3;\n\n\n    // Get our tile address on the tileMap\n    // NOTE: (tileMap represents where each tile is displayed on the screen)\n    // NOTE: (tile map represents the entire map, now just what is within the \"camera\")\n    // For instance, if we have y pixel 144. 144 / 8 = 18. 18 * 32 = line address in map memory.\n    // And we have x pixel 160. 160 / 8 = 20.\n    // * 32, because remember, this is NOT only for the camera, the actual map is 32x32. Therefore, the next tile line of the map, is 32 byte offset.\n    // Think like indexing a 2d array, as a 1d array and it make sense :)\n    let tileMapAddress: u16 = tileMapMemoryLocation + <u16>(tileYPositionInMap * 32) + <u16>tileXPositionInMap;\n\n    // Get the tile Id on the Tile Map\n    let tileIdFromTileMap: u8 = loadFromVramBank(tileMapAddress, 0);\n\n    // Now get our tileDataAddress for the corresponding tileID we found in the map\n    // Read the comments in _getTileDataAddress() to see what's going on.\n    // tl;dr if we had the tile map of \"a b c d\", and wanted tileId 2.\n    // This funcitons returns the start of memory locaiton for the tile 'c'.\n    let tileDataAddress: u16 = getTileDataAddress(tileDataMemoryLocation, tileIdFromTileMap);\n\n    if (Cpu.GBCEnabled) {\n      //drawMonochromePixelFromTile(i, scanlineRegister, pixelXPositionInMap, pixelYPositionInMap, tileDataAddress);\n      drawColorPixelFromTile(i, scanlineRegister, pixelXPositionInMap, pixelYPositionInMap, tileMapAddress, tileDataAddress);\n    } else {\n      drawMonochromePixelFromTile(i, scanlineRegister, pixelXPositionInMap, pixelYPositionInMap, tileDataAddress);\n    }\n  }\n}\n\n// Function to draw a pixel for the standard GB\n// TODO: Make this match our new RGB scheme for placing pixels in memory\nfunction drawMonochromePixelFromTile(xPixel: i32, yPixel: u8, pixelXPositionInMap: i32, pixelYPositionInMap: u16, tileDataAddress: u16): void {\n  // Now we can process the the individual bytes that represent the pixel on a tile\n\n  // Get the y pixel of the 8 by 8 tile.\n  // Simply modulo the scanline.\n  // For instance, let's say we are printing the first line of pixels on our camera,\n  // And the first line of pixels on our tile.\n  // yPixel = 1. 1 % 8 = 1.\n  // And for the last line\n  // yPixel = 144. 144 % 8 = 0.\n  // 0 Represents last line of pixels in a tile, 1 represents first. 1 2 3 4 5 6 7 0.\n  // Because remember, we are counting lines on the display NOT including zero\n  let pixelYInTile: u16 = pixelYPositionInMap % 8;\n\n  // Remember to represent a single line of 8 pixels on a tile, we need two bytes.\n  // Therefore, we need to times our modulo by 2, to get the correct line of pixels on the tile.\n  // Again, think like you had to map a 2d array as a 1d.\n  let byteOneForLineOfTilePixels: u8 = loadFromVramBank(tileDataAddress + (pixelYInTile * 2), 0)\n  let byteTwoForLineOfTilePixels: u8 = loadFromVramBank(tileDataAddress + (pixelYInTile * 2) + 1, 0);\n\n  // Same logic as pixelYInTile.\n  // However, We need to reverse our byte,\n  // As pixel 0 is on byte 7, and pixel 1 is on byte 6, etc...\n  // Therefore, is pixelX was 2, then really is need to be 5\n  // So 2 - 7 = -5, * 1 = 5\n  // Or to simplify, 7 - 2 = 5 haha!\n  let pixelXInTile: u8 = <u8>(pixelXPositionInMap) % 8;\n  pixelXInTile = 7 - pixelXInTile;\n\n  // Now we can get the color for that pixel\n  // Colors are represented by getting X position of ByteTwo, and X positon of Byte One\n  // To Get the color Id.\n  // For example, the result of the color id is 0000 00[xPixelByteTwo][xPixelByteOne]\n  // See: How to draw a tile/sprite from memory: http://www.codeslinger.co.uk/pages/projects/gameboy/graphics.html\n  let paletteColorId: u8 = 0;\n  if (checkBitOnByte(<u8>pixelXInTile, byteTwoForLineOfTilePixels)) {\n    // Byte one represents the second bit in our color id, so bit shift\n    paletteColorId += 1;\n    paletteColorId = (paletteColorId << 1);\n  }\n  if (checkBitOnByte(<u8>pixelXInTile, byteOneForLineOfTilePixels)) {\n    paletteColorId += 1;\n  }\n\n  // Now get the colorId from the pallete, to get our final color\n  // Developers could change colorIds to represents different colors\n  // in their palette, thus we need to grab the color from there\n  //let pixelColorInTileFromPalette: u8 = getColorFromPalette(paletteColorId, Graphics.memoryLocationBackgroundPalette);\n  // Moved below for perofrmance\n\n  // FINALLY, RENDER THAT PIXEL!\n  // Only rendering camera for now, so coordinates are for the camera.\n  // Get the rgb value for the color Id, will be repeated into R, G, B\n  let monochromeColor: u8 = getMonochromeColorFromPalette(paletteColorId, Graphics.memoryLocationBackgroundPalette);\n  setPixelOnFrame(xPixel, yPixel, 0, monochromeColor);\n  setPixelOnFrame(xPixel, yPixel, 1, monochromeColor);\n  setPixelOnFrame(xPixel, yPixel, 2, monochromeColor);\n}\n\n// Function to draw a pixel from a tile in C O L O R\n// See above for more context on some variables\nfunction drawColorPixelFromTile(xPixel: i32, yPixel: u8, pixelXPositionInMap: i32, pixelYPositionInMap: u16, tileMapAddress: u16, tileDataAddress: u16): void {\n\n  // TODO: PRIORITY\n\n  // Get the GB Map Attributes\n  // Bit 0-2  Background Palette number  (BGP0-7)\n  // Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)\n  // Bit 4    Not used\n  // Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)\n  // Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)\n  // Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)\n  let bgMapAttributes: u8 = loadFromVramBank(tileMapAddress, 1);\n\n  // See above for explanation\n  let pixelYInTile: u16 = pixelYPositionInMap % 8;\n  if (checkBitOnByte(6, bgMapAttributes)) {\n    // We are mirroring the tile, therefore, we need to opposite byte\n    // So if our pizel was 0 our of 8, it wild become 7 :)\n    // TODO: This may be wrong :p\n    pixelYInTile = 7 - (pixelYInTile);\n  }\n\n  // Remember to represent a single line of 8 pixels on a tile, we need two bytes.\n  // Therefore, we need to times our modulo by 2, to get the correct line of pixels on the tile.\n  // But we need to load the time from a specific Vram bank\n  let vramBankId: i32 = 0;\n  if (checkBitOnByte(3, bgMapAttributes)) {\n    vramBankId = 1;\n  }\n  let byteOneForLineOfTilePixels: u8 = loadFromVramBank(tileDataAddress + (pixelYInTile * 2), vramBankId)\n  let byteTwoForLineOfTilePixels: u8 = loadFromVramBank(tileDataAddress + (pixelYInTile * 2) + 1, vramBankId);\n\n  // Get our X pixel. Need to NOT reverse it if it was flipped.\n  // See above, you have to reverse this normally\n  let pixelXInTile: u8 = <u8>(pixelXPositionInMap) % 8;\n  if(!checkBitOnByte(5, bgMapAttributes)) {\n    pixelXInTile = 7 - pixelXInTile;\n  }\n\n  // Now we can get the color for that pixel\n  // Colors are represented by getting X position of ByteTwo, and X positon of Byte One\n  // To Get the color Id.\n  // For example, the result of the color id is 0000 00[xPixelByteTwo][xPixelByteOne]\n  // See: How to draw a tile/sprite from memory: http://www.codeslinger.co.uk/pages/projects/gameboy/graphics.html\n  let paletteColorId: u8 = 0;\n  if (checkBitOnByte(<u8>pixelXInTile, byteTwoForLineOfTilePixels)) {\n    // Byte one represents the second bit in our color id, so bit shift\n    paletteColorId += 1;\n    paletteColorId = (paletteColorId << 1);\n  }\n  if (checkBitOnByte(<u8>pixelXInTile, byteOneForLineOfTilePixels)) {\n    paletteColorId += 1;\n  }\n\n  // Finally lets add some, C O L O R\n  // Want the botom 3 bits\n  let bgPalette: u8 = (bgMapAttributes & 0x07);\n\n  // Call the helper function to grab the correct color from the palette\n  let rgbColorPalette: u16 = getRgbColorFromPalette(bgPalette, paletteColorId, false);\n\n  // Split off into red green and blue\n  let red: u8 = getColorComponentFromRgb(0, rgbColorPalette);\n  let green: u8 = getColorComponentFromRgb(1, rgbColorPalette);\n  let blue: u8 = getColorComponentFromRgb(2, rgbColorPalette);\n\n  // Finally Place our colors on the things\n  setPixelOnFrame(xPixel, yPixel, 0, red);\n  setPixelOnFrame(xPixel, yPixel, 1, green);\n  setPixelOnFrame(xPixel, yPixel, 2, blue);\n}\n","// utility funcitons to help in rendering\nimport {\n  Graphics\n} from './graphics';\nimport {\n  checkBitOnByte,\n  setBitOnByte,\n  resetBitOnByte\n} from '../helpers/index';\n\nexport function getTileDataAddress(tileDataMemoryLocation: u16, tileIdFromTileMap: u8): u16 {\n\n  // Watch this part of The ultimate gameboy talk: https://youtu.be/HyzD8pNlpwI?t=30m50s\n  // A line of 8 pixels on a single tile, is represented by 2 bytes.\n  // since a single tile is 8x8 pixels, 8 * 2 = 16 bytes\n\n\n  // Get the tile ID's tile addess from tile data.\n  // For instance, let's say our first line of tile data represents tiles for letters:\n  // a b c d e f g\n  // And we have tileId 0x02. That means we want the tile for the 'c' character\n  // Since each tile is 16 bytes, it would be the starting tileDataAddress + (tileId * tileSize), to skip over tiles we dont want\n  // The whole signed thing is weird, and has something to do how the second set of tile data is stored :p\n  if(tileDataMemoryLocation === Graphics.memoryLocationTileDataSelectZeroStart) {\n    // Treat the tile Id as a signed int, subtract an offset of 128\n    // if the tileId was 0 then the tile would be in memory region 0x9000-0x900F\n    // NOTE: Assemblyscript, Can't cast to i16, need to make negative manually\n    let signedTileId: i16 = tileIdFromTileMap + 128;\n    if (checkBitOnByte(7, tileIdFromTileMap)) {\n      signedTileId = <i16>tileIdFromTileMap - 128;\n    }\n    return tileDataMemoryLocation + <u16>(signedTileId * 16);\n  } else {\n    // if the background layout gave us the tileId 0, then the tile data would be between 0x8000-0x800F.\n    return tileDataMemoryLocation + <u16>tileIdFromTileMap * 16;\n  }\n}\n","// Functions for rendering the sprites\nimport {\n  Graphics\n} from './graphics';\nimport {\n  Cpu\n} from '../cpu/cpu';\nimport {\n  getTileDataAddress\n} from './renderUtils';\nimport {\n  getMonochromeColorFromPalette,\n  getRgbColorFromPalette,\n  getColorComponentFromRgb\n} from './palette';\n// Assembly script really not feeling the reexport\n// using Skip Traps, because LCD has unrestricted access\n// http://gbdev.gg8.se/wiki/articles/Video_Display#LCD_OAM_DMA_Transfers\nimport {\n  eightBitLoadFromGBMemorySkipTraps\n} from '../memory/load';\nimport {\n  loadFromVramBank,\n  setPixelOnFrame,\n  getPixelOnFrame\n} from '../memory/memory';\nimport {\n  checkBitOnByte,\n  setBitOnByte,\n  resetBitOnByte,\n  hexLog\n} from '../helpers/index';\n\nexport function renderSprites(scanlineRegister: u8, useLargerSprites: boolean): void {\n\n  // Need to loop through all 40 sprites to check their status\n  for(let i: i32 = 0; i < 40; i++) {\n\n    // Sprites occupy 4 bytes in the sprite attribute table\n    let spriteTableIndex: u16 = <u16>(i * 4);\n    // Y positon is offset by 16, X position is offset by 8\n    // TODO: Why is OAM entry zero???\n    let spriteYPosition: u8 = eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationSpriteAttributesTable + spriteTableIndex);\n    spriteYPosition -= 16;\n    let spriteXPosition: u8 = eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationSpriteAttributesTable + spriteTableIndex + 1);\n    spriteXPosition -= 8;\n    let spriteTileId: u8 = eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationSpriteAttributesTable + spriteTableIndex + 2);\n    let spriteAttributes: u8 = eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationSpriteAttributesTable + spriteTableIndex + 3);\n\n    // Check sprite Priority\n    let isSpritePriorityBehindWindowAndBackground: boolean = checkBitOnByte(7, spriteAttributes);\n\n    // Check if we should flip the sprite on the x or y axis\n    let flipSpriteY: boolean = checkBitOnByte(6, spriteAttributes);\n    let flipSpriteX: boolean = checkBitOnByte(5, spriteAttributes);\n\n    // Find our sprite height\n    let spriteHeight: u8 = 8;\n    if(useLargerSprites) {\n      spriteHeight = 16;\n    }\n\n    // Find if our sprite is on the current scanline\n    if(scanlineRegister >= spriteYPosition && scanlineRegister < (spriteYPosition + spriteHeight)) {\n      // Then we need to draw the current sprite\n\n      // Find which line on the sprite we are on\n      let currentSpriteLine: i16 = scanlineRegister - spriteYPosition;\n\n      // If we fliiped the Y axis on our sprite, need to read from memory backwards to acheive the same effect\n      if(flipSpriteY) {\n        currentSpriteLine -= <i16>spriteHeight;\n        currentSpriteLine = currentSpriteLine * -1;\n\n        // Bug fix for the flipped flies in link's awakening\n        currentSpriteLine -= 1;\n      }\n      // Each line of a tile takes two bytes of memory\n      currentSpriteLine = currentSpriteLine * 2;\n\n      // Get our sprite tile address, need to also add the current sprite line to get the correct bytes\n      let spriteTileAddressStart: i32 = <i32>getTileDataAddress(Graphics.memoryLocationTileDataSelectOneStart, spriteTileId);\n      spriteTileAddressStart = spriteTileAddressStart + currentSpriteLine;\n      let spriteTileAddress: u16 = <u16>spriteTileAddressStart;\n\n      // Find which VRAM Bank to load from\n      let vramBankId: i32 = 0;\n      if (Cpu.GBCEnabled && checkBitOnByte(3, spriteAttributes)) {\n        vramBankId = 1;\n      }\n      let spriteDataByteOneForLineOfTilePixels: u8 = loadFromVramBank(spriteTileAddress, vramBankId);\n      let spriteDataByteTwoForLineOfTilePixels: u8 = loadFromVramBank(spriteTileAddress + 1, vramBankId);\n\n      // Iterate over the width of our sprite to find our individual pixels\n      for(let tilePixel: i8 = 7; tilePixel >= 0; tilePixel--) {\n\n        // Get our spritePixel, and check for flipping\n        let spritePixelXInTile: i8 = tilePixel;\n        if(flipSpriteX) {\n          spritePixelXInTile -= 7;\n          spritePixelXInTile = spritePixelXInTile * -1;\n        }\n\n        // Get the color Id of our sprite, similar to renderBackground()\n        // With the first byte, and second byte lined up method thing\n        // Yes, the second byte comes before the first, see ./background.ts\n        let spriteColorId: u8 = 0;\n        if (checkBitOnByte(<u8>spritePixelXInTile, spriteDataByteTwoForLineOfTilePixels)) {\n          // Byte one represents the second bit in our color id, so bit shift\n          spriteColorId += 1;\n          spriteColorId = (spriteColorId << 1);\n        }\n        if (checkBitOnByte(<u8>spritePixelXInTile, spriteDataByteOneForLineOfTilePixels)) {\n          spriteColorId += 1;\n        }\n\n        // ColorId zero (last two bits of pallette) are transparent\n        // http://gbdev.gg8.se/wiki/articles/Video_Display\n        if (spriteColorId !== 0) {\n\n          // Find our actual X pixel location on the gameboy \"camera\" view\n          let spriteXPixelLocationInCameraView: u8 = spriteXPosition + (7 - <u8>tilePixel);\n\n          // Now that we have our coordinates, check sprite priority\n          // Remember, set pixel on frame increases the value by one!\n          if (!isSpritePriorityBehindWindowAndBackground ||\n            getPixelOnFrame(spriteXPixelLocationInCameraView, scanlineRegister) >= 200) {\n\n            if(!Cpu.GBCEnabled) {\n              // Get our monochrome color RGB from the current sprite pallete\n              // Get our sprite pallete\n              let spritePaletteLocation: u16 = Graphics.memoryLocationSpritePaletteOne;\n              if (checkBitOnByte(4, spriteAttributes)) {\n                spritePaletteLocation = Graphics.memoryLocationSpritePaletteTwo;\n              }\n              let spritePixelColorFromPalette: u8 = getMonochromeColorFromPalette(spriteColorId, spritePaletteLocation);\n\n              // Finally set the pixel!\n              setPixelOnFrame(spriteXPixelLocationInCameraView, scanlineRegister, 0, spritePixelColorFromPalette);\n              setPixelOnFrame(spriteXPixelLocationInCameraView, scanlineRegister, 1, spritePixelColorFromPalette);\n              setPixelOnFrame(spriteXPixelLocationInCameraView, scanlineRegister, 2, spritePixelColorFromPalette);\n            } else {\n\n              // Get our RGB Color\n\n              // Finally lets add some, C O L O R\n              // Want the botom 3 bits\n              let bgPalette: u8 = (spriteAttributes & 0x07);\n\n              // Call the helper function to grab the correct color from the palette\n              let rgbColorPalette: u16 = getRgbColorFromPalette(bgPalette, spriteColorId, true);\n\n              // Split off into red green and blue\n              let red: u8 = getColorComponentFromRgb(0, rgbColorPalette);\n              let green: u8 = getColorComponentFromRgb(1, rgbColorPalette);\n              let blue: u8 = getColorComponentFromRgb(2, rgbColorPalette);\n\n              // Finally Place our colors on the things\n              setPixelOnFrame(spriteXPixelLocationInCameraView, scanlineRegister, 0, red);\n              setPixelOnFrame(spriteXPixelLocationInCameraView, scanlineRegister, 1, green);\n              setPixelOnFrame(spriteXPixelLocationInCameraView, scanlineRegister, 2, blue);\n            }\n          }\n        }\n\n        // Done!\n      }\n    }\n  }\n}\n","// Functions to get information about the emulator for debugging purposes\nimport {\n  Cpu\n} from'../cpu/cpu';\nimport {\n  eightBitLoadFromGBMemorySkipTraps\n} from '../memory/index';\n\nexport function getRegisterA(): u8 {\n  return Cpu.registerA;\n}\n\nexport function getRegisterB(): u8 {\n  return Cpu.registerB;\n}\n\nexport function getRegisterC(): u8 {\n  return Cpu.registerC;\n}\n\nexport function getRegisterD(): u8 {\n  return Cpu.registerD;\n}\n\nexport function getRegisterE(): u8 {\n  return Cpu.registerE;\n}\n\nexport function getRegisterH(): u8 {\n  return Cpu.registerH;\n}\n\nexport function getRegisterL(): u8 {\n  return Cpu.registerL;\n}\n\nexport function getRegisterF(): u8 {\n  return Cpu.registerF;\n}\n\nexport function getProgramCounter(): u16 {\n  return Cpu.programCounter;\n}\n\nexport function getStackPointer(): u16 {\n  return Cpu.stackPointer;\n}\n\nexport function getOpcodeAtProgramCounter(): u8 {\n  return eightBitLoadFromGBMemorySkipTraps(Cpu.programCounter);\n}\n","// Functions to debug graphical output\nimport {\n  backgroundMapLocation\n} from '../constants/constants';\nimport {\n  Graphics\n} from '../graphics/graphics';\nimport {\n  Cpu\n} from '../cpu/cpu';\nimport {\n  getTileDataAddress\n} from '../graphics/renderUtils';\nimport {\n  getMonochromeColorFromPalette,\n  getRgbColorFromPalette,\n  getColorComponentFromRgb\n} from '../graphics/palette';\nimport {\n  eightBitLoadFromGBMemorySkipTraps,\n  Memory,\n  loadFromVramBank\n} from '../memory/index';\nimport {\n  checkBitOnByte\n} from '../helpers/index';\n\nexport function drawBackgroundMapToWasmMemory(showColor: i32 = 0): void {\n  // http://www.codeslinger.co.uk/pages/projects/gameboy/graphics.html\n  // Bit 7 - LCD Display Enable (0=Off, 1=On)\n  // Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)\n  // Bit 5 - Window Display Enable (0=Off, 1=On)\n  // Bit 4 - BG & Window Tile Data Select (0=8800-97FF, 1=8000-8FFF)\n  // Bit 3 - BG Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)\n  // Bit 2 - OBJ (Sprite) Size (0=8x8, 1=8x16)\n  // Bit 1 - OBJ (Sprite) Display Enable (0=Off, 1=On)\n  // Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)\n\n  // Get our lcd control, see above for usage\n  let lcdControl: u8 = eightBitLoadFromGBMemorySkipTraps(Graphics.memoryLocationLcdControl);\n\n  // Get our seleted tile data memory location\n  let tileDataMemoryLocation = Graphics.memoryLocationTileDataSelectZeroStart;\n  if(checkBitOnByte(4, lcdControl)) {\n    tileDataMemoryLocation = Graphics.memoryLocationTileDataSelectOneStart;\n  }\n\n  let tileMapMemoryLocation = Graphics.memoryLocationTileMapSelectZeroStart;\n  if (checkBitOnByte(3, lcdControl)) {\n    tileMapMemoryLocation = Graphics.memoryLocationTileMapSelectOneStart;\n  }\n\n  for(let y: i32 = 0; y < 256; y++) {\n    for (let x: i32 = 0; x < 256; x++) {\n\n      // Get our current Y\n      let pixelYPositionInMap: u16 = <u16>y;\n\n      // Get our Current X position of our pixel on the on the 160x144 camera\n      // this is done by getting the current scroll X position,\n      // and adding it do what X Value the scanline is drawing on the camera.\n      let pixelXPositionInMap: i32 = x;\n\n      // Divide our pixel position by 8 to get our tile.\n      // Since, there are 256x256 pixels, and 32x32 tiles.\n      // 256 / 8 = 32.\n      // Also, bitshifting by 3, do do a division by 8\n      // Need to use u16s, as they will be used to compute an address, which will cause weird errors and overflows\n      let tileXPositionInMap: i32 = pixelXPositionInMap >> 3;\n      let tileYPositionInMap: i32 = pixelYPositionInMap >> 3;\n\n      // Get our tile address on the tileMap\n      // NOTE: (tileMap represents where each tile is displayed on the screen)\n      // NOTE: (tile map represents the entire map, now just what is within the \"camera\")\n      // For instance, if we have y pixel 144. 144 / 8 = 18. 18 * 32 = line address in map memory.\n      // And we have x pixel 160. 160 / 8 = 20.\n      // * 32, because remember, this is NOT only for the camera, the actual map is 32x32. Therefore, the next tile line of the map, is 32 byte offset.\n      // Think like indexing a 2d array, as a 1d array and it make sense :)\n      let tileMapAddress: u16 = tileMapMemoryLocation + <u16>(tileYPositionInMap * 32) + <u16>tileXPositionInMap;\n\n      // Get the tile Id on the Tile Map\n      let tileIdFromTileMap: u8 = loadFromVramBank(tileMapAddress, 0);\n\n      // Now get our tileDataAddress for the corresponding tileID we found in the map\n      // Read the comments in _getTileDataAddress() to see what's going on.\n      // tl;dr if we had the tile map of \"a b c d\", and wanted tileId 2.\n      // This funcitons returns the start of memory locaiton for the tile 'c'.\n      let tileDataAddress: u16 = getTileDataAddress(tileDataMemoryLocation, tileIdFromTileMap);\n\n      // Now we can process the the individual bytes that represent the pixel on a tile\n\n      // Get the y pixel of the 8 by 8 tile.\n      // Simply modulo the scanline.\n      // For instance, let's say we are printing the first line of pixels on our camera,\n      // And the first line of pixels on our tile.\n      // yPixel = 1. 1 % 8 = 1.\n      // And for the last line\n      // yPixel = 144. 144 % 8 = 0.\n      // 0 Represents last line of pixels in a tile, 1 represents first. 1 2 3 4 5 6 7 0.\n      // Because remember, we are counting lines on the display NOT including zero\n      let pixelYInTile: u16 = pixelYPositionInMap % 8;\n\n      // Same logic as pixelYInTile.\n      // However, We need to reverse our byte,\n      // As pixel 0 is on byte 7, and pixel 1 is on byte 6, etc...\n      // Therefore, is pixelX was 2, then really is need to be 5\n      // So 2 - 7 = -5, * 1 = 5\n      // Or to simplify, 7 - 2 = 5 haha!\n      let pixelXInTile: u8 = <u8>(pixelXPositionInMap) % 8;\n      pixelXInTile = 7 - pixelXInTile;\n\n      // Get the GB Map Attributes\n      // Bit 0-2  Background Palette number  (BGP0-7)\n      // Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)\n      // Bit 4    Not used\n      // Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)\n      // Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)\n      // Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)\n      let bgMapAttributes: u8 = 0;\n      if(Cpu.GBCEnabled && showColor > 0) {\n        bgMapAttributes = loadFromVramBank(tileMapAddress, 1);\n      }\n\n      if (checkBitOnByte(6, bgMapAttributes)) {\n        // We are mirroring the tile, therefore, we need to opposite byte\n        // So if our pizel was 0 our of 8, it wild become 7 :)\n        // TODO: This may be wrong :p\n        pixelYInTile = 7 - (pixelYInTile);\n      }\n\n      // Remember to represent a single line of 8 pixels on a tile, we need two bytes.\n      // Therefore, we need to times our modulo by 2, to get the correct line of pixels on the tile.\n      // But we need to load the time from a specific Vram bank\n      let vramBankId: i32 = 0;\n      if (checkBitOnByte(3, bgMapAttributes)) {\n        vramBankId = 1;\n      }\n\n      // Remember to represent a single line of 8 pixels on a tile, we need two bytes.\n      // Therefore, we need to times our modulo by 2, to get the correct line of pixels on the tile.\n      // Again, think like you had to map a 2d array as a 1d.\n      let byteOneForLineOfTilePixels: u8 = loadFromVramBank(tileDataAddress + (pixelYInTile * 2), vramBankId)\n      let byteTwoForLineOfTilePixels: u8 = loadFromVramBank(tileDataAddress + (pixelYInTile * 2) + 1, vramBankId);\n\n      // Now we can get the color for that pixel\n      // Colors are represented by getting X position of ByteTwo, and X positon of Byte One\n      // To Get the color Id.\n      // For example, the result of the color id is 0000 00[xPixelByteTwo][xPixelByteOne]\n      // See: How to draw a tile/sprite from memory: http://www.codeslinger.co.uk/pages/projects/gameboy/graphics.html\n      let paletteColorId: u8 = 0;\n      if (checkBitOnByte(<u8>pixelXInTile, byteTwoForLineOfTilePixels)) {\n        // Byte one represents the second bit in our color id, so bit shift\n        paletteColorId += 1;\n        paletteColorId = (paletteColorId << 1);\n      }\n      if (checkBitOnByte(<u8>pixelXInTile, byteOneForLineOfTilePixels)) {\n        paletteColorId += 1;\n      }\n\n      // FINALLY, RENDER THAT PIXEL!\n      let pixelStart: i32 = ((y * 256) + x) * 3;\n\n      if(Cpu.GBCEnabled && showColor > 0) {\n        // Finally lets add some, C O L O R\n        // Want the botom 3 bits\n        let bgPalette: u8 = (bgMapAttributes & 0x07);\n\n        // Call the helper function to grab the correct color from the palette\n        let rgbColorPalette: u16 = getRgbColorFromPalette(bgPalette, paletteColorId, false);\n\n        // Split off into red green and blue\n        let red: u8 = getColorComponentFromRgb(0, rgbColorPalette);\n        let green: u8 = getColorComponentFromRgb(1, rgbColorPalette);\n        let blue: u8 = getColorComponentFromRgb(2, rgbColorPalette);\n\n        let offset: i32 = backgroundMapLocation + pixelStart;\n        store<u8>(offset, red);\n        store<u8>(offset + 1, green);\n        store<u8>(offset + 2, blue);\n      } else {\n\n        // Only rendering camera for now, so coordinates are for the camera.\n        // Get the rgb value for the color Id, will be repeated into R, G, B\n        let monochromeColor: u8 = getMonochromeColorFromPalette(paletteColorId, Graphics.memoryLocationBackgroundPalette);\n\n        for(let i: i32 = 0; i < 3; i++) {\n          let offset: i32 = backgroundMapLocation + pixelStart + i;\n          store<u8>(offset, monochromeColor);\n        }\n      }\n    }\n  }\n}\n\nexport function drawTileDataToWasmMemory(showColor: i32 = 0): void {\n  \n}\n","// Imports\nimport {\n  Cpu\n} from './cpu/index';\nimport {\n  Graphics\n} from './graphics/index';\nimport {\n  Interrupts\n} from './interrupts/index';\nimport {\n  Joypad\n} from './joypad/index';\nimport {\n  Memory\n} from './memory/index';\nimport {\n  Timers\n} from './timers/index';\nimport {\n  Sound,\n  Channel1,\n  Channel2,\n  Channel3,\n  Channel4\n} from './sound/index';\nimport {\n  eightBitLoadFromGBMemory\n} from './memory/index';\nimport {\n  performanceTimestamp\n} from './helpers/index'\n\n// Public Exports\nexport {\n  initialize\n} from './cpu/index';\nexport {\n  config\n} from './config';\nexport {\n  update,\n  emulationStep\n} from './cpu/opcodes';\nexport {\n  areInterruptsEnabled\n} from './interrupts/index';\nexport {\n  setJoypadState\n} from './joypad/index';\nexport {\n  getAudioQueueIndex,\n  resetAudioQueue\n} from './sound/index';\nexport {\n  wasmMemorySize,\n  wasmBoyInternalStateLocation,\n  wasmBoyInternalStateSize,\n  gameBoyInternalMemoryLocation,\n  gameBoyInternalMemorySize,\n  videoOutputLocation,\n  currentFrameVideoOutputLocation,\n  frameInProgressVideoOutputLocation,\n  gameboyColorPaletteLocation,\n  backgroundMapLocation,\n  soundOutputLocation,\n  gameBytesLocation,\n  gameRamBanksLocation\n} from './constants/constants';\nexport {\n  getWasmBoyOffsetFromGameBoyOffset\n} from './memory/memoryMap';\nexport {\n  getRegisterA,\n  getRegisterB,\n  getRegisterC,\n  getRegisterD,\n  getRegisterE,\n  getRegisterH,\n  getRegisterL,\n  getRegisterF,\n  getProgramCounter,\n  getStackPointer,\n  getOpcodeAtProgramCounter,\n  drawBackgroundMapToWasmMemory\n} from './debug/debug';\n\n// Function to save state to memory for all of our classes\nexport function saveState(): void {\n  Cpu.saveState();\n  Graphics.saveState();\n  Interrupts.saveState();\n  Joypad.saveState();\n  Memory.saveState();\n  Timers.saveState();\n  Sound.saveState();\n  Channel1.saveState();\n  Channel2.saveState();\n  Channel3.saveState();\n  Channel4.saveState();\n}\n\n// Function to load state from memory for all of our classes\nexport function loadState(): void {\n  Cpu.loadState();\n  Graphics.loadState();\n  Interrupts.loadState();\n  Joypad.loadState();\n  Memory.loadState();\n  Timers.loadState();\n  Sound.loadState();\n  Channel1.loadState();\n  Channel2.loadState();\n  Channel3.loadState();\n  Channel4.loadState();\n}\n"]}